var H0 = Object.defineProperty;
var G0 = (n, e, t) =>
  e in n
    ? H0(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (n[e] = t);
var fn = (n, e, t) => (G0(n, typeof e != "symbol" ? e + "" : e, t), t),
  V0 = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  };
var Tl = (n, e, t) => {
  if (e.has(n))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(n) : e.set(n, t);
};
var pu = (n, e, t) => (V0(n, e, "access private method"), t);
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const a of i)
      if (a.type === "childList")
        for (const s of a.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const a = {};
    return (
      i.integrity && (a.integrity = i.integrity),
      i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (a.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (a.credentials = "omit")
        : (a.credentials = "same-origin"),
      a
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const a = t(i);
    fetch(i.href, a);
  }
})();
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Ic = "156",
  bi = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  _i = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  W0 = 0,
  Cl = 1,
  q0 = 2,
  Ep = 1,
  $0 = 2,
  rr = 3,
  lr = 0,
  en = 1,
  jt = 2,
  Tr = 0,
  ea = 1,
  Nl = 2,
  Rl = 3,
  Fl = 4,
  j0 = 5,
  Wi = 100,
  X0 = 101,
  Y0 = 102,
  Pl = 103,
  Ll = 104,
  Z0 = 200,
  J0 = 201,
  K0 = 202,
  Q0 = 203,
  Sp = 204,
  Mp = 205,
  ev = 206,
  tv = 207,
  nv = 208,
  rv = 209,
  iv = 210,
  av = 0,
  sv = 1,
  ov = 2,
  uc = 3,
  uv = 4,
  cv = 5,
  lv = 6,
  fv = 7,
  Oc = 0,
  hv = 1,
  dv = 2,
  Cr = 0,
  pv = 1,
  mv = 2,
  gv = 3,
  vv = 4,
  yv = 5,
  Ap = 300,
  sa = 301,
  oa = 302,
  Mo = 303,
  cc = 304,
  Ho = 306,
  lc = 1e3,
  Pn = 1001,
  fc = 1002,
  Qt = 1003,
  Il = 1004,
  mu = 1005,
  wn = 1006,
  xv = 1007,
  es = 1008,
  Nr = 1009,
  bv = 1010,
  _v = 1011,
  Uc = 1012,
  Dp = 1013,
  Er = 1014,
  Sr = 1015,
  ts = 1016,
  Tp = 1017,
  Cp = 1018,
  Qr = 1020,
  wv = 1021,
  Ln = 1023,
  Ev = 1024,
  Sv = 1025,
  ei = 1026,
  ua = 1027,
  Mv = 1028,
  Np = 1029,
  Av = 1030,
  Rp = 1031,
  Fp = 1033,
  gu = 33776,
  vu = 33777,
  yu = 33778,
  xu = 33779,
  Ol = 35840,
  Ul = 35841,
  Bl = 35842,
  zl = 35843,
  Dv = 36196,
  kl = 37492,
  Hl = 37496,
  Gl = 37808,
  Vl = 37809,
  Wl = 37810,
  ql = 37811,
  $l = 37812,
  jl = 37813,
  Xl = 37814,
  Yl = 37815,
  Zl = 37816,
  Jl = 37817,
  Kl = 37818,
  Ql = 37819,
  ef = 37820,
  tf = 37821,
  bu = 36492,
  nf = 36494,
  rf = 36495,
  Tv = 36283,
  af = 36284,
  sf = 36285,
  of = 36286,
  Pp = 3e3,
  ti = 3001,
  Cv = 3200,
  Nv = 3201,
  Bc = 0,
  Rv = 1,
  ni = "",
  gt = "srgb",
  Gn = "srgb-linear",
  Go = "display-p3",
  _u = 7680,
  Fv = 519,
  Pv = 512,
  Lv = 513,
  Iv = 514,
  Ov = 515,
  Uv = 516,
  Bv = 517,
  zv = 518,
  kv = 519,
  uf = 35044,
  cf = "300 es",
  hc = 1035,
  sr = 2e3,
  Ao = 2001;
class ci {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const a = i.indexOf(t);
      a !== -1 && i.splice(a, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let a = 0, s = i.length; a < s; a++) i[a].call(this, e);
      e.target = null;
    }
  }
}
const qt = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let lf = 1234567;
const qa = Math.PI / 180,
  ns = 180 / Math.PI;
function li() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    qt[n & 255] +
    qt[(n >> 8) & 255] +
    qt[(n >> 16) & 255] +
    qt[(n >> 24) & 255] +
    "-" +
    qt[e & 255] +
    qt[(e >> 8) & 255] +
    "-" +
    qt[((e >> 16) & 15) | 64] +
    qt[(e >> 24) & 255] +
    "-" +
    qt[(t & 63) | 128] +
    qt[(t >> 8) & 255] +
    "-" +
    qt[(t >> 16) & 255] +
    qt[(t >> 24) & 255] +
    qt[r & 255] +
    qt[(r >> 8) & 255] +
    qt[(r >> 16) & 255] +
    qt[(r >> 24) & 255]
  ).toLowerCase();
}
function Ut(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function zc(n, e) {
  return ((n % e) + e) % e;
}
function Hv(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function Gv(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function $a(n, e, t) {
  return (1 - t) * n + t * e;
}
function Vv(n, e, t, r) {
  return $a(n, e, 1 - Math.exp(-t * r));
}
function Wv(n, e = 1) {
  return e - Math.abs(zc(n, e * 2) - e);
}
function qv(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function $v(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function jv(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function Xv(n, e) {
  return n + Math.random() * (e - n);
}
function Yv(n) {
  return n * (0.5 - Math.random());
}
function Zv(n) {
  n !== void 0 && (lf = n);
  let e = (lf += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function Jv(n) {
  return n * qa;
}
function Kv(n) {
  return n * ns;
}
function dc(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function Qv(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Do(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function ey(n, e, t, r, i) {
  const a = Math.cos,
    s = Math.sin,
    o = a(t / 2),
    c = s(t / 2),
    u = a((e + r) / 2),
    l = s((e + r) / 2),
    f = a((e - r) / 2),
    h = s((e - r) / 2),
    d = a((r - e) / 2),
    g = s((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(o * l, c * f, c * h, o * u);
      break;
    case "YZY":
      n.set(c * h, o * l, c * f, o * u);
      break;
    case "ZXZ":
      n.set(c * f, c * h, o * l, o * u);
      break;
    case "XZX":
      n.set(o * l, c * g, c * d, o * u);
      break;
    case "YXY":
      n.set(c * d, o * l, c * g, o * u);
      break;
    case "ZYZ":
      n.set(c * g, c * d, o * l, o * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function qi(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Jt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Ba = {
  DEG2RAD: qa,
  RAD2DEG: ns,
  generateUUID: li,
  clamp: Ut,
  euclideanModulo: zc,
  mapLinear: Hv,
  inverseLerp: Gv,
  lerp: $a,
  damp: Vv,
  pingpong: Wv,
  smoothstep: qv,
  smootherstep: $v,
  randInt: jv,
  randFloat: Xv,
  randFloatSpread: Yv,
  seededRandom: Zv,
  degToRad: Jv,
  radToDeg: Kv,
  isPowerOfTwo: dc,
  ceilPowerOfTwo: Qv,
  floorPowerOfTwo: Do,
  setQuaternionFromProperEuler: ey,
  normalize: Jt,
  denormalize: qi,
};
class De {
  constructor(e = 0, t = 0) {
    (De.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Ut(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      a = this.x - e.x,
      s = this.y - e.y;
    return (this.x = a * r - s * i + e.x), (this.y = a * i + s * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Je {
  constructor(e, t, r, i, a, s, o, c, u) {
    (Je.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, a, s, o, c, u);
  }
  set(e, t, r, i, a, s, o, c, u) {
    const l = this.elements;
    return (
      (l[0] = e),
      (l[1] = i),
      (l[2] = o),
      (l[3] = t),
      (l[4] = a),
      (l[5] = c),
      (l[6] = r),
      (l[7] = s),
      (l[8] = u),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      a = this.elements,
      s = r[0],
      o = r[3],
      c = r[6],
      u = r[1],
      l = r[4],
      f = r[7],
      h = r[2],
      d = r[5],
      g = r[8],
      x = i[0],
      m = i[3],
      p = i[6],
      S = i[1],
      v = i[4],
      y = i[7],
      E = i[2],
      M = i[5],
      T = i[8];
    return (
      (a[0] = s * x + o * S + c * E),
      (a[3] = s * m + o * v + c * M),
      (a[6] = s * p + o * y + c * T),
      (a[1] = u * x + l * S + f * E),
      (a[4] = u * m + l * v + f * M),
      (a[7] = u * p + l * y + f * T),
      (a[2] = h * x + d * S + g * E),
      (a[5] = h * m + d * v + g * M),
      (a[8] = h * p + d * y + g * T),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      a = e[3],
      s = e[4],
      o = e[5],
      c = e[6],
      u = e[7],
      l = e[8];
    return (
      t * s * l - t * o * u - r * a * l + r * o * c + i * a * u - i * s * c
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      a = e[3],
      s = e[4],
      o = e[5],
      c = e[6],
      u = e[7],
      l = e[8],
      f = l * s - o * u,
      h = o * c - l * a,
      d = u * a - s * c,
      g = t * f + r * h + i * d;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / g;
    return (
      (e[0] = f * x),
      (e[1] = (i * u - l * r) * x),
      (e[2] = (o * r - i * s) * x),
      (e[3] = h * x),
      (e[4] = (l * t - i * c) * x),
      (e[5] = (i * a - o * t) * x),
      (e[6] = d * x),
      (e[7] = (r * c - u * t) * x),
      (e[8] = (s * t - r * a) * x),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, a, s, o) {
    const c = Math.cos(a),
      u = Math.sin(a);
    return (
      this.set(
        r * c,
        r * u,
        -r * (c * s + u * o) + s + e,
        -i * u,
        i * c,
        -i * (-u * s + c * o) + o + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(wu.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(wu.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(wu.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const wu = new Je();
function Lp(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
function rs(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function ty() {
  const n = rs("canvas");
  return (n.style.display = "block"), n;
}
const ff = {};
function ja(n) {
  n in ff || ((ff[n] = !0), console.warn(n));
}
function ta(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Eu(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const ny = new Je().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  ry = new Je().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function iy(n) {
  return n.convertSRGBToLinear().applyMatrix3(ry);
}
function ay(n) {
  return n.applyMatrix3(ny).convertLinearToSRGB();
}
const sy = { [Gn]: (n) => n, [gt]: (n) => n.convertSRGBToLinear(), [Go]: iy },
  oy = { [Gn]: (n) => n, [gt]: (n) => n.convertLinearToSRGB(), [Go]: ay },
  Dn = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(n) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !n);
    },
    get workingColorSpace() {
      return Gn;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const r = sy[e],
        i = oy[t];
      if (r === void 0 || i === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return i(r(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  };
let wi;
class Ip {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      wi === void 0 && (wi = rs("canvas")),
        (wi.width = e.width),
        (wi.height = e.height);
      const r = wi.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (t = wi);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = rs("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        a = i.data;
      for (let s = 0; s < a.length; s++) a[s] = ta(a[s] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(ta(t[r] / 255) * 255))
          : (t[r] = ta(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let uy = 0;
class Op {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: uy++ }),
      (this.uuid = li()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let a;
      if (Array.isArray(i)) {
        a = [];
        for (let s = 0, o = i.length; s < o; s++)
          i[s].isDataTexture ? a.push(Su(i[s].image)) : a.push(Su(i[s]));
      } else a = Su(i);
      r.url = a;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function Su(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? Ip.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let cy = 0;
class sn extends ci {
  constructor(
    e = sn.DEFAULT_IMAGE,
    t = sn.DEFAULT_MAPPING,
    r = Pn,
    i = Pn,
    a = wn,
    s = es,
    o = Ln,
    c = Nr,
    u = sn.DEFAULT_ANISOTROPY,
    l = ni
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: cy++ }),
      (this.uuid = li()),
      (this.name = ""),
      (this.source = new Op(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = a),
      (this.minFilter = s),
      (this.anisotropy = u),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = c),
      (this.offset = new De(0, 0)),
      (this.repeat = new De(1, 1)),
      (this.center = new De(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Je()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof l == "string"
        ? (this.colorSpace = l)
        : (ja(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = l === ti ? gt : ni)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Ap) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case lc:
          e.x = e.x - Math.floor(e.x);
          break;
        case Pn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case fc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case lc:
          e.y = e.y - Math.floor(e.y);
          break;
        case Pn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case fc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      ja("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === gt ? ti : Pp
    );
  }
  set encoding(e) {
    ja("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === ti ? gt : ni);
  }
}
sn.DEFAULT_IMAGE = null;
sn.DEFAULT_MAPPING = Ap;
sn.DEFAULT_ANISOTROPY = 1;
class xt {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (xt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      a = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i + s[12] * a),
      (this.y = s[1] * t + s[5] * r + s[9] * i + s[13] * a),
      (this.z = s[2] * t + s[6] * r + s[10] * i + s[14] * a),
      (this.w = s[3] * t + s[7] * r + s[11] * i + s[15] * a),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, a;
    const c = e.elements,
      u = c[0],
      l = c[4],
      f = c[8],
      h = c[1],
      d = c[5],
      g = c[9],
      x = c[2],
      m = c[6],
      p = c[10];
    if (
      Math.abs(l - h) < 0.01 &&
      Math.abs(f - x) < 0.01 &&
      Math.abs(g - m) < 0.01
    ) {
      if (
        Math.abs(l + h) < 0.1 &&
        Math.abs(f + x) < 0.1 &&
        Math.abs(g + m) < 0.1 &&
        Math.abs(u + d + p - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const v = (u + 1) / 2,
        y = (d + 1) / 2,
        E = (p + 1) / 2,
        M = (l + h) / 4,
        T = (f + x) / 4,
        N = (g + m) / 4;
      return (
        v > y && v > E
          ? v < 0.01
            ? ((r = 0), (i = 0.707106781), (a = 0.707106781))
            : ((r = Math.sqrt(v)), (i = M / r), (a = T / r))
          : y > E
          ? y < 0.01
            ? ((r = 0.707106781), (i = 0), (a = 0.707106781))
            : ((i = Math.sqrt(y)), (r = M / i), (a = N / i))
          : E < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (a = 0))
          : ((a = Math.sqrt(E)), (r = T / a), (i = N / a)),
        this.set(r, i, a, t),
        this
      );
    }
    let S = Math.sqrt(
      (m - g) * (m - g) + (f - x) * (f - x) + (h - l) * (h - l)
    );
    return (
      Math.abs(S) < 0.001 && (S = 1),
      (this.x = (m - g) / S),
      (this.y = (f - x) / S),
      (this.z = (h - l) / S),
      (this.w = Math.acos((u + d + p - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class ly extends ci {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new xt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new xt(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    r.encoding !== void 0 &&
      (ja(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (r.colorSpace = r.encoding === ti ? gt : ni)),
      (this.texture = new sn(
        i,
        r.mapping,
        r.wrapS,
        r.wrapT,
        r.magFilter,
        r.minFilter,
        r.format,
        r.type,
        r.anisotropy,
        r.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        r.generateMipmaps !== void 0 ? r.generateMipmaps : !1),
      (this.texture.internalFormat =
        r.internalFormat !== void 0 ? r.internalFormat : null),
      (this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : wn),
      (this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0),
      (this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1),
      (this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null),
      (this.samples = r.samples !== void 0 ? r.samples : 0);
  }
  setSize(e, t, r = 1) {
    (this.width !== e || this.height !== t || this.depth !== r) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = r),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = r),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Op(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ri extends ly {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class Up extends sn {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = Qt),
      (this.minFilter = Qt),
      (this.wrapR = Pn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class fy extends sn {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = Qt),
      (this.minFilter = Qt),
      (this.wrapR = Pn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Ht {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, a, s, o) {
    let c = r[i + 0],
      u = r[i + 1],
      l = r[i + 2],
      f = r[i + 3];
    const h = a[s + 0],
      d = a[s + 1],
      g = a[s + 2],
      x = a[s + 3];
    if (o === 0) {
      (e[t + 0] = c), (e[t + 1] = u), (e[t + 2] = l), (e[t + 3] = f);
      return;
    }
    if (o === 1) {
      (e[t + 0] = h), (e[t + 1] = d), (e[t + 2] = g), (e[t + 3] = x);
      return;
    }
    if (f !== x || c !== h || u !== d || l !== g) {
      let m = 1 - o;
      const p = c * h + u * d + l * g + f * x,
        S = p >= 0 ? 1 : -1,
        v = 1 - p * p;
      if (v > Number.EPSILON) {
        const E = Math.sqrt(v),
          M = Math.atan2(E, p * S);
        (m = Math.sin(m * M) / E), (o = Math.sin(o * M) / E);
      }
      const y = o * S;
      if (
        ((c = c * m + h * y),
        (u = u * m + d * y),
        (l = l * m + g * y),
        (f = f * m + x * y),
        m === 1 - o)
      ) {
        const E = 1 / Math.sqrt(c * c + u * u + l * l + f * f);
        (c *= E), (u *= E), (l *= E), (f *= E);
      }
    }
    (e[t] = c), (e[t + 1] = u), (e[t + 2] = l), (e[t + 3] = f);
  }
  static multiplyQuaternionsFlat(e, t, r, i, a, s) {
    const o = r[i],
      c = r[i + 1],
      u = r[i + 2],
      l = r[i + 3],
      f = a[s],
      h = a[s + 1],
      d = a[s + 2],
      g = a[s + 3];
    return (
      (e[t] = o * g + l * f + c * d - u * h),
      (e[t + 1] = c * g + l * h + u * f - o * d),
      (e[t + 2] = u * g + l * d + o * h - c * f),
      (e[t + 3] = l * g - o * f - c * h - u * d),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const r = e._x,
      i = e._y,
      a = e._z,
      s = e._order,
      o = Math.cos,
      c = Math.sin,
      u = o(r / 2),
      l = o(i / 2),
      f = o(a / 2),
      h = c(r / 2),
      d = c(i / 2),
      g = c(a / 2);
    switch (s) {
      case "XYZ":
        (this._x = h * l * f + u * d * g),
          (this._y = u * d * f - h * l * g),
          (this._z = u * l * g + h * d * f),
          (this._w = u * l * f - h * d * g);
        break;
      case "YXZ":
        (this._x = h * l * f + u * d * g),
          (this._y = u * d * f - h * l * g),
          (this._z = u * l * g - h * d * f),
          (this._w = u * l * f + h * d * g);
        break;
      case "ZXY":
        (this._x = h * l * f - u * d * g),
          (this._y = u * d * f + h * l * g),
          (this._z = u * l * g + h * d * f),
          (this._w = u * l * f - h * d * g);
        break;
      case "ZYX":
        (this._x = h * l * f - u * d * g),
          (this._y = u * d * f + h * l * g),
          (this._z = u * l * g - h * d * f),
          (this._w = u * l * f + h * d * g);
        break;
      case "YZX":
        (this._x = h * l * f + u * d * g),
          (this._y = u * d * f + h * l * g),
          (this._z = u * l * g - h * d * f),
          (this._w = u * l * f - h * d * g);
        break;
      case "XZY":
        (this._x = h * l * f - u * d * g),
          (this._y = u * d * f - h * l * g),
          (this._z = u * l * g + h * d * f),
          (this._w = u * l * f + h * d * g);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      a = t[8],
      s = t[1],
      o = t[5],
      c = t[9],
      u = t[2],
      l = t[6],
      f = t[10],
      h = r + o + f;
    if (h > 0) {
      const d = 0.5 / Math.sqrt(h + 1);
      (this._w = 0.25 / d),
        (this._x = (l - c) * d),
        (this._y = (a - u) * d),
        (this._z = (s - i) * d);
    } else if (r > o && r > f) {
      const d = 2 * Math.sqrt(1 + r - o - f);
      (this._w = (l - c) / d),
        (this._x = 0.25 * d),
        (this._y = (i + s) / d),
        (this._z = (a + u) / d);
    } else if (o > f) {
      const d = 2 * Math.sqrt(1 + o - r - f);
      (this._w = (a - u) / d),
        (this._x = (i + s) / d),
        (this._y = 0.25 * d),
        (this._z = (c + l) / d);
    } else {
      const d = 2 * Math.sqrt(1 + f - r - o);
      (this._w = (s - i) / d),
        (this._x = (a + u) / d),
        (this._y = (c + l) / d),
        (this._z = 0.25 * d);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ut(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      a = e._z,
      s = e._w,
      o = t._x,
      c = t._y,
      u = t._z,
      l = t._w;
    return (
      (this._x = r * l + s * o + i * u - a * c),
      (this._y = i * l + s * c + a * o - r * u),
      (this._z = a * l + s * u + r * c - i * o),
      (this._w = s * l - r * o - i * c - a * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      a = this._z,
      s = this._w;
    let o = s * e._w + r * e._x + i * e._y + a * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = s), (this._x = r), (this._y = i), (this._z = a), this;
    const c = 1 - o * o;
    if (c <= Number.EPSILON) {
      const d = 1 - t;
      return (
        (this._w = d * s + t * this._w),
        (this._x = d * r + t * this._x),
        (this._y = d * i + t * this._y),
        (this._z = d * a + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const u = Math.sqrt(c),
      l = Math.atan2(u, o),
      f = Math.sin((1 - t) * l) / u,
      h = Math.sin(t * l) / u;
    return (
      (this._w = s * f + this._w * h),
      (this._x = r * f + this._x * h),
      (this._y = i * f + this._y * h),
      (this._z = a * f + this._z * h),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      r = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      a = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      r * Math.sin(a),
      r * Math.cos(a),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class B {
  constructor(e = 0, t = 0, r = 0) {
    (B.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(hf.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(hf.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[3] * r + a[6] * i),
      (this.y = a[1] * t + a[4] * r + a[7] * i),
      (this.z = a[2] * t + a[5] * r + a[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      a = e.elements,
      s = 1 / (a[3] * t + a[7] * r + a[11] * i + a[15]);
    return (
      (this.x = (a[0] * t + a[4] * r + a[8] * i + a[12]) * s),
      (this.y = (a[1] * t + a[5] * r + a[9] * i + a[13]) * s),
      (this.z = (a[2] * t + a[6] * r + a[10] * i + a[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      a = e.x,
      s = e.y,
      o = e.z,
      c = e.w,
      u = c * t + s * i - o * r,
      l = c * r + o * t - a * i,
      f = c * i + a * r - s * t,
      h = -a * t - s * r - o * i;
    return (
      (this.x = u * c + h * -a + l * -o - f * -s),
      (this.y = l * c + h * -s + f * -a - u * -o),
      (this.z = f * c + h * -o + u * -s - l * -a),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * r + a[8] * i),
      (this.y = a[1] * t + a[5] * r + a[9] * i),
      (this.z = a[2] * t + a[6] * r + a[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      a = e.z,
      s = t.x,
      o = t.y,
      c = t.z;
    return (
      (this.x = i * c - a * o),
      (this.y = a * s - r * c),
      (this.z = r * o - i * s),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return Mu.copy(this).projectOnVector(e), this.sub(Mu);
  }
  reflect(e) {
    return this.sub(Mu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Ut(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      r = Math.sqrt(1 - e ** 2);
    return (
      (this.x = r * Math.cos(t)), (this.y = r * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Mu = new B(),
  hf = new Ht();
class Ir {
  constructor(
    e = new B(1 / 0, 1 / 0, 1 / 0),
    t = new B(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Jn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Jn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Jn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        Ei.copy(e.boundingBox),
        Ei.applyMatrix4(e.matrixWorld),
        this.union(Ei);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const a = i.attributes.position;
          for (let s = 0, o = a.count; s < o; s++)
            Jn.fromBufferAttribute(a, s).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Jn);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            Ei.copy(i.boundingBox),
            Ei.applyMatrix4(e.matrixWorld),
            this.union(Ei);
    }
    const r = e.children;
    for (let i = 0, a = r.length; i < a; i++) this.expandByObject(r[i], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Jn),
      Jn.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Aa),
      Ms.subVectors(this.max, Aa),
      Si.subVectors(e.a, Aa),
      Mi.subVectors(e.b, Aa),
      Ai.subVectors(e.c, Aa),
      mr.subVectors(Mi, Si),
      gr.subVectors(Ai, Mi),
      Hr.subVectors(Si, Ai);
    let t = [
      0,
      -mr.z,
      mr.y,
      0,
      -gr.z,
      gr.y,
      0,
      -Hr.z,
      Hr.y,
      mr.z,
      0,
      -mr.x,
      gr.z,
      0,
      -gr.x,
      Hr.z,
      0,
      -Hr.x,
      -mr.y,
      mr.x,
      0,
      -gr.y,
      gr.x,
      0,
      -Hr.y,
      Hr.x,
      0,
    ];
    return !Au(t, Si, Mi, Ai, Ms) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Au(t, Si, Mi, Ai, Ms))
      ? !1
      : (As.crossVectors(mr, gr),
        (t = [As.x, As.y, As.z]),
        Au(t, Si, Mi, Ai, Ms));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Jn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Jn).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Zn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Zn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Zn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Zn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Zn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Zn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Zn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Zn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Zn),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Zn = [
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
  ],
  Jn = new B(),
  Ei = new Ir(),
  Si = new B(),
  Mi = new B(),
  Ai = new B(),
  mr = new B(),
  gr = new B(),
  Hr = new B(),
  Aa = new B(),
  Ms = new B(),
  As = new B(),
  Gr = new B();
function Au(n, e, t, r, i) {
  for (let a = 0, s = n.length - 3; a <= s; a += 3) {
    Gr.fromArray(n, a);
    const o =
        i.x * Math.abs(Gr.x) + i.y * Math.abs(Gr.y) + i.z * Math.abs(Gr.z),
      c = e.dot(Gr),
      u = t.dot(Gr),
      l = r.dot(Gr);
    if (Math.max(-Math.max(c, u, l), Math.min(c, u, l)) > o) return !1;
  }
  return !0;
}
const hy = new Ir(),
  Da = new B(),
  Du = new B();
class ma {
  constructor(e = new B(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : hy.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let a = 0, s = e.length; a < s; a++)
      i = Math.max(i, r.distanceToSquared(e[a]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Da.subVectors(e, this.center);
    const t = Da.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(Da, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Du.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Da.copy(e.center).add(Du)),
            this.expandByPoint(Da.copy(e.center).sub(Du))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Kn = new B(),
  Tu = new B(),
  Ds = new B(),
  vr = new B(),
  Cu = new B(),
  Ts = new B(),
  Nu = new B();
class Vo {
  constructor(e = new B(), t = new B(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Kn)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Kn.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Kn.copy(this.origin).addScaledVector(this.direction, t),
        Kn.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    Tu.copy(e).add(t).multiplyScalar(0.5),
      Ds.copy(t).sub(e).normalize(),
      vr.copy(this.origin).sub(Tu);
    const a = e.distanceTo(t) * 0.5,
      s = -this.direction.dot(Ds),
      o = vr.dot(this.direction),
      c = -vr.dot(Ds),
      u = vr.lengthSq(),
      l = Math.abs(1 - s * s);
    let f, h, d, g;
    if (l > 0)
      if (((f = s * c - o), (h = s * o - c), (g = a * l), f >= 0))
        if (h >= -g)
          if (h <= g) {
            const x = 1 / l;
            (f *= x),
              (h *= x),
              (d = f * (f + s * h + 2 * o) + h * (s * f + h + 2 * c) + u);
          } else
            (h = a),
              (f = Math.max(0, -(s * h + o))),
              (d = -f * f + h * (h + 2 * c) + u);
        else
          (h = -a),
            (f = Math.max(0, -(s * h + o))),
            (d = -f * f + h * (h + 2 * c) + u);
      else
        h <= -g
          ? ((f = Math.max(0, -(-s * a + o))),
            (h = f > 0 ? -a : Math.min(Math.max(-a, -c), a)),
            (d = -f * f + h * (h + 2 * c) + u))
          : h <= g
          ? ((f = 0),
            (h = Math.min(Math.max(-a, -c), a)),
            (d = h * (h + 2 * c) + u))
          : ((f = Math.max(0, -(s * a + o))),
            (h = f > 0 ? a : Math.min(Math.max(-a, -c), a)),
            (d = -f * f + h * (h + 2 * c) + u));
    else
      (h = s > 0 ? -a : a),
        (f = Math.max(0, -(s * h + o))),
        (d = -f * f + h * (h + 2 * c) + u);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, f),
      i && i.copy(Tu).addScaledVector(Ds, h),
      d
    );
  }
  intersectSphere(e, t) {
    Kn.subVectors(e.center, this.origin);
    const r = Kn.dot(this.direction),
      i = Kn.dot(Kn) - r * r,
      a = e.radius * e.radius;
    if (i > a) return null;
    const s = Math.sqrt(a - i),
      o = r - s,
      c = r + s;
    return c < 0 ? null : o < 0 ? this.at(c, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, a, s, o, c;
    const u = 1 / this.direction.x,
      l = 1 / this.direction.y,
      f = 1 / this.direction.z,
      h = this.origin;
    return (
      u >= 0
        ? ((r = (e.min.x - h.x) * u), (i = (e.max.x - h.x) * u))
        : ((r = (e.max.x - h.x) * u), (i = (e.min.x - h.x) * u)),
      l >= 0
        ? ((a = (e.min.y - h.y) * l), (s = (e.max.y - h.y) * l))
        : ((a = (e.max.y - h.y) * l), (s = (e.min.y - h.y) * l)),
      r > s ||
      a > i ||
      ((a > r || isNaN(r)) && (r = a),
      (s < i || isNaN(i)) && (i = s),
      f >= 0
        ? ((o = (e.min.z - h.z) * f), (c = (e.max.z - h.z) * f))
        : ((o = (e.max.z - h.z) * f), (c = (e.min.z - h.z) * f)),
      r > c || o > i) ||
      ((o > r || r !== r) && (r = o), (c < i || i !== i) && (i = c), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Kn) !== null;
  }
  intersectTriangle(e, t, r, i, a) {
    Cu.subVectors(t, e), Ts.subVectors(r, e), Nu.crossVectors(Cu, Ts);
    let s = this.direction.dot(Nu),
      o;
    if (s > 0) {
      if (i) return null;
      o = 1;
    } else if (s < 0) (o = -1), (s = -s);
    else return null;
    vr.subVectors(this.origin, e);
    const c = o * this.direction.dot(Ts.crossVectors(vr, Ts));
    if (c < 0) return null;
    const u = o * this.direction.dot(Cu.cross(vr));
    if (u < 0 || c + u > s) return null;
    const l = -o * vr.dot(Nu);
    return l < 0 ? null : this.at(l / s, a);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ut {
  constructor(e, t, r, i, a, s, o, c, u, l, f, h, d, g, x, m) {
    (ut.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, a, s, o, c, u, l, f, h, d, g, x, m);
  }
  set(e, t, r, i, a, s, o, c, u, l, f, h, d, g, x, m) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[4] = t),
      (p[8] = r),
      (p[12] = i),
      (p[1] = a),
      (p[5] = s),
      (p[9] = o),
      (p[13] = c),
      (p[2] = u),
      (p[6] = l),
      (p[10] = f),
      (p[14] = h),
      (p[3] = d),
      (p[7] = g),
      (p[11] = x),
      (p[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new ut().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / Di.setFromMatrixColumn(e, 0).length(),
      a = 1 / Di.setFromMatrixColumn(e, 1).length(),
      s = 1 / Di.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * a),
      (t[5] = r[5] * a),
      (t[6] = r[6] * a),
      (t[7] = 0),
      (t[8] = r[8] * s),
      (t[9] = r[9] * s),
      (t[10] = r[10] * s),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      a = e.z,
      s = Math.cos(r),
      o = Math.sin(r),
      c = Math.cos(i),
      u = Math.sin(i),
      l = Math.cos(a),
      f = Math.sin(a);
    if (e.order === "XYZ") {
      const h = s * l,
        d = s * f,
        g = o * l,
        x = o * f;
      (t[0] = c * l),
        (t[4] = -c * f),
        (t[8] = u),
        (t[1] = d + g * u),
        (t[5] = h - x * u),
        (t[9] = -o * c),
        (t[2] = x - h * u),
        (t[6] = g + d * u),
        (t[10] = s * c);
    } else if (e.order === "YXZ") {
      const h = c * l,
        d = c * f,
        g = u * l,
        x = u * f;
      (t[0] = h + x * o),
        (t[4] = g * o - d),
        (t[8] = s * u),
        (t[1] = s * f),
        (t[5] = s * l),
        (t[9] = -o),
        (t[2] = d * o - g),
        (t[6] = x + h * o),
        (t[10] = s * c);
    } else if (e.order === "ZXY") {
      const h = c * l,
        d = c * f,
        g = u * l,
        x = u * f;
      (t[0] = h - x * o),
        (t[4] = -s * f),
        (t[8] = g + d * o),
        (t[1] = d + g * o),
        (t[5] = s * l),
        (t[9] = x - h * o),
        (t[2] = -s * u),
        (t[6] = o),
        (t[10] = s * c);
    } else if (e.order === "ZYX") {
      const h = s * l,
        d = s * f,
        g = o * l,
        x = o * f;
      (t[0] = c * l),
        (t[4] = g * u - d),
        (t[8] = h * u + x),
        (t[1] = c * f),
        (t[5] = x * u + h),
        (t[9] = d * u - g),
        (t[2] = -u),
        (t[6] = o * c),
        (t[10] = s * c);
    } else if (e.order === "YZX") {
      const h = s * c,
        d = s * u,
        g = o * c,
        x = o * u;
      (t[0] = c * l),
        (t[4] = x - h * f),
        (t[8] = g * f + d),
        (t[1] = f),
        (t[5] = s * l),
        (t[9] = -o * l),
        (t[2] = -u * l),
        (t[6] = d * f + g),
        (t[10] = h - x * f);
    } else if (e.order === "XZY") {
      const h = s * c,
        d = s * u,
        g = o * c,
        x = o * u;
      (t[0] = c * l),
        (t[4] = -f),
        (t[8] = u * l),
        (t[1] = h * f + x),
        (t[5] = s * l),
        (t[9] = d * f - g),
        (t[2] = g * f - d),
        (t[6] = o * l),
        (t[10] = x * f + h);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(dy, e, py);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      hn.subVectors(e, t),
      hn.lengthSq() === 0 && (hn.z = 1),
      hn.normalize(),
      yr.crossVectors(r, hn),
      yr.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (hn.x += 1e-4) : (hn.z += 1e-4),
        hn.normalize(),
        yr.crossVectors(r, hn)),
      yr.normalize(),
      Cs.crossVectors(hn, yr),
      (i[0] = yr.x),
      (i[4] = Cs.x),
      (i[8] = hn.x),
      (i[1] = yr.y),
      (i[5] = Cs.y),
      (i[9] = hn.y),
      (i[2] = yr.z),
      (i[6] = Cs.z),
      (i[10] = hn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      a = this.elements,
      s = r[0],
      o = r[4],
      c = r[8],
      u = r[12],
      l = r[1],
      f = r[5],
      h = r[9],
      d = r[13],
      g = r[2],
      x = r[6],
      m = r[10],
      p = r[14],
      S = r[3],
      v = r[7],
      y = r[11],
      E = r[15],
      M = i[0],
      T = i[4],
      N = i[8],
      A = i[12],
      D = i[1],
      z = i[5],
      $ = i[9],
      I = i[13],
      G = i[2],
      L = i[6],
      C = i[10],
      k = i[14],
      Z = i[3],
      ie = i[7],
      ne = i[11],
      Y = i[15];
    return (
      (a[0] = s * M + o * D + c * G + u * Z),
      (a[4] = s * T + o * z + c * L + u * ie),
      (a[8] = s * N + o * $ + c * C + u * ne),
      (a[12] = s * A + o * I + c * k + u * Y),
      (a[1] = l * M + f * D + h * G + d * Z),
      (a[5] = l * T + f * z + h * L + d * ie),
      (a[9] = l * N + f * $ + h * C + d * ne),
      (a[13] = l * A + f * I + h * k + d * Y),
      (a[2] = g * M + x * D + m * G + p * Z),
      (a[6] = g * T + x * z + m * L + p * ie),
      (a[10] = g * N + x * $ + m * C + p * ne),
      (a[14] = g * A + x * I + m * k + p * Y),
      (a[3] = S * M + v * D + y * G + E * Z),
      (a[7] = S * T + v * z + y * L + E * ie),
      (a[11] = S * N + v * $ + y * C + E * ne),
      (a[15] = S * A + v * I + y * k + E * Y),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      a = e[12],
      s = e[1],
      o = e[5],
      c = e[9],
      u = e[13],
      l = e[2],
      f = e[6],
      h = e[10],
      d = e[14],
      g = e[3],
      x = e[7],
      m = e[11],
      p = e[15];
    return (
      g *
        (+a * c * f -
          i * u * f -
          a * o * h +
          r * u * h +
          i * o * d -
          r * c * d) +
      x *
        (+t * c * d -
          t * u * h +
          a * s * h -
          i * s * d +
          i * u * l -
          a * c * l) +
      m *
        (+t * u * f -
          t * o * d -
          a * s * f +
          r * s * d +
          a * o * l -
          r * u * l) +
      p *
        (-i * o * l - t * c * f + t * o * h + i * s * f - r * s * h + r * c * l)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      a = e[3],
      s = e[4],
      o = e[5],
      c = e[6],
      u = e[7],
      l = e[8],
      f = e[9],
      h = e[10],
      d = e[11],
      g = e[12],
      x = e[13],
      m = e[14],
      p = e[15],
      S = f * m * u - x * h * u + x * c * d - o * m * d - f * c * p + o * h * p,
      v = g * h * u - l * m * u - g * c * d + s * m * d + l * c * p - s * h * p,
      y = l * x * u - g * f * u + g * o * d - s * x * d - l * o * p + s * f * p,
      E = g * f * c - l * x * c - g * o * h + s * x * h + l * o * m - s * f * m,
      M = t * S + r * v + i * y + a * E;
    if (M === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / M;
    return (
      (e[0] = S * T),
      (e[1] =
        (x * h * a -
          f * m * a -
          x * i * d +
          r * m * d +
          f * i * p -
          r * h * p) *
        T),
      (e[2] =
        (o * m * a -
          x * c * a +
          x * i * u -
          r * m * u -
          o * i * p +
          r * c * p) *
        T),
      (e[3] =
        (f * c * a -
          o * h * a -
          f * i * u +
          r * h * u +
          o * i * d -
          r * c * d) *
        T),
      (e[4] = v * T),
      (e[5] =
        (l * m * a -
          g * h * a +
          g * i * d -
          t * m * d -
          l * i * p +
          t * h * p) *
        T),
      (e[6] =
        (g * c * a -
          s * m * a -
          g * i * u +
          t * m * u +
          s * i * p -
          t * c * p) *
        T),
      (e[7] =
        (s * h * a -
          l * c * a +
          l * i * u -
          t * h * u -
          s * i * d +
          t * c * d) *
        T),
      (e[8] = y * T),
      (e[9] =
        (g * f * a -
          l * x * a -
          g * r * d +
          t * x * d +
          l * r * p -
          t * f * p) *
        T),
      (e[10] =
        (s * x * a -
          g * o * a +
          g * r * u -
          t * x * u -
          s * r * p +
          t * o * p) *
        T),
      (e[11] =
        (l * o * a -
          s * f * a -
          l * r * u +
          t * f * u +
          s * r * d -
          t * o * d) *
        T),
      (e[12] = E * T),
      (e[13] =
        (l * x * i -
          g * f * i +
          g * r * h -
          t * x * h -
          l * r * m +
          t * f * m) *
        T),
      (e[14] =
        (g * o * i -
          s * x * i -
          g * r * c +
          t * x * c +
          s * r * m -
          t * o * m) *
        T),
      (e[15] =
        (s * f * i -
          l * o * i +
          l * r * c -
          t * f * c -
          s * r * h +
          t * o * h) *
        T),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      a = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= a),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= a),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= a),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= a),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      a = 1 - r,
      s = e.x,
      o = e.y,
      c = e.z,
      u = a * s,
      l = a * o;
    return (
      this.set(
        u * s + r,
        u * o - i * c,
        u * c + i * o,
        0,
        u * o + i * c,
        l * o + r,
        l * c - i * s,
        0,
        u * c - i * o,
        l * c + i * s,
        a * c * c + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, a, s) {
    return this.set(1, r, a, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      a = t._x,
      s = t._y,
      o = t._z,
      c = t._w,
      u = a + a,
      l = s + s,
      f = o + o,
      h = a * u,
      d = a * l,
      g = a * f,
      x = s * l,
      m = s * f,
      p = o * f,
      S = c * u,
      v = c * l,
      y = c * f,
      E = r.x,
      M = r.y,
      T = r.z;
    return (
      (i[0] = (1 - (x + p)) * E),
      (i[1] = (d + y) * E),
      (i[2] = (g - v) * E),
      (i[3] = 0),
      (i[4] = (d - y) * M),
      (i[5] = (1 - (h + p)) * M),
      (i[6] = (m + S) * M),
      (i[7] = 0),
      (i[8] = (g + v) * T),
      (i[9] = (m - S) * T),
      (i[10] = (1 - (h + x)) * T),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let a = Di.set(i[0], i[1], i[2]).length();
    const s = Di.set(i[4], i[5], i[6]).length(),
      o = Di.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (a = -a),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      Tn.copy(this);
    const u = 1 / a,
      l = 1 / s,
      f = 1 / o;
    return (
      (Tn.elements[0] *= u),
      (Tn.elements[1] *= u),
      (Tn.elements[2] *= u),
      (Tn.elements[4] *= l),
      (Tn.elements[5] *= l),
      (Tn.elements[6] *= l),
      (Tn.elements[8] *= f),
      (Tn.elements[9] *= f),
      (Tn.elements[10] *= f),
      t.setFromRotationMatrix(Tn),
      (r.x = a),
      (r.y = s),
      (r.z = o),
      this
    );
  }
  makePerspective(e, t, r, i, a, s, o = sr) {
    const c = this.elements,
      u = (2 * a) / (t - e),
      l = (2 * a) / (r - i),
      f = (t + e) / (t - e),
      h = (r + i) / (r - i);
    let d, g;
    if (o === sr) (d = -(s + a) / (s - a)), (g = (-2 * s * a) / (s - a));
    else if (o === Ao) (d = -s / (s - a)), (g = (-s * a) / (s - a));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o
      );
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = f),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = l),
      (c[9] = h),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = d),
      (c[14] = g),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, a, s, o = sr) {
    const c = this.elements,
      u = 1 / (t - e),
      l = 1 / (r - i),
      f = 1 / (s - a),
      h = (t + e) * u,
      d = (r + i) * l;
    let g, x;
    if (o === sr) (g = (s + a) * f), (x = -2 * f);
    else if (o === Ao) (g = a * f), (x = -1 * f);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o
      );
    return (
      (c[0] = 2 * u),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = -h),
      (c[1] = 0),
      (c[5] = 2 * l),
      (c[9] = 0),
      (c[13] = -d),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = x),
      (c[14] = -g),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const Di = new B(),
  Tn = new ut(),
  dy = new B(0, 0, 0),
  py = new B(1, 1, 1),
  yr = new B(),
  Cs = new B(),
  hn = new B(),
  df = new ut(),
  pf = new Ht();
class ms {
  constructor(e = 0, t = 0, r = 0, i = ms.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      a = i[0],
      s = i[4],
      o = i[8],
      c = i[1],
      u = i[5],
      l = i[9],
      f = i[2],
      h = i[6],
      d = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Ut(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-l, d)), (this._z = Math.atan2(-s, a)))
            : ((this._x = Math.atan2(h, u)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Ut(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(c, u)))
            : ((this._y = Math.atan2(-f, a)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Ut(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(-f, d)), (this._z = Math.atan2(-s, u)))
            : ((this._y = 0), (this._z = Math.atan2(c, a)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Ut(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(c, a)))
            : ((this._x = 0), (this._z = Math.atan2(-s, u)));
        break;
      case "YZX":
        (this._z = Math.asin(Ut(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-l, u)), (this._y = Math.atan2(-f, a)))
            : ((this._x = 0), (this._y = Math.atan2(o, d)));
        break;
      case "XZY":
        (this._z = Math.asin(-Ut(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(h, u)), (this._y = Math.atan2(o, a)))
            : ((this._x = Math.atan2(-l, d)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      df.makeRotationFromQuaternion(e), this.setFromRotationMatrix(df, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return pf.setFromEuler(this), this.setFromQuaternion(pf, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ms.DEFAULT_ORDER = "XYZ";
class kc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let my = 0;
const mf = new B(),
  Ti = new Ht(),
  Qn = new ut(),
  Ns = new B(),
  Ta = new B(),
  gy = new B(),
  vy = new Ht(),
  gf = new B(1, 0, 0),
  vf = new B(0, 1, 0),
  yf = new B(0, 0, 1),
  yy = { type: "added" },
  xy = { type: "removed" };
class st extends ci {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: my++ }),
      (this.uuid = li()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = st.DEFAULT_UP.clone());
    const e = new B(),
      t = new ms(),
      r = new Ht(),
      i = new B(1, 1, 1);
    function a() {
      r.setFromEuler(t, !1);
    }
    function s() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(a),
      r._onChange(s),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new ut() },
        normalMatrix: { value: new Je() },
      }),
      (this.matrix = new ut()),
      (this.matrixWorld = new ut()),
      (this.matrixAutoUpdate = st.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = st.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new kc()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ti.setFromAxisAngle(e, t), this.quaternion.multiply(Ti), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ti.setFromAxisAngle(e, t), this.quaternion.premultiply(Ti), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(gf, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(vf, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(yf, e);
  }
  translateOnAxis(e, t) {
    return (
      mf.copy(e).applyQuaternion(this.quaternion),
      this.position.add(mf.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(gf, e);
  }
  translateY(e) {
    return this.translateOnAxis(vf, e);
  }
  translateZ(e) {
    return this.translateOnAxis(yf, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Qn.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? Ns.copy(e) : Ns.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Ta.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Qn.lookAt(Ta, Ns, this.up)
        : Qn.lookAt(Ns, Ta, this.up),
      this.quaternion.setFromRotationMatrix(Qn),
      i &&
        (Qn.extractRotation(i.matrixWorld),
        Ti.setFromRotationMatrix(Qn),
        this.quaternion.premultiply(Ti.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(yy))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(xy)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Qn.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Qn.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Qn),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const s = this.children[r].getObjectByProperty(e, t);
      if (s !== void 0) return s;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let i = 0, a = this.children.length; i < a; i++) {
      const s = this.children[i].getObjectsByProperty(e, t);
      s.length > 0 && (r = r.concat(s));
    }
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ta, e, gy), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ta, vy, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) {
      const a = t[r];
      (a.matrixWorldAutoUpdate === !0 || e === !0) && a.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 &&
        r !== null &&
        r.matrixWorldAutoUpdate === !0 &&
        r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let a = 0, s = i.length; a < s; a++) {
        const o = i[a];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function a(o, c) {
      return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = a(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const c = o.shapes;
        if (Array.isArray(c))
          for (let u = 0, l = c.length; u < l; u++) {
            const f = c[u];
            a(e.shapes, f);
          }
        else a(e.shapes, c);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (a(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          o.push(a(e.materials, this.material[c]));
        i.material = o;
      } else i.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const c = this.animations[o];
        i.animations.push(a(e.animations, c));
      }
    }
    if (t) {
      const o = s(e.geometries),
        c = s(e.materials),
        u = s(e.textures),
        l = s(e.images),
        f = s(e.shapes),
        h = s(e.skeletons),
        d = s(e.animations),
        g = s(e.nodes);
      o.length > 0 && (r.geometries = o),
        c.length > 0 && (r.materials = c),
        u.length > 0 && (r.textures = u),
        l.length > 0 && (r.images = l),
        f.length > 0 && (r.shapes = f),
        h.length > 0 && (r.skeletons = h),
        d.length > 0 && (r.animations = d),
        g.length > 0 && (r.nodes = g);
    }
    return (r.object = i), r;
    function s(o) {
      const c = [];
      for (const u in o) {
        const l = o[u];
        delete l.metadata, c.push(l);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
st.DEFAULT_UP = new B(0, 1, 0);
st.DEFAULT_MATRIX_AUTO_UPDATE = !0;
st.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Cn = new B(),
  er = new B(),
  Ru = new B(),
  tr = new B(),
  Ci = new B(),
  Ni = new B(),
  xf = new B(),
  Fu = new B(),
  Pu = new B(),
  Lu = new B();
let Rs = !1;
class Rn {
  constructor(e = new B(), t = new B(), r = new B()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), Cn.subVectors(e, t), i.cross(Cn);
    const a = i.lengthSq();
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, a) {
    Cn.subVectors(i, t), er.subVectors(r, t), Ru.subVectors(e, t);
    const s = Cn.dot(Cn),
      o = Cn.dot(er),
      c = Cn.dot(Ru),
      u = er.dot(er),
      l = er.dot(Ru),
      f = s * u - o * o;
    if (f === 0) return a.set(-2, -1, -1);
    const h = 1 / f,
      d = (u * c - o * l) * h,
      g = (s * l - o * c) * h;
    return a.set(1 - d - g, g, d);
  }
  static containsPoint(e, t, r, i) {
    return (
      this.getBarycoord(e, t, r, i, tr),
      tr.x >= 0 && tr.y >= 0 && tr.x + tr.y <= 1
    );
  }
  static getUV(e, t, r, i, a, s, o, c) {
    return (
      Rs === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Rs = !0)),
      this.getInterpolation(e, t, r, i, a, s, o, c)
    );
  }
  static getInterpolation(e, t, r, i, a, s, o, c) {
    return (
      this.getBarycoord(e, t, r, i, tr),
      c.setScalar(0),
      c.addScaledVector(a, tr.x),
      c.addScaledVector(s, tr.y),
      c.addScaledVector(o, tr.z),
      c
    );
  }
  static isFrontFacing(e, t, r, i) {
    return Cn.subVectors(r, t), er.subVectors(e, t), Cn.cross(er).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Cn.subVectors(this.c, this.b),
      er.subVectors(this.a, this.b),
      Cn.cross(er).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Rn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Rn.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, i, a) {
    return (
      Rs === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Rs = !0)),
      Rn.getInterpolation(e, this.a, this.b, this.c, t, r, i, a)
    );
  }
  getInterpolation(e, t, r, i, a) {
    return Rn.getInterpolation(e, this.a, this.b, this.c, t, r, i, a);
  }
  containsPoint(e) {
    return Rn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Rn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      a = this.c;
    let s, o;
    Ci.subVectors(i, r), Ni.subVectors(a, r), Fu.subVectors(e, r);
    const c = Ci.dot(Fu),
      u = Ni.dot(Fu);
    if (c <= 0 && u <= 0) return t.copy(r);
    Pu.subVectors(e, i);
    const l = Ci.dot(Pu),
      f = Ni.dot(Pu);
    if (l >= 0 && f <= l) return t.copy(i);
    const h = c * f - l * u;
    if (h <= 0 && c >= 0 && l <= 0)
      return (s = c / (c - l)), t.copy(r).addScaledVector(Ci, s);
    Lu.subVectors(e, a);
    const d = Ci.dot(Lu),
      g = Ni.dot(Lu);
    if (g >= 0 && d <= g) return t.copy(a);
    const x = d * u - c * g;
    if (x <= 0 && u >= 0 && g <= 0)
      return (o = u / (u - g)), t.copy(r).addScaledVector(Ni, o);
    const m = l * g - d * f;
    if (m <= 0 && f - l >= 0 && d - g >= 0)
      return (
        xf.subVectors(a, i),
        (o = (f - l) / (f - l + (d - g))),
        t.copy(i).addScaledVector(xf, o)
      );
    const p = 1 / (m + x + h);
    return (
      (s = x * p),
      (o = h * p),
      t.copy(r).addScaledVector(Ci, s).addScaledVector(Ni, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let by = 0;
class fi extends ci {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: by++ }),
      (this.uuid = li()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = ea),
      (this.side = lr),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Sp),
      (this.blendDst = Mp),
      (this.blendEquation = Wi),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = uc),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Fv),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = _u),
      (this.stencilZFail = _u),
      (this.stencilZPass = _u),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== ea && (r.blending = this.blending),
      this.side !== lr && (r.side = this.side),
      this.vertexColors && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = this.transparent),
      (r.depthFunc = this.depthFunc),
      (r.depthTest = this.depthTest),
      (r.depthWrite = this.depthWrite),
      (r.colorWrite = this.colorWrite),
      (r.stencilWrite = this.stencilWrite),
      (r.stencilWriteMask = this.stencilWriteMask),
      (r.stencilFunc = this.stencilFunc),
      (r.stencilRef = this.stencilRef),
      (r.stencilFuncMask = this.stencilFuncMask),
      (r.stencilFail = this.stencilFail),
      (r.stencilZFail = this.stencilZFail),
      (r.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = this.alphaHash),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (r.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (r.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = this.flatShading),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(a) {
      const s = [];
      for (const o in a) {
        const c = a[o];
        delete c.metadata, s.push(c);
      }
      return s;
    }
    if (t) {
      const a = i(e.textures),
        s = i(e.images);
      a.length > 0 && (r.textures = a), s.length > 0 && (r.images = s);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let a = 0; a !== i; ++a) r[a] = t[a].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const Bp = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Nn = { h: 0, s: 0, l: 0 },
  Fs = { h: 0, s: 0, l: 0 };
function Iu(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class tt {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = gt) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Dn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, i = Dn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      Dn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, r, i = Dn.workingColorSpace) {
    if (((e = zc(e, 1)), (t = Ut(t, 0, 1)), (r = Ut(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const a = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        s = 2 * r - a;
      (this.r = Iu(s, a, e + 1 / 3)),
        (this.g = Iu(s, a, e)),
        (this.b = Iu(s, a, e - 1 / 3));
    }
    return Dn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = gt) {
    function r(a) {
      a !== void 0 &&
        parseFloat(a) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let a;
      const s = i[1],
        o = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (a =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              r(a[4]),
              this.setRGB(
                Math.min(255, parseInt(a[1], 10)) / 255,
                Math.min(255, parseInt(a[2], 10)) / 255,
                Math.min(255, parseInt(a[3], 10)) / 255,
                t
              )
            );
          if (
            (a =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              r(a[4]),
              this.setRGB(
                Math.min(100, parseInt(a[1], 10)) / 100,
                Math.min(100, parseInt(a[2], 10)) / 100,
                Math.min(100, parseInt(a[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (a =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              r(a[4]),
              this.setHSL(
                parseFloat(a[1]) / 360,
                parseFloat(a[2]) / 100,
                parseFloat(a[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const a = i[1],
        s = a.length;
      if (s === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          t
        );
      if (s === 6) return this.setHex(parseInt(a, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = gt) {
    const r = Bp[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = ta(e.r)), (this.g = ta(e.g)), (this.b = ta(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Eu(e.r)), (this.g = Eu(e.g)), (this.b = Eu(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = gt) {
    return (
      Dn.fromWorkingColorSpace($t.copy(this), e),
      Math.round(Ut($t.r * 255, 0, 255)) * 65536 +
        Math.round(Ut($t.g * 255, 0, 255)) * 256 +
        Math.round(Ut($t.b * 255, 0, 255))
    );
  }
  getHexString(e = gt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Dn.workingColorSpace) {
    Dn.fromWorkingColorSpace($t.copy(this), t);
    const r = $t.r,
      i = $t.g,
      a = $t.b,
      s = Math.max(r, i, a),
      o = Math.min(r, i, a);
    let c, u;
    const l = (o + s) / 2;
    if (o === s) (c = 0), (u = 0);
    else {
      const f = s - o;
      switch (((u = l <= 0.5 ? f / (s + o) : f / (2 - s - o)), s)) {
        case r:
          c = (i - a) / f + (i < a ? 6 : 0);
          break;
        case i:
          c = (a - r) / f + 2;
          break;
        case a:
          c = (r - i) / f + 4;
          break;
      }
      c /= 6;
    }
    return (e.h = c), (e.s = u), (e.l = l), e;
  }
  getRGB(e, t = Dn.workingColorSpace) {
    return (
      Dn.fromWorkingColorSpace($t.copy(this), t),
      (e.r = $t.r),
      (e.g = $t.g),
      (e.b = $t.b),
      e
    );
  }
  getStyle(e = gt) {
    Dn.fromWorkingColorSpace($t.copy(this), e);
    const t = $t.r,
      r = $t.g,
      i = $t.b;
    return e !== gt
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return (
      this.getHSL(Nn),
      (Nn.h += e),
      (Nn.s += t),
      (Nn.l += r),
      this.setHSL(Nn.h, Nn.s, Nn.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Nn), e.getHSL(Fs);
    const r = $a(Nn.h, Fs.h, t),
      i = $a(Nn.s, Fs.s, t),
      a = $a(Nn.l, Fs.l, t);
    return this.setHSL(r, i, a), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      a = e.elements;
    return (
      (this.r = a[0] * t + a[3] * r + a[6] * i),
      (this.g = a[1] * t + a[4] * r + a[7] * i),
      (this.b = a[2] * t + a[5] * r + a[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const $t = new tt();
tt.NAMES = Bp;
class Vn extends fi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new tt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Oc),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const At = new B(),
  Ps = new De();
class gn {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = uf),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = Sr),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, a = this.itemSize; i < a; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        Ps.fromBufferAttribute(this, t),
          Ps.applyMatrix3(e),
          this.setXY(t, Ps.x, Ps.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        At.fromBufferAttribute(this, t),
          At.applyMatrix3(e),
          this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      At.fromBufferAttribute(this, t),
        At.applyMatrix4(e),
        this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      At.fromBufferAttribute(this, t),
        At.applyNormalMatrix(e),
        this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      At.fromBufferAttribute(this, t),
        At.transformDirection(e),
        this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = qi(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = Jt(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = qi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = qi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = qi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = qi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Jt(t, this.array)), (r = Jt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, a) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array)),
        (a = Jt(a, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = a),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== uf && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class zp extends gn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class kp extends gn {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class nt extends gn {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let _y = 0;
const yn = new ut(),
  Ou = new st(),
  Ri = new B(),
  dn = new Ir(),
  Ca = new Ir(),
  It = new B();
class wt extends ci {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _y++ }),
      (this.uuid = li()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (Lp(e) ? kp : zp)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const a = new Je().getNormalMatrix(e);
      r.applyNormalMatrix(a), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return yn.makeRotationFromQuaternion(e), this.applyMatrix4(yn), this;
  }
  rotateX(e) {
    return yn.makeRotationX(e), this.applyMatrix4(yn), this;
  }
  rotateY(e) {
    return yn.makeRotationY(e), this.applyMatrix4(yn), this;
  }
  rotateZ(e) {
    return yn.makeRotationZ(e), this.applyMatrix4(yn), this;
  }
  translate(e, t, r) {
    return yn.makeTranslation(e, t, r), this.applyMatrix4(yn), this;
  }
  scale(e, t, r) {
    return yn.makeScale(e, t, r), this.applyMatrix4(yn), this;
  }
  lookAt(e) {
    return Ou.lookAt(e), Ou.updateMatrix(), this.applyMatrix4(Ou.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ri).negate(),
      this.translate(Ri.x, Ri.y, Ri.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const a = e[r];
      t.push(a.x, a.y, a.z || 0);
    }
    return this.setAttribute("position", new nt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ir());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new B(-1 / 0, -1 / 0, -1 / 0),
          new B(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const a = t[r];
          dn.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (It.addVectors(this.boundingBox.min, dn.min),
                this.boundingBox.expandByPoint(It),
                It.addVectors(this.boundingBox.max, dn.max),
                this.boundingBox.expandByPoint(It))
              : (this.boundingBox.expandByPoint(dn.min),
                this.boundingBox.expandByPoint(dn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ma());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new B(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((dn.setFromBufferAttribute(e), t))
        for (let a = 0, s = t.length; a < s; a++) {
          const o = t[a];
          Ca.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (It.addVectors(dn.min, Ca.min),
                dn.expandByPoint(It),
                It.addVectors(dn.max, Ca.max),
                dn.expandByPoint(It))
              : (dn.expandByPoint(Ca.min), dn.expandByPoint(Ca.max));
        }
      dn.getCenter(r);
      let i = 0;
      for (let a = 0, s = e.count; a < s; a++)
        It.fromBufferAttribute(e, a),
          (i = Math.max(i, r.distanceToSquared(It)));
      if (t)
        for (let a = 0, s = t.length; a < s; a++) {
          const o = t[a],
            c = this.morphTargetsRelative;
          for (let u = 0, l = o.count; u < l; u++)
            It.fromBufferAttribute(o, u),
              c && (Ri.fromBufferAttribute(e, u), It.add(Ri)),
              (i = Math.max(i, r.distanceToSquared(It)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = e.array,
      i = t.position.array,
      a = t.normal.array,
      s = t.uv.array,
      o = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new gn(new Float32Array(4 * o), 4));
    const c = this.getAttribute("tangent").array,
      u = [],
      l = [];
    for (let D = 0; D < o; D++) (u[D] = new B()), (l[D] = new B());
    const f = new B(),
      h = new B(),
      d = new B(),
      g = new De(),
      x = new De(),
      m = new De(),
      p = new B(),
      S = new B();
    function v(D, z, $) {
      f.fromArray(i, D * 3),
        h.fromArray(i, z * 3),
        d.fromArray(i, $ * 3),
        g.fromArray(s, D * 2),
        x.fromArray(s, z * 2),
        m.fromArray(s, $ * 2),
        h.sub(f),
        d.sub(f),
        x.sub(g),
        m.sub(g);
      const I = 1 / (x.x * m.y - m.x * x.y);
      isFinite(I) &&
        (p
          .copy(h)
          .multiplyScalar(m.y)
          .addScaledVector(d, -x.y)
          .multiplyScalar(I),
        S.copy(d)
          .multiplyScalar(x.x)
          .addScaledVector(h, -m.x)
          .multiplyScalar(I),
        u[D].add(p),
        u[z].add(p),
        u[$].add(p),
        l[D].add(S),
        l[z].add(S),
        l[$].add(S));
    }
    let y = this.groups;
    y.length === 0 && (y = [{ start: 0, count: r.length }]);
    for (let D = 0, z = y.length; D < z; ++D) {
      const $ = y[D],
        I = $.start,
        G = $.count;
      for (let L = I, C = I + G; L < C; L += 3) v(r[L + 0], r[L + 1], r[L + 2]);
    }
    const E = new B(),
      M = new B(),
      T = new B(),
      N = new B();
    function A(D) {
      T.fromArray(a, D * 3), N.copy(T);
      const z = u[D];
      E.copy(z),
        E.sub(T.multiplyScalar(T.dot(z))).normalize(),
        M.crossVectors(N, z);
      const I = M.dot(l[D]) < 0 ? -1 : 1;
      (c[D * 4] = E.x),
        (c[D * 4 + 1] = E.y),
        (c[D * 4 + 2] = E.z),
        (c[D * 4 + 3] = I);
    }
    for (let D = 0, z = y.length; D < z; ++D) {
      const $ = y[D],
        I = $.start,
        G = $.count;
      for (let L = I, C = I + G; L < C; L += 3)
        A(r[L + 0]), A(r[L + 1]), A(r[L + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new gn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let h = 0, d = r.count; h < d; h++) r.setXYZ(h, 0, 0, 0);
      const i = new B(),
        a = new B(),
        s = new B(),
        o = new B(),
        c = new B(),
        u = new B(),
        l = new B(),
        f = new B();
      if (e)
        for (let h = 0, d = e.count; h < d; h += 3) {
          const g = e.getX(h + 0),
            x = e.getX(h + 1),
            m = e.getX(h + 2);
          i.fromBufferAttribute(t, g),
            a.fromBufferAttribute(t, x),
            s.fromBufferAttribute(t, m),
            l.subVectors(s, a),
            f.subVectors(i, a),
            l.cross(f),
            o.fromBufferAttribute(r, g),
            c.fromBufferAttribute(r, x),
            u.fromBufferAttribute(r, m),
            o.add(l),
            c.add(l),
            u.add(l),
            r.setXYZ(g, o.x, o.y, o.z),
            r.setXYZ(x, c.x, c.y, c.z),
            r.setXYZ(m, u.x, u.y, u.z);
        }
      else
        for (let h = 0, d = t.count; h < d; h += 3)
          i.fromBufferAttribute(t, h + 0),
            a.fromBufferAttribute(t, h + 1),
            s.fromBufferAttribute(t, h + 2),
            l.subVectors(s, a),
            f.subVectors(i, a),
            l.cross(f),
            r.setXYZ(h + 0, l.x, l.y, l.z),
            r.setXYZ(h + 1, l.x, l.y, l.z),
            r.setXYZ(h + 2, l.x, l.y, l.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      It.fromBufferAttribute(e, t),
        It.normalize(),
        e.setXYZ(t, It.x, It.y, It.z);
  }
  toNonIndexed() {
    function e(o, c) {
      const u = o.array,
        l = o.itemSize,
        f = o.normalized,
        h = new u.constructor(c.length * l);
      let d = 0,
        g = 0;
      for (let x = 0, m = c.length; x < m; x++) {
        o.isInterleavedBufferAttribute
          ? (d = c[x] * o.data.stride + o.offset)
          : (d = c[x] * l);
        for (let p = 0; p < l; p++) h[g++] = u[d++];
      }
      return new gn(h, l, f);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new wt(),
      r = this.index.array,
      i = this.attributes;
    for (const o in i) {
      const c = i[o],
        u = e(c, r);
      t.setAttribute(o, u);
    }
    const a = this.morphAttributes;
    for (const o in a) {
      const c = [],
        u = a[o];
      for (let l = 0, f = u.length; l < f; l++) {
        const h = u[l],
          d = e(h, r);
        c.push(d);
      }
      t.morphAttributes[o] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let o = 0, c = s.length; o < c; o++) {
      const u = s[o];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const c = this.parameters;
      for (const u in c) c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const c in r) {
      const u = r[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const i = {};
    let a = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c],
        l = [];
      for (let f = 0, h = u.length; f < h; f++) {
        const d = u[f];
        l.push(d.toJSON(e.data));
      }
      l.length > 0 && ((i[c] = l), (a = !0));
    }
    a &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const u in i) {
      const l = i[u];
      this.setAttribute(u, l.clone(t));
    }
    const a = e.morphAttributes;
    for (const u in a) {
      const l = [],
        f = a[u];
      for (let h = 0, d = f.length; h < d; h++) l.push(f[h].clone(t));
      this.morphAttributes[u] = l;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let u = 0, l = s.length; u < l; u++) {
      const f = s[u];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const c = e.boundingSphere;
    return (
      c !== null && (this.boundingSphere = c.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const bf = new ut(),
  Vr = new Vo(),
  Ls = new ma(),
  _f = new B(),
  Fi = new B(),
  Pi = new B(),
  Li = new B(),
  Uu = new B(),
  Is = new B(),
  Os = new De(),
  Us = new De(),
  Bs = new De(),
  wf = new B(),
  Ef = new B(),
  Sf = new B(),
  zs = new B(),
  ks = new B();
class Re extends st {
  constructor(e = new wt(), t = new Vn()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let a = 0, s = i.length; a < s; a++) {
          const o = i[a].name || String(a);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = a);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      a = r.morphAttributes.position,
      s = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const o = this.morphTargetInfluences;
    if (a && o) {
      Is.set(0, 0, 0);
      for (let c = 0, u = a.length; c < u; c++) {
        const l = o[c],
          f = a[c];
        l !== 0 &&
          (Uu.fromBufferAttribute(f, e),
          s ? Is.addScaledVector(Uu, l) : Is.addScaledVector(Uu.sub(t), l));
      }
      t.add(Is);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      a = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Ls.copy(r.boundingSphere),
      Ls.applyMatrix4(a),
      Vr.copy(e.ray).recast(e.near),
      !(
        Ls.containsPoint(Vr.origin) === !1 &&
        (Vr.intersectSphere(Ls, _f) === null ||
          Vr.origin.distanceToSquared(_f) > (e.far - e.near) ** 2)
      ) &&
        (bf.copy(a).invert(),
        Vr.copy(e.ray).applyMatrix4(bf),
        !(r.boundingBox !== null && Vr.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, Vr)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const a = this.geometry,
      s = this.material,
      o = a.index,
      c = a.attributes.position,
      u = a.attributes.uv,
      l = a.attributes.uv1,
      f = a.attributes.normal,
      h = a.groups,
      d = a.drawRange;
    if (o !== null)
      if (Array.isArray(s))
        for (let g = 0, x = h.length; g < x; g++) {
          const m = h[g],
            p = s[m.materialIndex],
            S = Math.max(m.start, d.start),
            v = Math.min(
              o.count,
              Math.min(m.start + m.count, d.start + d.count)
            );
          for (let y = S, E = v; y < E; y += 3) {
            const M = o.getX(y),
              T = o.getX(y + 1),
              N = o.getX(y + 2);
            (i = Hs(this, p, e, r, u, l, f, M, T, N)),
              i &&
                ((i.faceIndex = Math.floor(y / 3)),
                (i.face.materialIndex = m.materialIndex),
                t.push(i));
          }
        }
      else {
        const g = Math.max(0, d.start),
          x = Math.min(o.count, d.start + d.count);
        for (let m = g, p = x; m < p; m += 3) {
          const S = o.getX(m),
            v = o.getX(m + 1),
            y = o.getX(m + 2);
          (i = Hs(this, s, e, r, u, l, f, S, v, y)),
            i && ((i.faceIndex = Math.floor(m / 3)), t.push(i));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(s))
        for (let g = 0, x = h.length; g < x; g++) {
          const m = h[g],
            p = s[m.materialIndex],
            S = Math.max(m.start, d.start),
            v = Math.min(
              c.count,
              Math.min(m.start + m.count, d.start + d.count)
            );
          for (let y = S, E = v; y < E; y += 3) {
            const M = y,
              T = y + 1,
              N = y + 2;
            (i = Hs(this, p, e, r, u, l, f, M, T, N)),
              i &&
                ((i.faceIndex = Math.floor(y / 3)),
                (i.face.materialIndex = m.materialIndex),
                t.push(i));
          }
        }
      else {
        const g = Math.max(0, d.start),
          x = Math.min(c.count, d.start + d.count);
        for (let m = g, p = x; m < p; m += 3) {
          const S = m,
            v = m + 1,
            y = m + 2;
          (i = Hs(this, s, e, r, u, l, f, S, v, y)),
            i && ((i.faceIndex = Math.floor(m / 3)), t.push(i));
        }
      }
  }
}
function wy(n, e, t, r, i, a, s, o) {
  let c;
  if (
    (e.side === en
      ? (c = r.intersectTriangle(s, a, i, !0, o))
      : (c = r.intersectTriangle(i, a, s, e.side === lr, o)),
    c === null)
  )
    return null;
  ks.copy(o), ks.applyMatrix4(n.matrixWorld);
  const u = t.ray.origin.distanceTo(ks);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: ks.clone(), object: n };
}
function Hs(n, e, t, r, i, a, s, o, c, u) {
  n.getVertexPosition(o, Fi),
    n.getVertexPosition(c, Pi),
    n.getVertexPosition(u, Li);
  const l = wy(n, e, t, r, Fi, Pi, Li, zs);
  if (l) {
    i &&
      (Os.fromBufferAttribute(i, o),
      Us.fromBufferAttribute(i, c),
      Bs.fromBufferAttribute(i, u),
      (l.uv = Rn.getInterpolation(zs, Fi, Pi, Li, Os, Us, Bs, new De()))),
      a &&
        (Os.fromBufferAttribute(a, o),
        Us.fromBufferAttribute(a, c),
        Bs.fromBufferAttribute(a, u),
        (l.uv1 = Rn.getInterpolation(zs, Fi, Pi, Li, Os, Us, Bs, new De())),
        (l.uv2 = l.uv1)),
      s &&
        (wf.fromBufferAttribute(s, o),
        Ef.fromBufferAttribute(s, c),
        Sf.fromBufferAttribute(s, u),
        (l.normal = Rn.getInterpolation(zs, Fi, Pi, Li, wf, Ef, Sf, new B())),
        l.normal.dot(r.direction) > 0 && l.normal.multiplyScalar(-1));
    const f = { a: o, b: c, c: u, normal: new B(), materialIndex: 0 };
    Rn.getNormal(Fi, Pi, Li, f.normal), (l.face = f);
  }
  return l;
}
class mt extends wt {
  constructor(e = 1, t = 1, r = 1, i = 1, a = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: a,
        depthSegments: s,
      });
    const o = this;
    (i = Math.floor(i)), (a = Math.floor(a)), (s = Math.floor(s));
    const c = [],
      u = [],
      l = [],
      f = [];
    let h = 0,
      d = 0;
    g("z", "y", "x", -1, -1, r, t, e, s, a, 0),
      g("z", "y", "x", 1, -1, r, t, -e, s, a, 1),
      g("x", "z", "y", 1, 1, e, r, t, i, s, 2),
      g("x", "z", "y", 1, -1, e, r, -t, i, s, 3),
      g("x", "y", "z", 1, -1, e, t, r, i, a, 4),
      g("x", "y", "z", -1, -1, e, t, -r, i, a, 5),
      this.setIndex(c),
      this.setAttribute("position", new nt(u, 3)),
      this.setAttribute("normal", new nt(l, 3)),
      this.setAttribute("uv", new nt(f, 2));
    function g(x, m, p, S, v, y, E, M, T, N, A) {
      const D = y / T,
        z = E / N,
        $ = y / 2,
        I = E / 2,
        G = M / 2,
        L = T + 1,
        C = N + 1;
      let k = 0,
        Z = 0;
      const ie = new B();
      for (let ne = 0; ne < C; ne++) {
        const Y = ne * z - I;
        for (let W = 0; W < L; W++) {
          const te = W * D - $;
          (ie[x] = te * S),
            (ie[m] = Y * v),
            (ie[p] = G),
            u.push(ie.x, ie.y, ie.z),
            (ie[x] = 0),
            (ie[m] = 0),
            (ie[p] = M > 0 ? 1 : -1),
            l.push(ie.x, ie.y, ie.z),
            f.push(W / T),
            f.push(1 - ne / N),
            (k += 1);
        }
      }
      for (let ne = 0; ne < N; ne++)
        for (let Y = 0; Y < T; Y++) {
          const W = h + Y + L * ne,
            te = h + Y + L * (ne + 1),
            ve = h + (Y + 1) + L * (ne + 1),
            be = h + (Y + 1) + L * ne;
          c.push(W, te, be), c.push(te, ve, be), (Z += 6);
        }
      o.addGroup(d, Z, A), (d += Z), (h += k);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new mt(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function ca(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function Kt(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = ca(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function Ey(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function Hp(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : Gn;
}
const Sy = { clone: ca, merge: Kt };
var My = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Ay = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ii extends fi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = My),
      (this.fragmentShader = Ay),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = ca(e.uniforms)),
      (this.uniformsGroups = Ey(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const s = this.uniforms[i].value;
      s && s.isTexture
        ? (t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
        : s && s.isColor
        ? (t.uniforms[i] = { type: "c", value: s.getHex() })
        : s && s.isVector2
        ? (t.uniforms[i] = { type: "v2", value: s.toArray() })
        : s && s.isVector3
        ? (t.uniforms[i] = { type: "v3", value: s.toArray() })
        : s && s.isVector4
        ? (t.uniforms[i] = { type: "v4", value: s.toArray() })
        : s && s.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: s.toArray() })
        : s && s.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: s.toArray() })
        : (t.uniforms[i] = { value: s });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class Gp extends st {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new ut()),
      (this.projectionMatrix = new ut()),
      (this.projectionMatrixInverse = new ut()),
      (this.coordinateSystem = sr);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class an extends Gp {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = ns * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(qa * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return ns * 2 * Math.atan(Math.tan(qa * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, r, i, a, s) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = a),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(qa * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      a = -0.5 * i;
    const s = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = s.fullWidth,
        u = s.fullHeight;
      (a += (s.offsetX * i) / c),
        (t -= (s.offsetY * r) / u),
        (i *= s.width / c),
        (r *= s.height / u);
    }
    const o = this.filmOffset;
    o !== 0 && (a += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        a,
        a + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Ii = -90,
  Oi = 1;
class Dy extends st {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null);
    const i = new an(Ii, Oi, e, t);
    (i.layers = this.layers), this.add(i);
    const a = new an(Ii, Oi, e, t);
    (a.layers = this.layers), this.add(a);
    const s = new an(Ii, Oi, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new an(Ii, Oi, e, t);
    (o.layers = this.layers), this.add(o);
    const c = new an(Ii, Oi, e, t);
    (c.layers = this.layers), this.add(c);
    const u = new an(Ii, Oi, e, t);
    (u.layers = this.layers), this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, a, s, o, c] = t;
    for (const u of t) this.remove(u);
    if (e === sr)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, 1, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, -1, 0),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1);
    else if (e === Ao)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, 1, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, -1, 0),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, 1),
        c.up.set(0, -1, 0),
        c.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const u of t) this.add(u), u.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const r = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [i, a, s, o, c, u] = this.children,
      l = e.getRenderTarget(),
      f = e.xr.enabled;
    e.xr.enabled = !1;
    const h = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0),
      e.render(t, i),
      e.setRenderTarget(r, 1),
      e.render(t, a),
      e.setRenderTarget(r, 2),
      e.render(t, s),
      e.setRenderTarget(r, 3),
      e.render(t, o),
      e.setRenderTarget(r, 4),
      e.render(t, c),
      (r.texture.generateMipmaps = h),
      e.setRenderTarget(r, 5),
      e.render(t, u),
      e.setRenderTarget(l),
      (e.xr.enabled = f),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class Vp extends sn {
  constructor(e, t, r, i, a, s, o, c, u, l) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : sa),
      super(e, t, r, i, a, s, o, c, u, l),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Ty extends ri {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    t.encoding !== void 0 &&
      (ja(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === ti ? gt : ni)),
      (this.texture = new Vp(
        i,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : wn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new mt(5, 5, 5),
      a = new ii({
        name: "CubemapFromEquirect",
        uniforms: ca(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: en,
        blending: Tr,
      });
    a.uniforms.tEquirect.value = t;
    const s = new Re(i, a),
      o = t.minFilter;
    return (
      t.minFilter === es && (t.minFilter = wn),
      new Dy(1, 10, this).update(e, s),
      (t.minFilter = o),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, t, r, i) {
    const a = e.getRenderTarget();
    for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, r, i);
    e.setRenderTarget(a);
  }
}
const Bu = new B(),
  Cy = new B(),
  Ny = new Je();
class br {
  constructor(e = new B(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = Bu.subVectors(r, t).cross(Cy.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(Bu),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / i;
    return a < 0 || a > 1 ? null : t.copy(e.start).addScaledVector(r, a);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || Ny.getNormalMatrix(e),
      i = this.coplanarPoint(Bu).applyMatrix4(e),
      a = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(a)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Wr = new ma(),
  Gs = new B();
class Hc {
  constructor(
    e = new br(),
    t = new br(),
    r = new br(),
    i = new br(),
    a = new br(),
    s = new br()
  ) {
    this.planes = [e, t, r, i, a, s];
  }
  set(e, t, r, i, a, s) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(r),
      o[3].copy(i),
      o[4].copy(a),
      o[5].copy(s),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = sr) {
    const r = this.planes,
      i = e.elements,
      a = i[0],
      s = i[1],
      o = i[2],
      c = i[3],
      u = i[4],
      l = i[5],
      f = i[6],
      h = i[7],
      d = i[8],
      g = i[9],
      x = i[10],
      m = i[11],
      p = i[12],
      S = i[13],
      v = i[14],
      y = i[15];
    if (
      (r[0].setComponents(c - a, h - u, m - d, y - p).normalize(),
      r[1].setComponents(c + a, h + u, m + d, y + p).normalize(),
      r[2].setComponents(c + s, h + l, m + g, y + S).normalize(),
      r[3].setComponents(c - s, h - l, m - g, y - S).normalize(),
      r[4].setComponents(c - o, h - f, m - x, y - v).normalize(),
      t === sr)
    )
      r[5].setComponents(c + o, h + f, m + x, y + v).normalize();
    else if (t === Ao) r[5].setComponents(o, f, x, v).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Wr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Wr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Wr);
  }
  intersectsSprite(e) {
    return (
      Wr.center.set(0, 0, 0),
      (Wr.radius = 0.7071067811865476),
      Wr.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Wr)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let a = 0; a < 6; a++) if (t[a].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((Gs.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Gs.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Gs.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Gs) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Wp() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(a, s) {
    t(a, s), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (a) {
      t = a;
    },
    setContext: function (a) {
      n = a;
    },
  };
}
function Ry(n, e) {
  const t = e.isWebGL2,
    r = new WeakMap();
  function i(u, l) {
    const f = u.array,
      h = u.usage,
      d = n.createBuffer();
    n.bindBuffer(l, d), n.bufferData(l, f, h), u.onUploadCallback();
    let g;
    if (f instanceof Float32Array) g = n.FLOAT;
    else if (f instanceof Uint16Array)
      if (u.isFloat16BufferAttribute)
        if (t) g = n.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else g = n.UNSIGNED_SHORT;
    else if (f instanceof Int16Array) g = n.SHORT;
    else if (f instanceof Uint32Array) g = n.UNSIGNED_INT;
    else if (f instanceof Int32Array) g = n.INT;
    else if (f instanceof Int8Array) g = n.BYTE;
    else if (f instanceof Uint8Array) g = n.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray) g = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + f
      );
    return {
      buffer: d,
      type: g,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: u.version,
    };
  }
  function a(u, l, f) {
    const h = l.array,
      d = l.updateRange;
    n.bindBuffer(f, u),
      d.count === -1
        ? n.bufferSubData(f, 0, h)
        : (t
            ? n.bufferSubData(
                f,
                d.offset * h.BYTES_PER_ELEMENT,
                h,
                d.offset,
                d.count
              )
            : n.bufferSubData(
                f,
                d.offset * h.BYTES_PER_ELEMENT,
                h.subarray(d.offset, d.offset + d.count)
              ),
          (d.count = -1)),
      l.onUploadCallback();
  }
  function s(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), r.get(u);
  }
  function o(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const l = r.get(u);
    l && (n.deleteBuffer(l.buffer), r.delete(u));
  }
  function c(u, l) {
    if (u.isGLBufferAttribute) {
      const h = r.get(u);
      (!h || h.version < u.version) &&
        r.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    u.isInterleavedBufferAttribute && (u = u.data);
    const f = r.get(u);
    f === void 0
      ? r.set(u, i(u, l))
      : f.version < u.version && (a(f.buffer, u, l), (f.version = u.version));
  }
  return { get: s, remove: o, update: c };
}
class ga extends wt {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const a = e / 2,
      s = t / 2,
      o = Math.floor(r),
      c = Math.floor(i),
      u = o + 1,
      l = c + 1,
      f = e / o,
      h = t / c,
      d = [],
      g = [],
      x = [],
      m = [];
    for (let p = 0; p < l; p++) {
      const S = p * h - s;
      for (let v = 0; v < u; v++) {
        const y = v * f - a;
        g.push(y, -S, 0), x.push(0, 0, 1), m.push(v / o), m.push(1 - p / c);
      }
    }
    for (let p = 0; p < c; p++)
      for (let S = 0; S < o; S++) {
        const v = S + u * p,
          y = S + u * (p + 1),
          E = S + 1 + u * (p + 1),
          M = S + 1 + u * p;
        d.push(v, y, M), d.push(y, E, M);
      }
    this.setIndex(d),
      this.setAttribute("position", new nt(g, 3)),
      this.setAttribute("normal", new nt(x, 3)),
      this.setAttribute("uv", new nt(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ga(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Fy = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  Py = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  Ly = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  Iy = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Oy = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  Uy = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  By = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  zy = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  ky = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Hy = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Gy = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Vy = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Wy = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  qy = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  $y = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  jy = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Xy = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Yy = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Zy = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Jy = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  Ky = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  Qy = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  ex = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  tx = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  nx = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  rx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  ix = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  ax = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  sx = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  ox = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  ux = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  cx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  lx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  fx = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  hx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  dx = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  px = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  mx = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  gx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  vx = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  yx = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  xx = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  bx = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  _x = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  wx = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Ex = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  Sx = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Mx = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  Ax = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Dx = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Tx = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  Cx = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Nx = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Rx = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Fx = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  Px = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Lx = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Ix = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  Ox = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  Ux = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Bx = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  zx = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  kx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Hx = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Gx = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Vx = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Wx = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  qx = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  $x = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  jx = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  Xx = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Yx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Zx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Jx = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Kx = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Qx = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  e1 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  t1 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  n1 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  r1 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  i1 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  a1 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  s1 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  o1 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  u1 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  c1 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  l1 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  f1 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  h1 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  d1 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  p1 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  m1 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  g1 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  v1 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  y1 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  x1 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  b1 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  _1 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  w1 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  E1 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  S1 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  M1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  A1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  D1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  T1 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const C1 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  N1 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  R1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  F1 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  P1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  L1 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  I1 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  O1 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  U1 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  B1 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  z1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  k1 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  H1 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  G1 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  V1 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  W1 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  q1 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  $1 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  j1 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  X1 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Y1 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Z1 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  J1 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  K1 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Q1 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  eb = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  tb = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  nb = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  rb = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  ib = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  ab = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  sb = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ob = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ub = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Ze = {
    alphahash_fragment: Fy,
    alphahash_pars_fragment: Py,
    alphamap_fragment: Ly,
    alphamap_pars_fragment: Iy,
    alphatest_fragment: Oy,
    alphatest_pars_fragment: Uy,
    aomap_fragment: By,
    aomap_pars_fragment: zy,
    begin_vertex: ky,
    beginnormal_vertex: Hy,
    bsdfs: Gy,
    iridescence_fragment: Vy,
    bumpmap_pars_fragment: Wy,
    clipping_planes_fragment: qy,
    clipping_planes_pars_fragment: $y,
    clipping_planes_pars_vertex: jy,
    clipping_planes_vertex: Xy,
    color_fragment: Yy,
    color_pars_fragment: Zy,
    color_pars_vertex: Jy,
    color_vertex: Ky,
    common: Qy,
    cube_uv_reflection_fragment: ex,
    defaultnormal_vertex: tx,
    displacementmap_pars_vertex: nx,
    displacementmap_vertex: rx,
    emissivemap_fragment: ix,
    emissivemap_pars_fragment: ax,
    colorspace_fragment: sx,
    colorspace_pars_fragment: ox,
    envmap_fragment: ux,
    envmap_common_pars_fragment: cx,
    envmap_pars_fragment: lx,
    envmap_pars_vertex: fx,
    envmap_physical_pars_fragment: Ex,
    envmap_vertex: hx,
    fog_vertex: dx,
    fog_pars_vertex: px,
    fog_fragment: mx,
    fog_pars_fragment: gx,
    gradientmap_pars_fragment: vx,
    lightmap_fragment: yx,
    lightmap_pars_fragment: xx,
    lights_lambert_fragment: bx,
    lights_lambert_pars_fragment: _x,
    lights_pars_begin: wx,
    lights_toon_fragment: Sx,
    lights_toon_pars_fragment: Mx,
    lights_phong_fragment: Ax,
    lights_phong_pars_fragment: Dx,
    lights_physical_fragment: Tx,
    lights_physical_pars_fragment: Cx,
    lights_fragment_begin: Nx,
    lights_fragment_maps: Rx,
    lights_fragment_end: Fx,
    logdepthbuf_fragment: Px,
    logdepthbuf_pars_fragment: Lx,
    logdepthbuf_pars_vertex: Ix,
    logdepthbuf_vertex: Ox,
    map_fragment: Ux,
    map_pars_fragment: Bx,
    map_particle_fragment: zx,
    map_particle_pars_fragment: kx,
    metalnessmap_fragment: Hx,
    metalnessmap_pars_fragment: Gx,
    morphcolor_vertex: Vx,
    morphnormal_vertex: Wx,
    morphtarget_pars_vertex: qx,
    morphtarget_vertex: $x,
    normal_fragment_begin: jx,
    normal_fragment_maps: Xx,
    normal_pars_fragment: Yx,
    normal_pars_vertex: Zx,
    normal_vertex: Jx,
    normalmap_pars_fragment: Kx,
    clearcoat_normal_fragment_begin: Qx,
    clearcoat_normal_fragment_maps: e1,
    clearcoat_pars_fragment: t1,
    iridescence_pars_fragment: n1,
    opaque_fragment: r1,
    packing: i1,
    premultiplied_alpha_fragment: a1,
    project_vertex: s1,
    dithering_fragment: o1,
    dithering_pars_fragment: u1,
    roughnessmap_fragment: c1,
    roughnessmap_pars_fragment: l1,
    shadowmap_pars_fragment: f1,
    shadowmap_pars_vertex: h1,
    shadowmap_vertex: d1,
    shadowmask_pars_fragment: p1,
    skinbase_vertex: m1,
    skinning_pars_vertex: g1,
    skinning_vertex: v1,
    skinnormal_vertex: y1,
    specularmap_fragment: x1,
    specularmap_pars_fragment: b1,
    tonemapping_fragment: _1,
    tonemapping_pars_fragment: w1,
    transmission_fragment: E1,
    transmission_pars_fragment: S1,
    uv_pars_fragment: M1,
    uv_pars_vertex: A1,
    uv_vertex: D1,
    worldpos_vertex: T1,
    background_vert: C1,
    background_frag: N1,
    backgroundCube_vert: R1,
    backgroundCube_frag: F1,
    cube_vert: P1,
    cube_frag: L1,
    depth_vert: I1,
    depth_frag: O1,
    distanceRGBA_vert: U1,
    distanceRGBA_frag: B1,
    equirect_vert: z1,
    equirect_frag: k1,
    linedashed_vert: H1,
    linedashed_frag: G1,
    meshbasic_vert: V1,
    meshbasic_frag: W1,
    meshlambert_vert: q1,
    meshlambert_frag: $1,
    meshmatcap_vert: j1,
    meshmatcap_frag: X1,
    meshnormal_vert: Y1,
    meshnormal_frag: Z1,
    meshphong_vert: J1,
    meshphong_frag: K1,
    meshphysical_vert: Q1,
    meshphysical_frag: eb,
    meshtoon_vert: tb,
    meshtoon_frag: nb,
    points_vert: rb,
    points_frag: ib,
    shadow_vert: ab,
    shadow_frag: sb,
    sprite_vert: ob,
    sprite_frag: ub,
  },
  Le = {
    common: {
      diffuse: { value: new tt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Je() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Je() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Je() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Je() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Je() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Je() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Je() },
      normalScale: { value: new De(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Je() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Je() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Je() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Je() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new tt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new tt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Je() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Je() },
    },
    sprite: {
      diffuse: { value: new tt(16777215) },
      opacity: { value: 1 },
      center: { value: new De(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Je() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Je() },
      alphaTest: { value: 0 },
    },
  },
  kn = {
    basic: {
      uniforms: Kt([
        Le.common,
        Le.specularmap,
        Le.envmap,
        Le.aomap,
        Le.lightmap,
        Le.fog,
      ]),
      vertexShader: Ze.meshbasic_vert,
      fragmentShader: Ze.meshbasic_frag,
    },
    lambert: {
      uniforms: Kt([
        Le.common,
        Le.specularmap,
        Le.envmap,
        Le.aomap,
        Le.lightmap,
        Le.emissivemap,
        Le.bumpmap,
        Le.normalmap,
        Le.displacementmap,
        Le.fog,
        Le.lights,
        { emissive: { value: new tt(0) } },
      ]),
      vertexShader: Ze.meshlambert_vert,
      fragmentShader: Ze.meshlambert_frag,
    },
    phong: {
      uniforms: Kt([
        Le.common,
        Le.specularmap,
        Le.envmap,
        Le.aomap,
        Le.lightmap,
        Le.emissivemap,
        Le.bumpmap,
        Le.normalmap,
        Le.displacementmap,
        Le.fog,
        Le.lights,
        {
          emissive: { value: new tt(0) },
          specular: { value: new tt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ze.meshphong_vert,
      fragmentShader: Ze.meshphong_frag,
    },
    standard: {
      uniforms: Kt([
        Le.common,
        Le.envmap,
        Le.aomap,
        Le.lightmap,
        Le.emissivemap,
        Le.bumpmap,
        Le.normalmap,
        Le.displacementmap,
        Le.roughnessmap,
        Le.metalnessmap,
        Le.fog,
        Le.lights,
        {
          emissive: { value: new tt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ze.meshphysical_vert,
      fragmentShader: Ze.meshphysical_frag,
    },
    toon: {
      uniforms: Kt([
        Le.common,
        Le.aomap,
        Le.lightmap,
        Le.emissivemap,
        Le.bumpmap,
        Le.normalmap,
        Le.displacementmap,
        Le.gradientmap,
        Le.fog,
        Le.lights,
        { emissive: { value: new tt(0) } },
      ]),
      vertexShader: Ze.meshtoon_vert,
      fragmentShader: Ze.meshtoon_frag,
    },
    matcap: {
      uniforms: Kt([
        Le.common,
        Le.bumpmap,
        Le.normalmap,
        Le.displacementmap,
        Le.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ze.meshmatcap_vert,
      fragmentShader: Ze.meshmatcap_frag,
    },
    points: {
      uniforms: Kt([Le.points, Le.fog]),
      vertexShader: Ze.points_vert,
      fragmentShader: Ze.points_frag,
    },
    dashed: {
      uniforms: Kt([
        Le.common,
        Le.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ze.linedashed_vert,
      fragmentShader: Ze.linedashed_frag,
    },
    depth: {
      uniforms: Kt([Le.common, Le.displacementmap]),
      vertexShader: Ze.depth_vert,
      fragmentShader: Ze.depth_frag,
    },
    normal: {
      uniforms: Kt([
        Le.common,
        Le.bumpmap,
        Le.normalmap,
        Le.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ze.meshnormal_vert,
      fragmentShader: Ze.meshnormal_frag,
    },
    sprite: {
      uniforms: Kt([Le.sprite, Le.fog]),
      vertexShader: Ze.sprite_vert,
      fragmentShader: Ze.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Je() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ze.background_vert,
      fragmentShader: Ze.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ze.backgroundCube_vert,
      fragmentShader: Ze.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Ze.cube_vert,
      fragmentShader: Ze.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ze.equirect_vert,
      fragmentShader: Ze.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Kt([
        Le.common,
        Le.displacementmap,
        {
          referencePosition: { value: new B() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ze.distanceRGBA_vert,
      fragmentShader: Ze.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Kt([
        Le.lights,
        Le.fog,
        { color: { value: new tt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ze.shadow_vert,
      fragmentShader: Ze.shadow_frag,
    },
  };
kn.physical = {
  uniforms: Kt([
    kn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Je() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Je() },
      clearcoatNormalScale: { value: new De(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Je() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Je() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Je() },
      sheen: { value: 0 },
      sheenColor: { value: new tt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Je() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Je() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Je() },
      transmissionSamplerSize: { value: new De() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Je() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new tt(0) },
      specularColor: { value: new tt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Je() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Je() },
      anisotropyVector: { value: new De() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Je() },
    },
  ]),
  vertexShader: Ze.meshphysical_vert,
  fragmentShader: Ze.meshphysical_frag,
};
const Vs = { r: 0, b: 0, g: 0 };
function cb(n, e, t, r, i, a, s) {
  const o = new tt(0);
  let c = a === !0 ? 0 : 1,
    u,
    l,
    f = null,
    h = 0,
    d = null;
  function g(m, p) {
    let S = !1,
      v = p.isScene === !0 ? p.background : null;
    v && v.isTexture && (v = (p.backgroundBlurriness > 0 ? t : e).get(v)),
      v === null ? x(o, c) : v && v.isColor && (x(v, 1), (S = !0));
    const y = n.xr.getEnvironmentBlendMode();
    y === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, s)
      : y === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s),
      (n.autoClear || S) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      v && (v.isCubeTexture || v.mapping === Ho)
        ? (l === void 0 &&
            ((l = new Re(
              new mt(1, 1, 1),
              new ii({
                name: "BackgroundCubeMaterial",
                uniforms: ca(kn.backgroundCube.uniforms),
                vertexShader: kn.backgroundCube.vertexShader,
                fragmentShader: kn.backgroundCube.fragmentShader,
                side: en,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            l.geometry.deleteAttribute("normal"),
            l.geometry.deleteAttribute("uv"),
            (l.onBeforeRender = function (E, M, T) {
              this.matrixWorld.copyPosition(T.matrixWorld);
            }),
            Object.defineProperty(l.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(l)),
          (l.material.uniforms.envMap.value = v),
          (l.material.uniforms.flipEnvMap.value =
            v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
          (l.material.uniforms.backgroundBlurriness.value =
            p.backgroundBlurriness),
          (l.material.uniforms.backgroundIntensity.value =
            p.backgroundIntensity),
          (l.material.toneMapped = v.colorSpace !== gt),
          (f !== v || h !== v.version || d !== n.toneMapping) &&
            ((l.material.needsUpdate = !0),
            (f = v),
            (h = v.version),
            (d = n.toneMapping)),
          l.layers.enableAll(),
          m.unshift(l, l.geometry, l.material, 0, 0, null))
        : v &&
          v.isTexture &&
          (u === void 0 &&
            ((u = new Re(
              new ga(2, 2),
              new ii({
                name: "BackgroundMaterial",
                uniforms: ca(kn.background.uniforms),
                vertexShader: kn.background.vertexShader,
                fragmentShader: kn.background.fragmentShader,
                side: lr,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            Object.defineProperty(u.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(u)),
          (u.material.uniforms.t2D.value = v),
          (u.material.uniforms.backgroundIntensity.value =
            p.backgroundIntensity),
          (u.material.toneMapped = v.colorSpace !== gt),
          v.matrixAutoUpdate === !0 && v.updateMatrix(),
          u.material.uniforms.uvTransform.value.copy(v.matrix),
          (f !== v || h !== v.version || d !== n.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (f = v),
            (h = v.version),
            (d = n.toneMapping)),
          u.layers.enableAll(),
          m.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function x(m, p) {
    m.getRGB(Vs, Hp(n)), r.buffers.color.setClear(Vs.r, Vs.g, Vs.b, p, s);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (m, p = 1) {
      o.set(m), (c = p), x(o, c);
    },
    getClearAlpha: function () {
      return c;
    },
    setClearAlpha: function (m) {
      (c = m), x(o, c);
    },
    render: g,
  };
}
function lb(n, e, t, r) {
  const i = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    a = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    s = r.isWebGL2 || a !== null,
    o = {},
    c = m(null);
  let u = c,
    l = !1;
  function f(G, L, C, k, Z) {
    let ie = !1;
    if (s) {
      const ne = x(k, C, L);
      u !== ne && ((u = ne), d(u.object)),
        (ie = p(G, k, C, Z)),
        ie && S(G, k, C, Z);
    } else {
      const ne = L.wireframe === !0;
      (u.geometry !== k.id || u.program !== C.id || u.wireframe !== ne) &&
        ((u.geometry = k.id),
        (u.program = C.id),
        (u.wireframe = ne),
        (ie = !0));
    }
    Z !== null && t.update(Z, n.ELEMENT_ARRAY_BUFFER),
      (ie || l) &&
        ((l = !1),
        N(G, L, C, k),
        Z !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(Z).buffer));
  }
  function h() {
    return r.isWebGL2 ? n.createVertexArray() : a.createVertexArrayOES();
  }
  function d(G) {
    return r.isWebGL2 ? n.bindVertexArray(G) : a.bindVertexArrayOES(G);
  }
  function g(G) {
    return r.isWebGL2 ? n.deleteVertexArray(G) : a.deleteVertexArrayOES(G);
  }
  function x(G, L, C) {
    const k = C.wireframe === !0;
    let Z = o[G.id];
    Z === void 0 && ((Z = {}), (o[G.id] = Z));
    let ie = Z[L.id];
    ie === void 0 && ((ie = {}), (Z[L.id] = ie));
    let ne = ie[k];
    return ne === void 0 && ((ne = m(h())), (ie[k] = ne)), ne;
  }
  function m(G) {
    const L = [],
      C = [],
      k = [];
    for (let Z = 0; Z < i; Z++) (L[Z] = 0), (C[Z] = 0), (k[Z] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: L,
      enabledAttributes: C,
      attributeDivisors: k,
      object: G,
      attributes: {},
      index: null,
    };
  }
  function p(G, L, C, k) {
    const Z = u.attributes,
      ie = L.attributes;
    let ne = 0;
    const Y = C.getAttributes();
    for (const W in Y)
      if (Y[W].location >= 0) {
        const ve = Z[W];
        let be = ie[W];
        if (
          (be === void 0 &&
            (W === "instanceMatrix" &&
              G.instanceMatrix &&
              (be = G.instanceMatrix),
            W === "instanceColor" && G.instanceColor && (be = G.instanceColor)),
          ve === void 0 || ve.attribute !== be || (be && ve.data !== be.data))
        )
          return !0;
        ne++;
      }
    return u.attributesNum !== ne || u.index !== k;
  }
  function S(G, L, C, k) {
    const Z = {},
      ie = L.attributes;
    let ne = 0;
    const Y = C.getAttributes();
    for (const W in Y)
      if (Y[W].location >= 0) {
        let ve = ie[W];
        ve === void 0 &&
          (W === "instanceMatrix" &&
            G.instanceMatrix &&
            (ve = G.instanceMatrix),
          W === "instanceColor" && G.instanceColor && (ve = G.instanceColor));
        const be = {};
        (be.attribute = ve),
          ve && ve.data && (be.data = ve.data),
          (Z[W] = be),
          ne++;
      }
    (u.attributes = Z), (u.attributesNum = ne), (u.index = k);
  }
  function v() {
    const G = u.newAttributes;
    for (let L = 0, C = G.length; L < C; L++) G[L] = 0;
  }
  function y(G) {
    E(G, 0);
  }
  function E(G, L) {
    const C = u.newAttributes,
      k = u.enabledAttributes,
      Z = u.attributeDivisors;
    (C[G] = 1),
      k[G] === 0 && (n.enableVertexAttribArray(G), (k[G] = 1)),
      Z[G] !== L &&
        ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](G, L),
        (Z[G] = L));
  }
  function M() {
    const G = u.newAttributes,
      L = u.enabledAttributes;
    for (let C = 0, k = L.length; C < k; C++)
      L[C] !== G[C] && (n.disableVertexAttribArray(C), (L[C] = 0));
  }
  function T(G, L, C, k, Z, ie, ne) {
    ne === !0
      ? n.vertexAttribIPointer(G, L, C, Z, ie)
      : n.vertexAttribPointer(G, L, C, k, Z, ie);
  }
  function N(G, L, C, k) {
    if (
      r.isWebGL2 === !1 &&
      (G.isInstancedMesh || k.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    v();
    const Z = k.attributes,
      ie = C.getAttributes(),
      ne = L.defaultAttributeValues;
    for (const Y in ie) {
      const W = ie[Y];
      if (W.location >= 0) {
        let te = Z[Y];
        if (
          (te === void 0 &&
            (Y === "instanceMatrix" &&
              G.instanceMatrix &&
              (te = G.instanceMatrix),
            Y === "instanceColor" && G.instanceColor && (te = G.instanceColor)),
          te !== void 0)
        ) {
          const ve = te.normalized,
            be = te.itemSize,
            Ae = t.get(te);
          if (Ae === void 0) continue;
          const Fe = Ae.buffer,
            Pe = Ae.type,
            Te = Ae.bytesPerElement,
            ze =
              r.isWebGL2 === !0 &&
              (Pe === n.INT || Pe === n.UNSIGNED_INT || te.gpuType === Dp);
          if (te.isInterleavedBufferAttribute) {
            const Ee = te.data,
              H = Ee.stride,
              we = te.offset;
            if (Ee.isInstancedInterleavedBuffer) {
              for (let he = 0; he < W.locationSize; he++)
                E(W.location + he, Ee.meshPerAttribute);
              G.isInstancedMesh !== !0 &&
                k._maxInstanceCount === void 0 &&
                (k._maxInstanceCount = Ee.meshPerAttribute * Ee.count);
            } else
              for (let he = 0; he < W.locationSize; he++) y(W.location + he);
            n.bindBuffer(n.ARRAY_BUFFER, Fe);
            for (let he = 0; he < W.locationSize; he++)
              T(
                W.location + he,
                be / W.locationSize,
                Pe,
                ve,
                H * Te,
                (we + (be / W.locationSize) * he) * Te,
                ze
              );
          } else {
            if (te.isInstancedBufferAttribute) {
              for (let Ee = 0; Ee < W.locationSize; Ee++)
                E(W.location + Ee, te.meshPerAttribute);
              G.isInstancedMesh !== !0 &&
                k._maxInstanceCount === void 0 &&
                (k._maxInstanceCount = te.meshPerAttribute * te.count);
            } else
              for (let Ee = 0; Ee < W.locationSize; Ee++) y(W.location + Ee);
            n.bindBuffer(n.ARRAY_BUFFER, Fe);
            for (let Ee = 0; Ee < W.locationSize; Ee++)
              T(
                W.location + Ee,
                be / W.locationSize,
                Pe,
                ve,
                be * Te,
                (be / W.locationSize) * Ee * Te,
                ze
              );
          }
        } else if (ne !== void 0) {
          const ve = ne[Y];
          if (ve !== void 0)
            switch (ve.length) {
              case 2:
                n.vertexAttrib2fv(W.location, ve);
                break;
              case 3:
                n.vertexAttrib3fv(W.location, ve);
                break;
              case 4:
                n.vertexAttrib4fv(W.location, ve);
                break;
              default:
                n.vertexAttrib1fv(W.location, ve);
            }
        }
      }
    }
    M();
  }
  function A() {
    $();
    for (const G in o) {
      const L = o[G];
      for (const C in L) {
        const k = L[C];
        for (const Z in k) g(k[Z].object), delete k[Z];
        delete L[C];
      }
      delete o[G];
    }
  }
  function D(G) {
    if (o[G.id] === void 0) return;
    const L = o[G.id];
    for (const C in L) {
      const k = L[C];
      for (const Z in k) g(k[Z].object), delete k[Z];
      delete L[C];
    }
    delete o[G.id];
  }
  function z(G) {
    for (const L in o) {
      const C = o[L];
      if (C[G.id] === void 0) continue;
      const k = C[G.id];
      for (const Z in k) g(k[Z].object), delete k[Z];
      delete C[G.id];
    }
  }
  function $() {
    I(), (l = !0), u !== c && ((u = c), d(u.object));
  }
  function I() {
    (c.geometry = null), (c.program = null), (c.wireframe = !1);
  }
  return {
    setup: f,
    reset: $,
    resetDefaultState: I,
    dispose: A,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: z,
    initAttributes: v,
    enableAttribute: y,
    disableUnusedAttributes: M,
  };
}
function fb(n, e, t, r) {
  const i = r.isWebGL2;
  let a;
  function s(u) {
    a = u;
  }
  function o(u, l) {
    n.drawArrays(a, u, l), t.update(l, a, 1);
  }
  function c(u, l, f) {
    if (f === 0) return;
    let h, d;
    if (i) (h = n), (d = "drawArraysInstanced");
    else if (
      ((h = e.get("ANGLE_instanced_arrays")),
      (d = "drawArraysInstancedANGLE"),
      h === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    h[d](a, u, l, f), t.update(l, a, f);
  }
  (this.setMode = s), (this.render = o), (this.renderInstances = c);
}
function hb(n, e, t) {
  let r;
  function i() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const T = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function a(T) {
    if (T === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      T = "mediump";
    }
    return T === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const s =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const c = a(o);
  c !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      c,
      "instead."
    ),
    (o = c));
  const u = s || e.has("WEBGL_draw_buffers"),
    l = t.logarithmicDepthBuffer === !0,
    f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    h = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    d = n.getParameter(n.MAX_TEXTURE_SIZE),
    g = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    m = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    p = n.getParameter(n.MAX_VARYING_VECTORS),
    S = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    v = h > 0,
    y = s || e.has("OES_texture_float"),
    E = v && y,
    M = s ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: s,
    drawBuffers: u,
    getMaxAnisotropy: i,
    getMaxPrecision: a,
    precision: o,
    logarithmicDepthBuffer: l,
    maxTextures: f,
    maxVertexTextures: h,
    maxTextureSize: d,
    maxCubemapSize: g,
    maxAttributes: x,
    maxVertexUniforms: m,
    maxVaryings: p,
    maxFragmentUniforms: S,
    vertexTextures: v,
    floatFragmentTextures: y,
    floatVertexTextures: E,
    maxSamples: M,
  };
}
function db(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    a = !1;
  const s = new br(),
    o = new Je(),
    c = { value: null, needsUpdate: !1 };
  (this.uniform = c),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (f, h) {
      const d = f.length !== 0 || h || r !== 0 || i;
      return (i = h), (r = f.length), d;
    }),
    (this.beginShadows = function () {
      (a = !0), l(null);
    }),
    (this.endShadows = function () {
      a = !1;
    }),
    (this.setGlobalState = function (f, h) {
      t = l(f, h, 0);
    }),
    (this.setState = function (f, h, d) {
      const g = f.clippingPlanes,
        x = f.clipIntersection,
        m = f.clipShadows,
        p = n.get(f);
      if (!i || g === null || g.length === 0 || (a && !m)) a ? l(null) : u();
      else {
        const S = a ? 0 : r,
          v = S * 4;
        let y = p.clippingState || null;
        (c.value = y), (y = l(g, h, v, d));
        for (let E = 0; E !== v; ++E) y[E] = t[E];
        (p.clippingState = y),
          (this.numIntersection = x ? this.numPlanes : 0),
          (this.numPlanes += S);
      }
    });
  function u() {
    c.value !== t && ((c.value = t), (c.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function l(f, h, d, g) {
    const x = f !== null ? f.length : 0;
    let m = null;
    if (x !== 0) {
      if (((m = c.value), g !== !0 || m === null)) {
        const p = d + x * 4,
          S = h.matrixWorldInverse;
        o.getNormalMatrix(S),
          (m === null || m.length < p) && (m = new Float32Array(p));
        for (let v = 0, y = d; v !== x; ++v, y += 4)
          s.copy(f[v]).applyMatrix4(S, o),
            s.normal.toArray(m, y),
            (m[y + 3] = s.constant);
      }
      (c.value = m), (c.needsUpdate = !0);
    }
    return (e.numPlanes = x), (e.numIntersection = 0), m;
  }
}
function pb(n) {
  let e = new WeakMap();
  function t(s, o) {
    return o === Mo ? (s.mapping = sa) : o === cc && (s.mapping = oa), s;
  }
  function r(s) {
    if (s && s.isTexture && s.isRenderTargetTexture === !1) {
      const o = s.mapping;
      if (o === Mo || o === cc)
        if (e.has(s)) {
          const c = e.get(s).texture;
          return t(c, s.mapping);
        } else {
          const c = s.image;
          if (c && c.height > 0) {
            const u = new Ty(c.height / 2);
            return (
              u.fromEquirectangularTexture(n, s),
              e.set(s, u),
              s.addEventListener("dispose", i),
              t(u.texture, s.mapping)
            );
          } else return null;
        }
    }
    return s;
  }
  function i(s) {
    const o = s.target;
    o.removeEventListener("dispose", i);
    const c = e.get(o);
    c !== void 0 && (e.delete(o), c.dispose());
  }
  function a() {
    e = new WeakMap();
  }
  return { get: r, dispose: a };
}
class qp extends Gp {
  constructor(e = -1, t = 1, r = 1, i = -1, a = 0.1, s = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = a),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, a, s) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = a),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let a = r - e,
      s = r + e,
      o = i + t,
      c = i - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (a += u * this.view.offsetX),
        (s = a + u * this.view.width),
        (o -= l * this.view.offsetY),
        (c = o - l * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      a,
      s,
      o,
      c,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const $i = 4,
  Mf = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Yr = 20,
  zu = new qp(),
  Af = new tt();
let ku = null;
const jr = (1 + Math.sqrt(5)) / 2,
  Ui = 1 / jr,
  Df = [
    new B(1, 1, 1),
    new B(-1, 1, 1),
    new B(1, 1, -1),
    new B(-1, 1, -1),
    new B(0, jr, Ui),
    new B(0, jr, -Ui),
    new B(Ui, 0, jr),
    new B(-Ui, 0, jr),
    new B(jr, Ui, 0),
    new B(-jr, Ui, 0),
  ];
class Tf {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    (ku = this._renderer.getRenderTarget()), this._setSize(256);
    const a = this._allocateTargets();
    return (
      (a.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, a),
      t > 0 && this._blur(a, 0, 0, t),
      this._applyPMREM(a),
      this._cleanup(a),
      a
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Rf()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Nf()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(ku),
      (e.scissorTest = !1),
      Ws(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === sa || e.mapping === oa
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (ku = this._renderer.getRenderTarget());
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: wn,
        minFilter: wn,
        generateMipmaps: !1,
        type: ts,
        format: Ln,
        colorSpace: Gn,
        depthBuffer: !1,
      },
      i = Cf(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Cf(e, t, r));
      const { _lodMax: a } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = mb(a)),
        (this._blurMaterial = gb(a, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Re(this._lodPlanes[0], e);
    this._renderer.compile(t, zu);
  }
  _sceneToCubeUV(e, t, r, i) {
    const o = new an(90, 1, t, r),
      c = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      l = this._renderer,
      f = l.autoClear,
      h = l.toneMapping;
    l.getClearColor(Af), (l.toneMapping = Cr), (l.autoClear = !1);
    const d = new Vn({
        name: "PMREM.Background",
        side: en,
        depthWrite: !1,
        depthTest: !1,
      }),
      g = new Re(new mt(), d);
    let x = !1;
    const m = e.background;
    m
      ? m.isColor && (d.color.copy(m), (e.background = null), (x = !0))
      : (d.color.copy(Af), (x = !0));
    for (let p = 0; p < 6; p++) {
      const S = p % 3;
      S === 0
        ? (o.up.set(0, c[p], 0), o.lookAt(u[p], 0, 0))
        : S === 1
        ? (o.up.set(0, 0, c[p]), o.lookAt(0, u[p], 0))
        : (o.up.set(0, c[p], 0), o.lookAt(0, 0, u[p]));
      const v = this._cubeSize;
      Ws(i, S * v, p > 2 ? v : 0, v, v),
        l.setRenderTarget(i),
        x && l.render(g, o),
        l.render(e, o);
    }
    g.geometry.dispose(),
      g.material.dispose(),
      (l.toneMapping = h),
      (l.autoClear = f),
      (e.background = m);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === sa || e.mapping === oa;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Rf()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Nf());
    const a = i ? this._cubemapMaterial : this._equirectMaterial,
      s = new Re(this._lodPlanes[0], a),
      o = a.uniforms;
    o.envMap.value = e;
    const c = this._cubeSize;
    Ws(t, 0, 0, 3 * c, 2 * c), r.setRenderTarget(t), r.render(s, zu);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const a = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        s = Df[(i - 1) % Df.length];
      this._blur(e, i - 1, i, a, s);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, a) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(e, s, t, r, i, "latitudinal", a),
      this._halfBlur(s, e, r, r, i, "longitudinal", a);
  }
  _halfBlur(e, t, r, i, a, s, o) {
    const c = this._renderer,
      u = this._blurMaterial;
    s !== "latitudinal" &&
      s !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const l = 3,
      f = new Re(this._lodPlanes[i], u),
      h = u.uniforms,
      d = this._sizeLods[r] - 1,
      g = isFinite(a) ? Math.PI / (2 * d) : (2 * Math.PI) / (2 * Yr - 1),
      x = a / g,
      m = isFinite(a) ? 1 + Math.floor(l * x) : Yr;
    m > Yr &&
      console.warn(
        `sigmaRadians, ${a}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Yr}`
      );
    const p = [];
    let S = 0;
    for (let T = 0; T < Yr; ++T) {
      const N = T / x,
        A = Math.exp((-N * N) / 2);
      p.push(A), T === 0 ? (S += A) : T < m && (S += 2 * A);
    }
    for (let T = 0; T < p.length; T++) p[T] = p[T] / S;
    (h.envMap.value = e.texture),
      (h.samples.value = m),
      (h.weights.value = p),
      (h.latitudinal.value = s === "latitudinal"),
      o && (h.poleAxis.value = o);
    const { _lodMax: v } = this;
    (h.dTheta.value = g), (h.mipInt.value = v - r);
    const y = this._sizeLods[i],
      E = 3 * y * (i > v - $i ? i - v + $i : 0),
      M = 4 * (this._cubeSize - y);
    Ws(t, E, M, 3 * y, 2 * y), c.setRenderTarget(t), c.render(f, zu);
  }
}
function mb(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const a = n - $i + 1 + Mf.length;
  for (let s = 0; s < a; s++) {
    const o = Math.pow(2, i);
    t.push(o);
    let c = 1 / o;
    s > n - $i ? (c = Mf[s - n + $i - 1]) : s === 0 && (c = 0), r.push(c);
    const u = 1 / (o - 2),
      l = -u,
      f = 1 + u,
      h = [l, l, f, l, f, f, l, l, f, f, l, f],
      d = 6,
      g = 6,
      x = 3,
      m = 2,
      p = 1,
      S = new Float32Array(x * g * d),
      v = new Float32Array(m * g * d),
      y = new Float32Array(p * g * d);
    for (let M = 0; M < d; M++) {
      const T = ((M % 3) * 2) / 3 - 1,
        N = M > 2 ? 0 : -1,
        A = [
          T,
          N,
          0,
          T + 2 / 3,
          N,
          0,
          T + 2 / 3,
          N + 1,
          0,
          T,
          N,
          0,
          T + 2 / 3,
          N + 1,
          0,
          T,
          N + 1,
          0,
        ];
      S.set(A, x * g * M), v.set(h, m * g * M);
      const D = [M, M, M, M, M, M];
      y.set(D, p * g * M);
    }
    const E = new wt();
    E.setAttribute("position", new gn(S, x)),
      E.setAttribute("uv", new gn(v, m)),
      E.setAttribute("faceIndex", new gn(y, p)),
      e.push(E),
      i > $i && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function Cf(n, e, t) {
  const r = new ri(n, e, t);
  return (
    (r.texture.mapping = Ho),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function Ws(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function gb(n, e, t) {
  const r = new Float32Array(Yr),
    i = new B(0, 1, 0);
  return new ii({
    name: "SphericalGaussianBlur",
    defines: {
      n: Yr,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Gc(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Tr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Nf() {
  return new ii({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Gc(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Tr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Rf() {
  return new ii({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Gc(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Tr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Gc() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function vb(n) {
  let e = new WeakMap(),
    t = null;
  function r(o) {
    if (o && o.isTexture) {
      const c = o.mapping,
        u = c === Mo || c === cc,
        l = c === sa || c === oa;
      if (u || l)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let f = e.get(o);
          return (
            t === null && (t = new Tf(n)),
            (f = u ? t.fromEquirectangular(o, f) : t.fromCubemap(o, f)),
            e.set(o, f),
            f.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const f = o.image;
            if ((u && f && f.height > 0) || (l && f && i(f))) {
              t === null && (t = new Tf(n));
              const h = u ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, h), o.addEventListener("dispose", a), h.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function i(o) {
    let c = 0;
    const u = 6;
    for (let l = 0; l < u; l++) o[l] !== void 0 && c++;
    return c === u;
  }
  function a(o) {
    const c = o.target;
    c.removeEventListener("dispose", a);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function s() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: s };
}
function yb(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function (r) {
      r.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        i
      );
    },
  };
}
function xb(n, e, t, r) {
  const i = {},
    a = new WeakMap();
  function s(f) {
    const h = f.target;
    h.index !== null && e.remove(h.index);
    for (const g in h.attributes) e.remove(h.attributes[g]);
    for (const g in h.morphAttributes) {
      const x = h.morphAttributes[g];
      for (let m = 0, p = x.length; m < p; m++) e.remove(x[m]);
    }
    h.removeEventListener("dispose", s), delete i[h.id];
    const d = a.get(h);
    d && (e.remove(d), a.delete(h)),
      r.releaseStatesOfGeometry(h),
      h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
      t.memory.geometries--;
  }
  function o(f, h) {
    return (
      i[h.id] === !0 ||
        (h.addEventListener("dispose", s),
        (i[h.id] = !0),
        t.memory.geometries++),
      h
    );
  }
  function c(f) {
    const h = f.attributes;
    for (const g in h) e.update(h[g], n.ARRAY_BUFFER);
    const d = f.morphAttributes;
    for (const g in d) {
      const x = d[g];
      for (let m = 0, p = x.length; m < p; m++) e.update(x[m], n.ARRAY_BUFFER);
    }
  }
  function u(f) {
    const h = [],
      d = f.index,
      g = f.attributes.position;
    let x = 0;
    if (d !== null) {
      const S = d.array;
      x = d.version;
      for (let v = 0, y = S.length; v < y; v += 3) {
        const E = S[v + 0],
          M = S[v + 1],
          T = S[v + 2];
        h.push(E, M, M, T, T, E);
      }
    } else if (g !== void 0) {
      const S = g.array;
      x = g.version;
      for (let v = 0, y = S.length / 3 - 1; v < y; v += 3) {
        const E = v + 0,
          M = v + 1,
          T = v + 2;
        h.push(E, M, M, T, T, E);
      }
    } else return;
    const m = new (Lp(h) ? kp : zp)(h, 1);
    m.version = x;
    const p = a.get(f);
    p && e.remove(p), a.set(f, m);
  }
  function l(f) {
    const h = a.get(f);
    if (h) {
      const d = f.index;
      d !== null && h.version < d.version && u(f);
    } else u(f);
    return a.get(f);
  }
  return { get: o, update: c, getWireframeAttribute: l };
}
function bb(n, e, t, r) {
  const i = r.isWebGL2;
  let a;
  function s(h) {
    a = h;
  }
  let o, c;
  function u(h) {
    (o = h.type), (c = h.bytesPerElement);
  }
  function l(h, d) {
    n.drawElements(a, d, o, h * c), t.update(d, a, 1);
  }
  function f(h, d, g) {
    if (g === 0) return;
    let x, m;
    if (i) (x = n), (m = "drawElementsInstanced");
    else if (
      ((x = e.get("ANGLE_instanced_arrays")),
      (m = "drawElementsInstancedANGLE"),
      x === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    x[m](a, d, o, h * c, g), t.update(d, a, g);
  }
  (this.setMode = s),
    (this.setIndex = u),
    (this.render = l),
    (this.renderInstances = f);
}
function _b(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(a, s, o) {
    switch ((t.calls++, s)) {
      case n.TRIANGLES:
        t.triangles += o * (a / 3);
        break;
      case n.LINES:
        t.lines += o * (a / 2);
        break;
      case n.LINE_STRIP:
        t.lines += o * (a - 1);
        break;
      case n.LINE_LOOP:
        t.lines += o * a;
        break;
      case n.POINTS:
        t.points += o * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function wb(n, e) {
  return n[0] - e[0];
}
function Eb(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function Sb(n, e, t) {
  const r = {},
    i = new Float32Array(8),
    a = new WeakMap(),
    s = new xt(),
    o = [];
  for (let u = 0; u < 8; u++) o[u] = [u, 0];
  function c(u, l, f) {
    const h = u.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const g =
          l.morphAttributes.position ||
          l.morphAttributes.normal ||
          l.morphAttributes.color,
        x = g !== void 0 ? g.length : 0;
      let m = a.get(l);
      if (m === void 0 || m.count !== x) {
        let L = function () {
          I.dispose(), a.delete(l), l.removeEventListener("dispose", L);
        };
        var d = L;
        m !== void 0 && m.texture.dispose();
        const v = l.morphAttributes.position !== void 0,
          y = l.morphAttributes.normal !== void 0,
          E = l.morphAttributes.color !== void 0,
          M = l.morphAttributes.position || [],
          T = l.morphAttributes.normal || [],
          N = l.morphAttributes.color || [];
        let A = 0;
        v === !0 && (A = 1), y === !0 && (A = 2), E === !0 && (A = 3);
        let D = l.attributes.position.count * A,
          z = 1;
        D > e.maxTextureSize &&
          ((z = Math.ceil(D / e.maxTextureSize)), (D = e.maxTextureSize));
        const $ = new Float32Array(D * z * 4 * x),
          I = new Up($, D, z, x);
        (I.type = Sr), (I.needsUpdate = !0);
        const G = A * 4;
        for (let C = 0; C < x; C++) {
          const k = M[C],
            Z = T[C],
            ie = N[C],
            ne = D * z * 4 * C;
          for (let Y = 0; Y < k.count; Y++) {
            const W = Y * G;
            v === !0 &&
              (s.fromBufferAttribute(k, Y),
              ($[ne + W + 0] = s.x),
              ($[ne + W + 1] = s.y),
              ($[ne + W + 2] = s.z),
              ($[ne + W + 3] = 0)),
              y === !0 &&
                (s.fromBufferAttribute(Z, Y),
                ($[ne + W + 4] = s.x),
                ($[ne + W + 5] = s.y),
                ($[ne + W + 6] = s.z),
                ($[ne + W + 7] = 0)),
              E === !0 &&
                (s.fromBufferAttribute(ie, Y),
                ($[ne + W + 8] = s.x),
                ($[ne + W + 9] = s.y),
                ($[ne + W + 10] = s.z),
                ($[ne + W + 11] = ie.itemSize === 4 ? s.w : 1));
          }
        }
        (m = { count: x, texture: I, size: new De(D, z) }),
          a.set(l, m),
          l.addEventListener("dispose", L);
      }
      let p = 0;
      for (let v = 0; v < h.length; v++) p += h[v];
      const S = l.morphTargetsRelative ? 1 : 1 - p;
      f.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        f.getUniforms().setValue(n, "morphTargetInfluences", h),
        f.getUniforms().setValue(n, "morphTargetsTexture", m.texture, t),
        f.getUniforms().setValue(n, "morphTargetsTextureSize", m.size);
    } else {
      const g = h === void 0 ? 0 : h.length;
      let x = r[l.id];
      if (x === void 0 || x.length !== g) {
        x = [];
        for (let y = 0; y < g; y++) x[y] = [y, 0];
        r[l.id] = x;
      }
      for (let y = 0; y < g; y++) {
        const E = x[y];
        (E[0] = y), (E[1] = h[y]);
      }
      x.sort(Eb);
      for (let y = 0; y < 8; y++)
        y < g && x[y][1]
          ? ((o[y][0] = x[y][0]), (o[y][1] = x[y][1]))
          : ((o[y][0] = Number.MAX_SAFE_INTEGER), (o[y][1] = 0));
      o.sort(wb);
      const m = l.morphAttributes.position,
        p = l.morphAttributes.normal;
      let S = 0;
      for (let y = 0; y < 8; y++) {
        const E = o[y],
          M = E[0],
          T = E[1];
        M !== Number.MAX_SAFE_INTEGER && T
          ? (m &&
              l.getAttribute("morphTarget" + y) !== m[M] &&
              l.setAttribute("morphTarget" + y, m[M]),
            p &&
              l.getAttribute("morphNormal" + y) !== p[M] &&
              l.setAttribute("morphNormal" + y, p[M]),
            (i[y] = T),
            (S += T))
          : (m &&
              l.hasAttribute("morphTarget" + y) === !0 &&
              l.deleteAttribute("morphTarget" + y),
            p &&
              l.hasAttribute("morphNormal" + y) === !0 &&
              l.deleteAttribute("morphNormal" + y),
            (i[y] = 0));
      }
      const v = l.morphTargetsRelative ? 1 : 1 - S;
      f.getUniforms().setValue(n, "morphTargetBaseInfluence", v),
        f.getUniforms().setValue(n, "morphTargetInfluences", i);
    }
  }
  return { update: c };
}
function Mb(n, e, t, r) {
  let i = new WeakMap();
  function a(c) {
    const u = r.render.frame,
      l = c.geometry,
      f = e.get(c, l);
    if (
      (i.get(f) !== u && (e.update(f), i.set(f, u)),
      c.isInstancedMesh &&
        (c.hasEventListener("dispose", o) === !1 &&
          c.addEventListener("dispose", o),
        i.get(c) !== u &&
          (t.update(c.instanceMatrix, n.ARRAY_BUFFER),
          c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER),
          i.set(c, u))),
      c.isSkinnedMesh)
    ) {
      const h = c.skeleton;
      i.get(h) !== u && (h.update(), i.set(h, u));
    }
    return f;
  }
  function s() {
    i = new WeakMap();
  }
  function o(c) {
    const u = c.target;
    u.removeEventListener("dispose", o),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return { update: a, dispose: s };
}
const $p = new sn(),
  jp = new Up(),
  Xp = new fy(),
  Yp = new Vp(),
  Ff = [],
  Pf = [],
  Lf = new Float32Array(16),
  If = new Float32Array(9),
  Of = new Float32Array(4);
function va(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let a = Ff[i];
  if ((a === void 0 && ((a = new Float32Array(i)), (Ff[i] = a)), e !== 0)) {
    r.toArray(a, 0);
    for (let s = 1, o = 0; s !== e; ++s) (o += t), n[s].toArray(a, o);
  }
  return a;
}
function Ft(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Pt(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function Wo(n, e) {
  let t = Pf[e];
  t === void 0 && ((t = new Int32Array(e)), (Pf[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function Ab(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function Db(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Ft(t, e)) return;
    n.uniform2fv(this.addr, e), Pt(t, e);
  }
}
function Tb(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Ft(t, e)) return;
    n.uniform3fv(this.addr, e), Pt(t, e);
  }
}
function Cb(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Ft(t, e)) return;
    n.uniform4fv(this.addr, e), Pt(t, e);
  }
}
function Nb(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Ft(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Pt(t, e);
  } else {
    if (Ft(t, r)) return;
    Of.set(r), n.uniformMatrix2fv(this.addr, !1, Of), Pt(t, r);
  }
}
function Rb(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Ft(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Pt(t, e);
  } else {
    if (Ft(t, r)) return;
    If.set(r), n.uniformMatrix3fv(this.addr, !1, If), Pt(t, r);
  }
}
function Fb(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Ft(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Pt(t, e);
  } else {
    if (Ft(t, r)) return;
    Lf.set(r), n.uniformMatrix4fv(this.addr, !1, Lf), Pt(t, r);
  }
}
function Pb(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function Lb(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Ft(t, e)) return;
    n.uniform2iv(this.addr, e), Pt(t, e);
  }
}
function Ib(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Ft(t, e)) return;
    n.uniform3iv(this.addr, e), Pt(t, e);
  }
}
function Ob(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Ft(t, e)) return;
    n.uniform4iv(this.addr, e), Pt(t, e);
  }
}
function Ub(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function Bb(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Ft(t, e)) return;
    n.uniform2uiv(this.addr, e), Pt(t, e);
  }
}
function zb(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Ft(t, e)) return;
    n.uniform3uiv(this.addr, e), Pt(t, e);
  }
}
function kb(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Ft(t, e)) return;
    n.uniform4uiv(this.addr, e), Pt(t, e);
  }
}
function Hb(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2D(e || $p, i);
}
function Gb(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || Xp, i);
}
function Vb(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || Yp, i);
}
function Wb(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || jp, i);
}
function qb(n) {
  switch (n) {
    case 5126:
      return Ab;
    case 35664:
      return Db;
    case 35665:
      return Tb;
    case 35666:
      return Cb;
    case 35674:
      return Nb;
    case 35675:
      return Rb;
    case 35676:
      return Fb;
    case 5124:
    case 35670:
      return Pb;
    case 35667:
    case 35671:
      return Lb;
    case 35668:
    case 35672:
      return Ib;
    case 35669:
    case 35673:
      return Ob;
    case 5125:
      return Ub;
    case 36294:
      return Bb;
    case 36295:
      return zb;
    case 36296:
      return kb;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Hb;
    case 35679:
    case 36299:
    case 36307:
      return Gb;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Vb;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Wb;
  }
}
function $b(n, e) {
  n.uniform1fv(this.addr, e);
}
function jb(n, e) {
  const t = va(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Xb(n, e) {
  const t = va(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Yb(n, e) {
  const t = va(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function Zb(n, e) {
  const t = va(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Jb(n, e) {
  const t = va(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function Kb(n, e) {
  const t = va(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function Qb(n, e) {
  n.uniform1iv(this.addr, e);
}
function e_(n, e) {
  n.uniform2iv(this.addr, e);
}
function t_(n, e) {
  n.uniform3iv(this.addr, e);
}
function n_(n, e) {
  n.uniform4iv(this.addr, e);
}
function r_(n, e) {
  n.uniform1uiv(this.addr, e);
}
function i_(n, e) {
  n.uniform2uiv(this.addr, e);
}
function a_(n, e) {
  n.uniform3uiv(this.addr, e);
}
function s_(n, e) {
  n.uniform4uiv(this.addr, e);
}
function o_(n, e, t) {
  const r = this.cache,
    i = e.length,
    a = Wo(t, i);
  Ft(r, a) || (n.uniform1iv(this.addr, a), Pt(r, a));
  for (let s = 0; s !== i; ++s) t.setTexture2D(e[s] || $p, a[s]);
}
function u_(n, e, t) {
  const r = this.cache,
    i = e.length,
    a = Wo(t, i);
  Ft(r, a) || (n.uniform1iv(this.addr, a), Pt(r, a));
  for (let s = 0; s !== i; ++s) t.setTexture3D(e[s] || Xp, a[s]);
}
function c_(n, e, t) {
  const r = this.cache,
    i = e.length,
    a = Wo(t, i);
  Ft(r, a) || (n.uniform1iv(this.addr, a), Pt(r, a));
  for (let s = 0; s !== i; ++s) t.setTextureCube(e[s] || Yp, a[s]);
}
function l_(n, e, t) {
  const r = this.cache,
    i = e.length,
    a = Wo(t, i);
  Ft(r, a) || (n.uniform1iv(this.addr, a), Pt(r, a));
  for (let s = 0; s !== i; ++s) t.setTexture2DArray(e[s] || jp, a[s]);
}
function f_(n) {
  switch (n) {
    case 5126:
      return $b;
    case 35664:
      return jb;
    case 35665:
      return Xb;
    case 35666:
      return Yb;
    case 35674:
      return Zb;
    case 35675:
      return Jb;
    case 35676:
      return Kb;
    case 5124:
    case 35670:
      return Qb;
    case 35667:
    case 35671:
      return e_;
    case 35668:
    case 35672:
      return t_;
    case 35669:
    case 35673:
      return n_;
    case 5125:
      return r_;
    case 36294:
      return i_;
    case 36295:
      return a_;
    case 36296:
      return s_;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return o_;
    case 35679:
    case 36299:
    case 36307:
      return u_;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return c_;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return l_;
  }
}
class h_ {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.setValue = qb(t.type));
  }
}
class d_ {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = f_(t.type));
  }
}
class p_ {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let a = 0, s = i.length; a !== s; ++a) {
      const o = i[a];
      o.setValue(e, t[o.id], r);
    }
  }
}
const Hu = /(\w+)(\])?(\[|\.)?/g;
function Uf(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function m_(n, e, t) {
  const r = n.name,
    i = r.length;
  for (Hu.lastIndex = 0; ; ) {
    const a = Hu.exec(r),
      s = Hu.lastIndex;
    let o = a[1];
    const c = a[2] === "]",
      u = a[3];
    if ((c && (o = o | 0), u === void 0 || (u === "[" && s + 2 === i))) {
      Uf(t, u === void 0 ? new h_(o, n, e) : new d_(o, n, e));
      break;
    } else {
      let f = t.map[o];
      f === void 0 && ((f = new p_(o)), Uf(t, f)), (t = f);
    }
  }
}
class bo {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const a = e.getActiveUniform(t, i),
        s = e.getUniformLocation(t, a.name);
      m_(a, s, this);
    }
  }
  setValue(e, t, r, i) {
    const a = this.map[t];
    a !== void 0 && a.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let a = 0, s = t.length; a !== s; ++a) {
      const o = t[a],
        c = r[o.id];
      c.needsUpdate !== !1 && o.setValue(e, c.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, a = e.length; i !== a; ++i) {
      const s = e[i];
      s.id in t && r.push(s);
    }
    return r;
  }
}
function Bf(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
let g_ = 0;
function v_(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    a = Math.min(e + 6, t.length);
  for (let s = i; s < a; s++) {
    const o = s + 1;
    r.push(`${o === e ? ">" : " "} ${o}: ${t[s]}`);
  }
  return r.join(`
`);
}
function y_(n) {
  switch (n) {
    case Gn:
      return ["Linear", "( value )"];
    case gt:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        ["Linear", "( value )"]
      );
  }
}
function zf(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(i);
  if (a) {
    const s = parseInt(a[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      v_(n.getShaderSource(e), s)
    );
  } else return i;
}
function x_(n, e) {
  const t = y_(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function b_(n, e) {
  let t;
  switch (e) {
    case pv:
      t = "Linear";
      break;
    case mv:
      t = "Reinhard";
      break;
    case gv:
      t = "OptimizedCineon";
      break;
    case vv:
      t = "ACESFilmic";
      break;
    case yv:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function __(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(za).join(`
`);
}
function w_(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function E_(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const a = n.getActiveAttrib(e, i),
      s = a.name;
    let o = 1;
    a.type === n.FLOAT_MAT2 && (o = 2),
      a.type === n.FLOAT_MAT3 && (o = 3),
      a.type === n.FLOAT_MAT4 && (o = 4),
      (t[s] = {
        type: a.type,
        location: n.getAttribLocation(e, s),
        locationSize: o,
      });
  }
  return t;
}
function za(n) {
  return n !== "";
}
function kf(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Hf(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const S_ = /^[ \t]*#include +<([\w\d./]+)>/gm;
function pc(n) {
  return n.replace(S_, A_);
}
const M_ = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function A_(n, e) {
  let t = Ze[e];
  if (t === void 0) {
    const r = M_.get(e);
    if (r !== void 0)
      (t = Ze[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return pc(t);
}
const D_ =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Gf(n) {
  return n.replace(D_, T_);
}
function T_(n, e, t, r) {
  let i = "";
  for (let a = parseInt(e); a < parseInt(t); a++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + a + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, a);
  return i;
}
function Vf(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function C_(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Ep
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === $0
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === rr && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function N_(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case sa:
      case oa:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Ho:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function R_(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case oa:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function F_(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Oc:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case hv:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case dv:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function P_(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function L_(n, e, t, r) {
  const i = n.getContext(),
    a = t.defines;
  let s = t.vertexShader,
    o = t.fragmentShader;
  const c = C_(t),
    u = N_(t),
    l = R_(t),
    f = F_(t),
    h = P_(t),
    d = t.isWebGL2 ? "" : __(t),
    g = w_(a),
    x = i.createProgram();
  let m,
    p,
    S = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((m = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
      ].filter(za).join(`
`)),
      m.length > 0 &&
        (m += `
`),
      (p = [
        d,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
      ].filter(za).join(`
`)),
      p.length > 0 &&
        (p += `
`))
    : ((m = [
        Vf(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + l : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + c : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(za).join(`
`)),
      (p = [
        d,
        Vf(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + l : "",
        t.envMap ? "#define " + f : "",
        h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
        h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
        h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + c : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Cr ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Cr ? Ze.tonemapping_pars_fragment : "",
        t.toneMapping !== Cr ? b_("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Ze.colorspace_pars_fragment,
        x_("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(za).join(`
`))),
    (s = pc(s)),
    (s = kf(s, t)),
    (s = Hf(s, t)),
    (o = pc(o)),
    (o = kf(o, t)),
    (o = Hf(o, t)),
    (s = Gf(s)),
    (o = Gf(o)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((S = `#version 300 es
`),
      (m =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        m),
      (p =
        [
          "#define varying in",
          t.glslVersion === cf
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === cf ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        p));
  const v = S + m + s,
    y = S + p + o,
    E = Bf(i, i.VERTEX_SHADER, v),
    M = Bf(i, i.FRAGMENT_SHADER, y);
  if (
    (i.attachShader(x, E),
    i.attachShader(x, M),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(x, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"),
    i.linkProgram(x),
    n.debug.checkShaderErrors)
  ) {
    const A = i.getProgramInfoLog(x).trim(),
      D = i.getShaderInfoLog(E).trim(),
      z = i.getShaderInfoLog(M).trim();
    let $ = !0,
      I = !0;
    if (i.getProgramParameter(x, i.LINK_STATUS) === !1)
      if ((($ = !1), typeof n.debug.onShaderError == "function"))
        n.debug.onShaderError(i, x, E, M);
      else {
        const G = zf(i, E, "vertex"),
          L = zf(i, M, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            i.getError() +
            " - VALIDATE_STATUS " +
            i.getProgramParameter(x, i.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            A +
            `
` +
            G +
            `
` +
            L
        );
      }
    else
      A !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", A)
        : (D === "" || z === "") && (I = !1);
    I &&
      (this.diagnostics = {
        runnable: $,
        programLog: A,
        vertexShader: { log: D, prefix: m },
        fragmentShader: { log: z, prefix: p },
      });
  }
  i.deleteShader(E), i.deleteShader(M);
  let T;
  this.getUniforms = function () {
    return T === void 0 && (T = new bo(i, x)), T;
  };
  let N;
  return (
    (this.getAttributes = function () {
      return N === void 0 && (N = E_(i, x)), N;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(x),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = g_++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = x),
    (this.vertexShader = E),
    (this.fragmentShader = M),
    this
  );
}
let I_ = 0;
class O_ {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      a = this._getShaderStage(r),
      s = this._getShaderCacheForMaterial(e);
    return (
      s.has(i) === !1 && (s.add(i), i.usedTimes++),
      s.has(a) === !1 && (s.add(a), a.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new U_(e)), t.set(e, r)), r;
  }
}
class U_ {
  constructor(e) {
    (this.id = I_++), (this.code = e), (this.usedTimes = 0);
  }
}
function B_(n, e, t, r, i, a, s) {
  const o = new kc(),
    c = new O_(),
    u = [],
    l = i.isWebGL2,
    f = i.logarithmicDepthBuffer,
    h = i.vertexTextures;
  let d = i.precision;
  const g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function x(A) {
    return A === 0 ? "uv" : `uv${A}`;
  }
  function m(A, D, z, $, I) {
    const G = $.fog,
      L = I.geometry,
      C = A.isMeshStandardMaterial ? $.environment : null,
      k = (A.isMeshStandardMaterial ? t : e).get(A.envMap || C),
      Z = k && k.mapping === Ho ? k.image.height : null,
      ie = g[A.type];
    A.precision !== null &&
      ((d = i.getMaxPrecision(A.precision)),
      d !== A.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          A.precision,
          "not supported, using",
          d,
          "instead."
        ));
    const ne =
        L.morphAttributes.position ||
        L.morphAttributes.normal ||
        L.morphAttributes.color,
      Y = ne !== void 0 ? ne.length : 0;
    let W = 0;
    L.morphAttributes.position !== void 0 && (W = 1),
      L.morphAttributes.normal !== void 0 && (W = 2),
      L.morphAttributes.color !== void 0 && (W = 3);
    let te, ve, be, Ae;
    if (ie) {
      const lt = kn[ie];
      (te = lt.vertexShader), (ve = lt.fragmentShader);
    } else
      (te = A.vertexShader),
        (ve = A.fragmentShader),
        c.update(A),
        (be = c.getVertexShaderID(A)),
        (Ae = c.getFragmentShaderID(A));
    const Fe = n.getRenderTarget(),
      Pe = I.isInstancedMesh === !0,
      Te = !!A.map,
      ze = !!A.matcap,
      Ee = !!k,
      H = !!A.aoMap,
      we = !!A.lightMap,
      he = !!A.bumpMap,
      _e = !!A.normalMap,
      ge = !!A.displacementMap,
      Ue = !!A.emissiveMap,
      J = !!A.metalnessMap,
      Q = !!A.roughnessMap,
      ce = A.anisotropy > 0,
      Ce = A.clearcoat > 0,
      Ne = A.iridescence > 0,
      w = A.sheen > 0,
      b = A.transmission > 0,
      F = ce && !!A.anisotropyMap,
      V = Ce && !!A.clearcoatMap,
      j = Ce && !!A.clearcoatNormalMap,
      X = Ce && !!A.clearcoatRoughnessMap,
      oe = Ne && !!A.iridescenceMap,
      ee = Ne && !!A.iridescenceThicknessMap,
      q = w && !!A.sheenColorMap,
      P = w && !!A.sheenRoughnessMap,
      ue = !!A.specularMap,
      ye = !!A.specularColorMap,
      fe = !!A.specularIntensityMap,
      Me = b && !!A.transmissionMap,
      _ = b && !!A.thicknessMap,
      U = !!A.gradientMap,
      R = !!A.alphaMap,
      re = A.alphaTest > 0,
      K = !!A.alphaHash,
      le = !!A.extensions,
      Se = !!L.attributes.uv1,
      Ye = !!L.attributes.uv2,
      it = !!L.attributes.uv3;
    let ct = Cr;
    return (
      A.toneMapped &&
        (Fe === null || Fe.isXRRenderTarget === !0) &&
        (ct = n.toneMapping),
      {
        isWebGL2: l,
        shaderID: ie,
        shaderType: A.type,
        shaderName: A.name,
        vertexShader: te,
        fragmentShader: ve,
        defines: A.defines,
        customVertexShaderID: be,
        customFragmentShaderID: Ae,
        isRawShaderMaterial: A.isRawShaderMaterial === !0,
        glslVersion: A.glslVersion,
        precision: d,
        instancing: Pe,
        instancingColor: Pe && I.instanceColor !== null,
        supportsVertexTextures: h,
        outputColorSpace:
          Fe === null
            ? n.outputColorSpace
            : Fe.isXRRenderTarget === !0
            ? Fe.texture.colorSpace
            : Gn,
        map: Te,
        matcap: ze,
        envMap: Ee,
        envMapMode: Ee && k.mapping,
        envMapCubeUVHeight: Z,
        aoMap: H,
        lightMap: we,
        bumpMap: he,
        normalMap: _e,
        displacementMap: h && ge,
        emissiveMap: Ue,
        normalMapObjectSpace: _e && A.normalMapType === Rv,
        normalMapTangentSpace: _e && A.normalMapType === Bc,
        metalnessMap: J,
        roughnessMap: Q,
        anisotropy: ce,
        anisotropyMap: F,
        clearcoat: Ce,
        clearcoatMap: V,
        clearcoatNormalMap: j,
        clearcoatRoughnessMap: X,
        iridescence: Ne,
        iridescenceMap: oe,
        iridescenceThicknessMap: ee,
        sheen: w,
        sheenColorMap: q,
        sheenRoughnessMap: P,
        specularMap: ue,
        specularColorMap: ye,
        specularIntensityMap: fe,
        transmission: b,
        transmissionMap: Me,
        thicknessMap: _,
        gradientMap: U,
        opaque: A.transparent === !1 && A.blending === ea,
        alphaMap: R,
        alphaTest: re,
        alphaHash: K,
        combine: A.combine,
        mapUv: Te && x(A.map.channel),
        aoMapUv: H && x(A.aoMap.channel),
        lightMapUv: we && x(A.lightMap.channel),
        bumpMapUv: he && x(A.bumpMap.channel),
        normalMapUv: _e && x(A.normalMap.channel),
        displacementMapUv: ge && x(A.displacementMap.channel),
        emissiveMapUv: Ue && x(A.emissiveMap.channel),
        metalnessMapUv: J && x(A.metalnessMap.channel),
        roughnessMapUv: Q && x(A.roughnessMap.channel),
        anisotropyMapUv: F && x(A.anisotropyMap.channel),
        clearcoatMapUv: V && x(A.clearcoatMap.channel),
        clearcoatNormalMapUv: j && x(A.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: X && x(A.clearcoatRoughnessMap.channel),
        iridescenceMapUv: oe && x(A.iridescenceMap.channel),
        iridescenceThicknessMapUv: ee && x(A.iridescenceThicknessMap.channel),
        sheenColorMapUv: q && x(A.sheenColorMap.channel),
        sheenRoughnessMapUv: P && x(A.sheenRoughnessMap.channel),
        specularMapUv: ue && x(A.specularMap.channel),
        specularColorMapUv: ye && x(A.specularColorMap.channel),
        specularIntensityMapUv: fe && x(A.specularIntensityMap.channel),
        transmissionMapUv: Me && x(A.transmissionMap.channel),
        thicknessMapUv: _ && x(A.thicknessMap.channel),
        alphaMapUv: R && x(A.alphaMap.channel),
        vertexTangents: !!L.attributes.tangent && (_e || ce),
        vertexColors: A.vertexColors,
        vertexAlphas:
          A.vertexColors === !0 &&
          !!L.attributes.color &&
          L.attributes.color.itemSize === 4,
        vertexUv1s: Se,
        vertexUv2s: Ye,
        vertexUv3s: it,
        pointsUvs: I.isPoints === !0 && !!L.attributes.uv && (Te || R),
        fog: !!G,
        useFog: A.fog === !0,
        fogExp2: G && G.isFogExp2,
        flatShading: A.flatShading === !0,
        sizeAttenuation: A.sizeAttenuation === !0,
        logarithmicDepthBuffer: f,
        skinning: I.isSkinnedMesh === !0,
        morphTargets: L.morphAttributes.position !== void 0,
        morphNormals: L.morphAttributes.normal !== void 0,
        morphColors: L.morphAttributes.color !== void 0,
        morphTargetsCount: Y,
        morphTextureStride: W,
        numDirLights: D.directional.length,
        numPointLights: D.point.length,
        numSpotLights: D.spot.length,
        numSpotLightMaps: D.spotLightMap.length,
        numRectAreaLights: D.rectArea.length,
        numHemiLights: D.hemi.length,
        numDirLightShadows: D.directionalShadowMap.length,
        numPointLightShadows: D.pointShadowMap.length,
        numSpotLightShadows: D.spotShadowMap.length,
        numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps,
        numClippingPlanes: s.numPlanes,
        numClipIntersection: s.numIntersection,
        dithering: A.dithering,
        shadowMapEnabled: n.shadowMap.enabled && z.length > 0,
        shadowMapType: n.shadowMap.type,
        toneMapping: ct,
        useLegacyLights: n._useLegacyLights,
        decodeVideoTexture:
          Te && A.map.isVideoTexture === !0 && A.map.colorSpace === gt,
        premultipliedAlpha: A.premultipliedAlpha,
        doubleSided: A.side === jt,
        flipSided: A.side === en,
        useDepthPacking: A.depthPacking >= 0,
        depthPacking: A.depthPacking || 0,
        index0AttributeName: A.index0AttributeName,
        extensionDerivatives: le && A.extensions.derivatives === !0,
        extensionFragDepth: le && A.extensions.fragDepth === !0,
        extensionDrawBuffers: le && A.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: le && A.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: l || r.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: l || r.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: l || r.has("EXT_shader_texture_lod"),
        customProgramCacheKey: A.customProgramCacheKey(),
      }
    );
  }
  function p(A) {
    const D = [];
    if (
      (A.shaderID
        ? D.push(A.shaderID)
        : (D.push(A.customVertexShaderID), D.push(A.customFragmentShaderID)),
      A.defines !== void 0)
    )
      for (const z in A.defines) D.push(z), D.push(A.defines[z]);
    return (
      A.isRawShaderMaterial === !1 &&
        (S(D, A), v(D, A), D.push(n.outputColorSpace)),
      D.push(A.customProgramCacheKey),
      D.join()
    );
  }
  function S(A, D) {
    A.push(D.precision),
      A.push(D.outputColorSpace),
      A.push(D.envMapMode),
      A.push(D.envMapCubeUVHeight),
      A.push(D.mapUv),
      A.push(D.alphaMapUv),
      A.push(D.lightMapUv),
      A.push(D.aoMapUv),
      A.push(D.bumpMapUv),
      A.push(D.normalMapUv),
      A.push(D.displacementMapUv),
      A.push(D.emissiveMapUv),
      A.push(D.metalnessMapUv),
      A.push(D.roughnessMapUv),
      A.push(D.anisotropyMapUv),
      A.push(D.clearcoatMapUv),
      A.push(D.clearcoatNormalMapUv),
      A.push(D.clearcoatRoughnessMapUv),
      A.push(D.iridescenceMapUv),
      A.push(D.iridescenceThicknessMapUv),
      A.push(D.sheenColorMapUv),
      A.push(D.sheenRoughnessMapUv),
      A.push(D.specularMapUv),
      A.push(D.specularColorMapUv),
      A.push(D.specularIntensityMapUv),
      A.push(D.transmissionMapUv),
      A.push(D.thicknessMapUv),
      A.push(D.combine),
      A.push(D.fogExp2),
      A.push(D.sizeAttenuation),
      A.push(D.morphTargetsCount),
      A.push(D.morphAttributeCount),
      A.push(D.numDirLights),
      A.push(D.numPointLights),
      A.push(D.numSpotLights),
      A.push(D.numSpotLightMaps),
      A.push(D.numHemiLights),
      A.push(D.numRectAreaLights),
      A.push(D.numDirLightShadows),
      A.push(D.numPointLightShadows),
      A.push(D.numSpotLightShadows),
      A.push(D.numSpotLightShadowsWithMaps),
      A.push(D.shadowMapType),
      A.push(D.toneMapping),
      A.push(D.numClippingPlanes),
      A.push(D.numClipIntersection),
      A.push(D.depthPacking);
  }
  function v(A, D) {
    o.disableAll(),
      D.isWebGL2 && o.enable(0),
      D.supportsVertexTextures && o.enable(1),
      D.instancing && o.enable(2),
      D.instancingColor && o.enable(3),
      D.matcap && o.enable(4),
      D.envMap && o.enable(5),
      D.normalMapObjectSpace && o.enable(6),
      D.normalMapTangentSpace && o.enable(7),
      D.clearcoat && o.enable(8),
      D.iridescence && o.enable(9),
      D.alphaTest && o.enable(10),
      D.vertexColors && o.enable(11),
      D.vertexAlphas && o.enable(12),
      D.vertexUv1s && o.enable(13),
      D.vertexUv2s && o.enable(14),
      D.vertexUv3s && o.enable(15),
      D.vertexTangents && o.enable(16),
      D.anisotropy && o.enable(17),
      A.push(o.mask),
      o.disableAll(),
      D.fog && o.enable(0),
      D.useFog && o.enable(1),
      D.flatShading && o.enable(2),
      D.logarithmicDepthBuffer && o.enable(3),
      D.skinning && o.enable(4),
      D.morphTargets && o.enable(5),
      D.morphNormals && o.enable(6),
      D.morphColors && o.enable(7),
      D.premultipliedAlpha && o.enable(8),
      D.shadowMapEnabled && o.enable(9),
      D.useLegacyLights && o.enable(10),
      D.doubleSided && o.enable(11),
      D.flipSided && o.enable(12),
      D.useDepthPacking && o.enable(13),
      D.dithering && o.enable(14),
      D.transmission && o.enable(15),
      D.sheen && o.enable(16),
      D.opaque && o.enable(17),
      D.pointsUvs && o.enable(18),
      D.decodeVideoTexture && o.enable(19),
      A.push(o.mask);
  }
  function y(A) {
    const D = g[A.type];
    let z;
    if (D) {
      const $ = kn[D];
      z = Sy.clone($.uniforms);
    } else z = A.uniforms;
    return z;
  }
  function E(A, D) {
    let z;
    for (let $ = 0, I = u.length; $ < I; $++) {
      const G = u[$];
      if (G.cacheKey === D) {
        (z = G), ++z.usedTimes;
        break;
      }
    }
    return z === void 0 && ((z = new L_(n, D, A, a)), u.push(z)), z;
  }
  function M(A) {
    if (--A.usedTimes === 0) {
      const D = u.indexOf(A);
      (u[D] = u[u.length - 1]), u.pop(), A.destroy();
    }
  }
  function T(A) {
    c.remove(A);
  }
  function N() {
    c.dispose();
  }
  return {
    getParameters: m,
    getProgramCacheKey: p,
    getUniforms: y,
    acquireProgram: E,
    releaseProgram: M,
    releaseShaderCache: T,
    programs: u,
    dispose: N,
  };
}
function z_() {
  let n = new WeakMap();
  function e(a) {
    let s = n.get(a);
    return s === void 0 && ((s = {}), n.set(a, s)), s;
  }
  function t(a) {
    n.delete(a);
  }
  function r(a, s, o) {
    n.get(a)[s] = o;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function k_(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function Wf(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function qf() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function a() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function s(f, h, d, g, x, m) {
    let p = n[e];
    return (
      p === void 0
        ? ((p = {
            id: f.id,
            object: f,
            geometry: h,
            material: d,
            groupOrder: g,
            renderOrder: f.renderOrder,
            z: x,
            group: m,
          }),
          (n[e] = p))
        : ((p.id = f.id),
          (p.object = f),
          (p.geometry = h),
          (p.material = d),
          (p.groupOrder = g),
          (p.renderOrder = f.renderOrder),
          (p.z = x),
          (p.group = m)),
      e++,
      p
    );
  }
  function o(f, h, d, g, x, m) {
    const p = s(f, h, d, g, x, m);
    d.transmission > 0
      ? r.push(p)
      : d.transparent === !0
      ? i.push(p)
      : t.push(p);
  }
  function c(f, h, d, g, x, m) {
    const p = s(f, h, d, g, x, m);
    d.transmission > 0
      ? r.unshift(p)
      : d.transparent === !0
      ? i.unshift(p)
      : t.unshift(p);
  }
  function u(f, h) {
    t.length > 1 && t.sort(f || k_),
      r.length > 1 && r.sort(h || Wf),
      i.length > 1 && i.sort(h || Wf);
  }
  function l() {
    for (let f = e, h = n.length; f < h; f++) {
      const d = n[f];
      if (d.id === null) break;
      (d.id = null),
        (d.object = null),
        (d.geometry = null),
        (d.material = null),
        (d.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: a,
    push: o,
    unshift: c,
    finish: l,
    sort: u,
  };
}
function H_() {
  let n = new WeakMap();
  function e(r, i) {
    const a = n.get(r);
    let s;
    return (
      a === void 0
        ? ((s = new qf()), n.set(r, [s]))
        : i >= a.length
        ? ((s = new qf()), a.push(s))
        : (s = a[i]),
      s
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function G_() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new B(), color: new tt() };
          break;
        case "SpotLight":
          t = {
            position: new B(),
            direction: new B(),
            color: new tt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new B(), color: new tt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new B(), skyColor: new tt(), groundColor: new tt() };
          break;
        case "RectAreaLight":
          t = {
            color: new tt(),
            position: new B(),
            halfWidth: new B(),
            halfHeight: new B(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function V_() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new De(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new De(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new De(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let W_ = 0;
function q_(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function $_(n, e) {
  const t = new G_(),
    r = V_(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let l = 0; l < 9; l++) i.probe.push(new B());
  const a = new B(),
    s = new ut(),
    o = new ut();
  function c(l, f) {
    let h = 0,
      d = 0,
      g = 0;
    for (let z = 0; z < 9; z++) i.probe[z].set(0, 0, 0);
    let x = 0,
      m = 0,
      p = 0,
      S = 0,
      v = 0,
      y = 0,
      E = 0,
      M = 0,
      T = 0,
      N = 0;
    l.sort(q_);
    const A = f === !0 ? Math.PI : 1;
    for (let z = 0, $ = l.length; z < $; z++) {
      const I = l[z],
        G = I.color,
        L = I.intensity,
        C = I.distance,
        k = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
      if (I.isAmbientLight)
        (h += G.r * L * A), (d += G.g * L * A), (g += G.b * L * A);
      else if (I.isLightProbe)
        for (let Z = 0; Z < 9; Z++)
          i.probe[Z].addScaledVector(I.sh.coefficients[Z], L);
      else if (I.isDirectionalLight) {
        const Z = t.get(I);
        if (
          (Z.color.copy(I.color).multiplyScalar(I.intensity * A), I.castShadow)
        ) {
          const ie = I.shadow,
            ne = r.get(I);
          (ne.shadowBias = ie.bias),
            (ne.shadowNormalBias = ie.normalBias),
            (ne.shadowRadius = ie.radius),
            (ne.shadowMapSize = ie.mapSize),
            (i.directionalShadow[x] = ne),
            (i.directionalShadowMap[x] = k),
            (i.directionalShadowMatrix[x] = I.shadow.matrix),
            y++;
        }
        (i.directional[x] = Z), x++;
      } else if (I.isSpotLight) {
        const Z = t.get(I);
        Z.position.setFromMatrixPosition(I.matrixWorld),
          Z.color.copy(G).multiplyScalar(L * A),
          (Z.distance = C),
          (Z.coneCos = Math.cos(I.angle)),
          (Z.penumbraCos = Math.cos(I.angle * (1 - I.penumbra))),
          (Z.decay = I.decay),
          (i.spot[p] = Z);
        const ie = I.shadow;
        if (
          (I.map &&
            ((i.spotLightMap[T] = I.map),
            T++,
            ie.updateMatrices(I),
            I.castShadow && N++),
          (i.spotLightMatrix[p] = ie.matrix),
          I.castShadow)
        ) {
          const ne = r.get(I);
          (ne.shadowBias = ie.bias),
            (ne.shadowNormalBias = ie.normalBias),
            (ne.shadowRadius = ie.radius),
            (ne.shadowMapSize = ie.mapSize),
            (i.spotShadow[p] = ne),
            (i.spotShadowMap[p] = k),
            M++;
        }
        p++;
      } else if (I.isRectAreaLight) {
        const Z = t.get(I);
        Z.color.copy(G).multiplyScalar(L),
          Z.halfWidth.set(I.width * 0.5, 0, 0),
          Z.halfHeight.set(0, I.height * 0.5, 0),
          (i.rectArea[S] = Z),
          S++;
      } else if (I.isPointLight) {
        const Z = t.get(I);
        if (
          (Z.color.copy(I.color).multiplyScalar(I.intensity * A),
          (Z.distance = I.distance),
          (Z.decay = I.decay),
          I.castShadow)
        ) {
          const ie = I.shadow,
            ne = r.get(I);
          (ne.shadowBias = ie.bias),
            (ne.shadowNormalBias = ie.normalBias),
            (ne.shadowRadius = ie.radius),
            (ne.shadowMapSize = ie.mapSize),
            (ne.shadowCameraNear = ie.camera.near),
            (ne.shadowCameraFar = ie.camera.far),
            (i.pointShadow[m] = ne),
            (i.pointShadowMap[m] = k),
            (i.pointShadowMatrix[m] = I.shadow.matrix),
            E++;
        }
        (i.point[m] = Z), m++;
      } else if (I.isHemisphereLight) {
        const Z = t.get(I);
        Z.skyColor.copy(I.color).multiplyScalar(L * A),
          Z.groundColor.copy(I.groundColor).multiplyScalar(L * A),
          (i.hemi[v] = Z),
          v++;
      }
    }
    S > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Le.LTC_FLOAT_1), (i.rectAreaLTC2 = Le.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = Le.LTC_HALF_1), (i.rectAreaLTC2 = Le.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = h),
      (i.ambient[1] = d),
      (i.ambient[2] = g);
    const D = i.hash;
    (D.directionalLength !== x ||
      D.pointLength !== m ||
      D.spotLength !== p ||
      D.rectAreaLength !== S ||
      D.hemiLength !== v ||
      D.numDirectionalShadows !== y ||
      D.numPointShadows !== E ||
      D.numSpotShadows !== M ||
      D.numSpotMaps !== T) &&
      ((i.directional.length = x),
      (i.spot.length = p),
      (i.rectArea.length = S),
      (i.point.length = m),
      (i.hemi.length = v),
      (i.directionalShadow.length = y),
      (i.directionalShadowMap.length = y),
      (i.pointShadow.length = E),
      (i.pointShadowMap.length = E),
      (i.spotShadow.length = M),
      (i.spotShadowMap.length = M),
      (i.directionalShadowMatrix.length = y),
      (i.pointShadowMatrix.length = E),
      (i.spotLightMatrix.length = M + T - N),
      (i.spotLightMap.length = T),
      (i.numSpotLightShadowsWithMaps = N),
      (D.directionalLength = x),
      (D.pointLength = m),
      (D.spotLength = p),
      (D.rectAreaLength = S),
      (D.hemiLength = v),
      (D.numDirectionalShadows = y),
      (D.numPointShadows = E),
      (D.numSpotShadows = M),
      (D.numSpotMaps = T),
      (i.version = W_++));
  }
  function u(l, f) {
    let h = 0,
      d = 0,
      g = 0,
      x = 0,
      m = 0;
    const p = f.matrixWorldInverse;
    for (let S = 0, v = l.length; S < v; S++) {
      const y = l[S];
      if (y.isDirectionalLight) {
        const E = i.directional[h];
        E.direction.setFromMatrixPosition(y.matrixWorld),
          a.setFromMatrixPosition(y.target.matrixWorld),
          E.direction.sub(a),
          E.direction.transformDirection(p),
          h++;
      } else if (y.isSpotLight) {
        const E = i.spot[g];
        E.position.setFromMatrixPosition(y.matrixWorld),
          E.position.applyMatrix4(p),
          E.direction.setFromMatrixPosition(y.matrixWorld),
          a.setFromMatrixPosition(y.target.matrixWorld),
          E.direction.sub(a),
          E.direction.transformDirection(p),
          g++;
      } else if (y.isRectAreaLight) {
        const E = i.rectArea[x];
        E.position.setFromMatrixPosition(y.matrixWorld),
          E.position.applyMatrix4(p),
          o.identity(),
          s.copy(y.matrixWorld),
          s.premultiply(p),
          o.extractRotation(s),
          E.halfWidth.set(y.width * 0.5, 0, 0),
          E.halfHeight.set(0, y.height * 0.5, 0),
          E.halfWidth.applyMatrix4(o),
          E.halfHeight.applyMatrix4(o),
          x++;
      } else if (y.isPointLight) {
        const E = i.point[d];
        E.position.setFromMatrixPosition(y.matrixWorld),
          E.position.applyMatrix4(p),
          d++;
      } else if (y.isHemisphereLight) {
        const E = i.hemi[m];
        E.direction.setFromMatrixPosition(y.matrixWorld),
          E.direction.transformDirection(p),
          m++;
      }
    }
  }
  return { setup: c, setupView: u, state: i };
}
function $f(n, e) {
  const t = new $_(n, e),
    r = [],
    i = [];
  function a() {
    (r.length = 0), (i.length = 0);
  }
  function s(f) {
    r.push(f);
  }
  function o(f) {
    i.push(f);
  }
  function c(f) {
    t.setup(r, f);
  }
  function u(f) {
    t.setupView(r, f);
  }
  return {
    init: a,
    state: { lightsArray: r, shadowsArray: i, lights: t },
    setupLights: c,
    setupLightsView: u,
    pushLight: s,
    pushShadow: o,
  };
}
function j_(n, e) {
  let t = new WeakMap();
  function r(a, s = 0) {
    const o = t.get(a);
    let c;
    return (
      o === void 0
        ? ((c = new $f(n, e)), t.set(a, [c]))
        : s >= o.length
        ? ((c = new $f(n, e)), o.push(c))
        : (c = o[s]),
      c
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: r, dispose: i };
}
class X_ extends fi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = Cv),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Y_ extends fi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const Z_ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  J_ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function K_(n, e, t) {
  let r = new Hc();
  const i = new De(),
    a = new De(),
    s = new xt(),
    o = new X_({ depthPacking: Nv }),
    c = new Y_(),
    u = {},
    l = t.maxTextureSize,
    f = { [lr]: en, [en]: lr, [jt]: jt },
    h = new ii({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new De() },
        radius: { value: 4 },
      },
      vertexShader: Z_,
      fragmentShader: J_,
    }),
    d = h.clone();
  d.defines.HORIZONTAL_PASS = 1;
  const g = new wt();
  g.setAttribute(
    "position",
    new gn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const x = new Re(g, h),
    m = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Ep);
  let p = this.type;
  this.render = function (E, M, T) {
    if (
      m.enabled === !1 ||
      (m.autoUpdate === !1 && m.needsUpdate === !1) ||
      E.length === 0
    )
      return;
    const N = n.getRenderTarget(),
      A = n.getActiveCubeFace(),
      D = n.getActiveMipmapLevel(),
      z = n.state;
    z.setBlending(Tr),
      z.buffers.color.setClear(1, 1, 1, 1),
      z.buffers.depth.setTest(!0),
      z.setScissorTest(!1);
    const $ = p !== rr && this.type === rr,
      I = p === rr && this.type !== rr;
    for (let G = 0, L = E.length; G < L; G++) {
      const C = E[G],
        k = C.shadow;
      if (k === void 0) {
        console.warn("THREE.WebGLShadowMap:", C, "has no shadow.");
        continue;
      }
      if (k.autoUpdate === !1 && k.needsUpdate === !1) continue;
      i.copy(k.mapSize);
      const Z = k.getFrameExtents();
      if (
        (i.multiply(Z),
        a.copy(k.mapSize),
        (i.x > l || i.y > l) &&
          (i.x > l &&
            ((a.x = Math.floor(l / Z.x)),
            (i.x = a.x * Z.x),
            (k.mapSize.x = a.x)),
          i.y > l &&
            ((a.y = Math.floor(l / Z.y)),
            (i.y = a.y * Z.y),
            (k.mapSize.y = a.y))),
        k.map === null || $ === !0 || I === !0)
      ) {
        const ne = this.type !== rr ? { minFilter: Qt, magFilter: Qt } : {};
        k.map !== null && k.map.dispose(),
          (k.map = new ri(i.x, i.y, ne)),
          (k.map.texture.name = C.name + ".shadowMap"),
          k.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(k.map), n.clear();
      const ie = k.getViewportCount();
      for (let ne = 0; ne < ie; ne++) {
        const Y = k.getViewport(ne);
        s.set(a.x * Y.x, a.y * Y.y, a.x * Y.z, a.y * Y.w),
          z.viewport(s),
          k.updateMatrices(C, ne),
          (r = k.getFrustum()),
          y(M, T, k.camera, C, this.type);
      }
      k.isPointLightShadow !== !0 && this.type === rr && S(k, T),
        (k.needsUpdate = !1);
    }
    (p = this.type), (m.needsUpdate = !1), n.setRenderTarget(N, A, D);
  };
  function S(E, M) {
    const T = e.update(x);
    h.defines.VSM_SAMPLES !== E.blurSamples &&
      ((h.defines.VSM_SAMPLES = E.blurSamples),
      (d.defines.VSM_SAMPLES = E.blurSamples),
      (h.needsUpdate = !0),
      (d.needsUpdate = !0)),
      E.mapPass === null && (E.mapPass = new ri(i.x, i.y)),
      (h.uniforms.shadow_pass.value = E.map.texture),
      (h.uniforms.resolution.value = E.mapSize),
      (h.uniforms.radius.value = E.radius),
      n.setRenderTarget(E.mapPass),
      n.clear(),
      n.renderBufferDirect(M, null, T, h, x, null),
      (d.uniforms.shadow_pass.value = E.mapPass.texture),
      (d.uniforms.resolution.value = E.mapSize),
      (d.uniforms.radius.value = E.radius),
      n.setRenderTarget(E.map),
      n.clear(),
      n.renderBufferDirect(M, null, T, d, x, null);
  }
  function v(E, M, T, N) {
    let A = null;
    const D =
      T.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
    if (D !== void 0) A = D;
    else if (
      ((A = T.isPointLight === !0 ? c : o),
      (n.localClippingEnabled &&
        M.clipShadows === !0 &&
        Array.isArray(M.clippingPlanes) &&
        M.clippingPlanes.length !== 0) ||
        (M.displacementMap && M.displacementScale !== 0) ||
        (M.alphaMap && M.alphaTest > 0) ||
        (M.map && M.alphaTest > 0))
    ) {
      const z = A.uuid,
        $ = M.uuid;
      let I = u[z];
      I === void 0 && ((I = {}), (u[z] = I));
      let G = I[$];
      G === void 0 && ((G = A.clone()), (I[$] = G)), (A = G);
    }
    if (
      ((A.visible = M.visible),
      (A.wireframe = M.wireframe),
      N === rr
        ? (A.side = M.shadowSide !== null ? M.shadowSide : M.side)
        : (A.side = M.shadowSide !== null ? M.shadowSide : f[M.side]),
      (A.alphaMap = M.alphaMap),
      (A.alphaTest = M.alphaTest),
      (A.map = M.map),
      (A.clipShadows = M.clipShadows),
      (A.clippingPlanes = M.clippingPlanes),
      (A.clipIntersection = M.clipIntersection),
      (A.displacementMap = M.displacementMap),
      (A.displacementScale = M.displacementScale),
      (A.displacementBias = M.displacementBias),
      (A.wireframeLinewidth = M.wireframeLinewidth),
      (A.linewidth = M.linewidth),
      T.isPointLight === !0 && A.isMeshDistanceMaterial === !0)
    ) {
      const z = n.properties.get(A);
      z.light = T;
    }
    return A;
  }
  function y(E, M, T, N, A) {
    if (E.visible === !1) return;
    if (
      E.layers.test(M.layers) &&
      (E.isMesh || E.isLine || E.isPoints) &&
      (E.castShadow || (E.receiveShadow && A === rr)) &&
      (!E.frustumCulled || r.intersectsObject(E))
    ) {
      E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, E.matrixWorld);
      const $ = e.update(E),
        I = E.material;
      if (Array.isArray(I)) {
        const G = $.groups;
        for (let L = 0, C = G.length; L < C; L++) {
          const k = G[L],
            Z = I[k.materialIndex];
          if (Z && Z.visible) {
            const ie = v(E, Z, N, A);
            n.renderBufferDirect(T, null, $, ie, E, k);
          }
        }
      } else if (I.visible) {
        const G = v(E, I, N, A);
        n.renderBufferDirect(T, null, $, G, E, null);
      }
    }
    const z = E.children;
    for (let $ = 0, I = z.length; $ < I; $++) y(z[$], M, T, N, A);
  }
}
function Q_(n, e, t) {
  const r = t.isWebGL2;
  function i() {
    let R = !1;
    const re = new xt();
    let K = null;
    const le = new xt(0, 0, 0, 0);
    return {
      setMask: function (Se) {
        K !== Se && !R && (n.colorMask(Se, Se, Se, Se), (K = Se));
      },
      setLocked: function (Se) {
        R = Se;
      },
      setClear: function (Se, Ye, it, ct, Yt) {
        Yt === !0 && ((Se *= ct), (Ye *= ct), (it *= ct)),
          re.set(Se, Ye, it, ct),
          le.equals(re) === !1 && (n.clearColor(Se, Ye, it, ct), le.copy(re));
      },
      reset: function () {
        (R = !1), (K = null), le.set(-1, 0, 0, 0);
      },
    };
  }
  function a() {
    let R = !1,
      re = null,
      K = null,
      le = null;
    return {
      setTest: function (Se) {
        Se ? Fe(n.DEPTH_TEST) : Pe(n.DEPTH_TEST);
      },
      setMask: function (Se) {
        re !== Se && !R && (n.depthMask(Se), (re = Se));
      },
      setFunc: function (Se) {
        if (K !== Se) {
          switch (Se) {
            case av:
              n.depthFunc(n.NEVER);
              break;
            case sv:
              n.depthFunc(n.ALWAYS);
              break;
            case ov:
              n.depthFunc(n.LESS);
              break;
            case uc:
              n.depthFunc(n.LEQUAL);
              break;
            case uv:
              n.depthFunc(n.EQUAL);
              break;
            case cv:
              n.depthFunc(n.GEQUAL);
              break;
            case lv:
              n.depthFunc(n.GREATER);
              break;
            case fv:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          K = Se;
        }
      },
      setLocked: function (Se) {
        R = Se;
      },
      setClear: function (Se) {
        le !== Se && (n.clearDepth(Se), (le = Se));
      },
      reset: function () {
        (R = !1), (re = null), (K = null), (le = null);
      },
    };
  }
  function s() {
    let R = !1,
      re = null,
      K = null,
      le = null,
      Se = null,
      Ye = null,
      it = null,
      ct = null,
      Yt = null;
    return {
      setTest: function (lt) {
        R || (lt ? Fe(n.STENCIL_TEST) : Pe(n.STENCIL_TEST));
      },
      setMask: function (lt) {
        re !== lt && !R && (n.stencilMask(lt), (re = lt));
      },
      setFunc: function (lt, vn, zt) {
        (K !== lt || le !== vn || Se !== zt) &&
          (n.stencilFunc(lt, vn, zt), (K = lt), (le = vn), (Se = zt));
      },
      setOp: function (lt, vn, zt) {
        (Ye !== lt || it !== vn || ct !== zt) &&
          (n.stencilOp(lt, vn, zt), (Ye = lt), (it = vn), (ct = zt));
      },
      setLocked: function (lt) {
        R = lt;
      },
      setClear: function (lt) {
        Yt !== lt && (n.clearStencil(lt), (Yt = lt));
      },
      reset: function () {
        (R = !1),
          (re = null),
          (K = null),
          (le = null),
          (Se = null),
          (Ye = null),
          (it = null),
          (ct = null),
          (Yt = null);
      },
    };
  }
  const o = new i(),
    c = new a(),
    u = new s(),
    l = new WeakMap(),
    f = new WeakMap();
  let h = {},
    d = {},
    g = new WeakMap(),
    x = [],
    m = null,
    p = !1,
    S = null,
    v = null,
    y = null,
    E = null,
    M = null,
    T = null,
    N = null,
    A = !1,
    D = null,
    z = null,
    $ = null,
    I = null,
    G = null;
  const L = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let C = !1,
    k = 0;
  const Z = n.getParameter(n.VERSION);
  Z.indexOf("WebGL") !== -1
    ? ((k = parseFloat(/^WebGL (\d)/.exec(Z)[1])), (C = k >= 1))
    : Z.indexOf("OpenGL ES") !== -1 &&
      ((k = parseFloat(/^OpenGL ES (\d)/.exec(Z)[1])), (C = k >= 2));
  let ie = null,
    ne = {};
  const Y = n.getParameter(n.SCISSOR_BOX),
    W = n.getParameter(n.VIEWPORT),
    te = new xt().fromArray(Y),
    ve = new xt().fromArray(W);
  function be(R, re, K, le) {
    const Se = new Uint8Array(4),
      Ye = n.createTexture();
    n.bindTexture(R, Ye),
      n.texParameteri(R, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(R, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let it = 0; it < K; it++)
      r && (R === n.TEXTURE_3D || R === n.TEXTURE_2D_ARRAY)
        ? n.texImage3D(re, 0, n.RGBA, 1, 1, le, 0, n.RGBA, n.UNSIGNED_BYTE, Se)
        : n.texImage2D(
            re + it,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            Se
          );
    return Ye;
  }
  const Ae = {};
  (Ae[n.TEXTURE_2D] = be(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Ae[n.TEXTURE_CUBE_MAP] = be(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    r &&
      ((Ae[n.TEXTURE_2D_ARRAY] = be(
        n.TEXTURE_2D_ARRAY,
        n.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Ae[n.TEXTURE_3D] = be(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
    o.setClear(0, 0, 0, 1),
    c.setClear(1),
    u.setClear(0),
    Fe(n.DEPTH_TEST),
    c.setFunc(uc),
    ge(!1),
    Ue(Cl),
    Fe(n.CULL_FACE),
    he(Tr);
  function Fe(R) {
    h[R] !== !0 && (n.enable(R), (h[R] = !0));
  }
  function Pe(R) {
    h[R] !== !1 && (n.disable(R), (h[R] = !1));
  }
  function Te(R, re) {
    return d[R] !== re
      ? (n.bindFramebuffer(R, re),
        (d[R] = re),
        r &&
          (R === n.DRAW_FRAMEBUFFER && (d[n.FRAMEBUFFER] = re),
          R === n.FRAMEBUFFER && (d[n.DRAW_FRAMEBUFFER] = re)),
        !0)
      : !1;
  }
  function ze(R, re) {
    let K = x,
      le = !1;
    if (R)
      if (
        ((K = g.get(re)),
        K === void 0 && ((K = []), g.set(re, K)),
        R.isWebGLMultipleRenderTargets)
      ) {
        const Se = R.texture;
        if (K.length !== Se.length || K[0] !== n.COLOR_ATTACHMENT0) {
          for (let Ye = 0, it = Se.length; Ye < it; Ye++)
            K[Ye] = n.COLOR_ATTACHMENT0 + Ye;
          (K.length = Se.length), (le = !0);
        }
      } else
        K[0] !== n.COLOR_ATTACHMENT0 &&
          ((K[0] = n.COLOR_ATTACHMENT0), (le = !0));
    else K[0] !== n.BACK && ((K[0] = n.BACK), (le = !0));
    le &&
      (t.isWebGL2
        ? n.drawBuffers(K)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(K));
  }
  function Ee(R) {
    return m !== R ? (n.useProgram(R), (m = R), !0) : !1;
  }
  const H = {
    [Wi]: n.FUNC_ADD,
    [X0]: n.FUNC_SUBTRACT,
    [Y0]: n.FUNC_REVERSE_SUBTRACT,
  };
  if (r) (H[Pl] = n.MIN), (H[Ll] = n.MAX);
  else {
    const R = e.get("EXT_blend_minmax");
    R !== null && ((H[Pl] = R.MIN_EXT), (H[Ll] = R.MAX_EXT));
  }
  const we = {
    [Z0]: n.ZERO,
    [J0]: n.ONE,
    [K0]: n.SRC_COLOR,
    [Sp]: n.SRC_ALPHA,
    [iv]: n.SRC_ALPHA_SATURATE,
    [nv]: n.DST_COLOR,
    [ev]: n.DST_ALPHA,
    [Q0]: n.ONE_MINUS_SRC_COLOR,
    [Mp]: n.ONE_MINUS_SRC_ALPHA,
    [rv]: n.ONE_MINUS_DST_COLOR,
    [tv]: n.ONE_MINUS_DST_ALPHA,
  };
  function he(R, re, K, le, Se, Ye, it, ct) {
    if (R === Tr) {
      p === !0 && (Pe(n.BLEND), (p = !1));
      return;
    }
    if ((p === !1 && (Fe(n.BLEND), (p = !0)), R !== j0)) {
      if (R !== S || ct !== A) {
        if (
          ((v !== Wi || M !== Wi) &&
            (n.blendEquation(n.FUNC_ADD), (v = Wi), (M = Wi)),
          ct)
        )
          switch (R) {
            case ea:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Nl:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case Rl:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Fl:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", R);
              break;
          }
        else
          switch (R) {
            case ea:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Nl:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case Rl:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Fl:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", R);
              break;
          }
        (y = null), (E = null), (T = null), (N = null), (S = R), (A = ct);
      }
      return;
    }
    (Se = Se || re),
      (Ye = Ye || K),
      (it = it || le),
      (re !== v || Se !== M) &&
        (n.blendEquationSeparate(H[re], H[Se]), (v = re), (M = Se)),
      (K !== y || le !== E || Ye !== T || it !== N) &&
        (n.blendFuncSeparate(we[K], we[le], we[Ye], we[it]),
        (y = K),
        (E = le),
        (T = Ye),
        (N = it)),
      (S = R),
      (A = !1);
  }
  function _e(R, re) {
    R.side === jt ? Pe(n.CULL_FACE) : Fe(n.CULL_FACE);
    let K = R.side === en;
    re && (K = !K),
      ge(K),
      R.blending === ea && R.transparent === !1
        ? he(Tr)
        : he(
            R.blending,
            R.blendEquation,
            R.blendSrc,
            R.blendDst,
            R.blendEquationAlpha,
            R.blendSrcAlpha,
            R.blendDstAlpha,
            R.premultipliedAlpha
          ),
      c.setFunc(R.depthFunc),
      c.setTest(R.depthTest),
      c.setMask(R.depthWrite),
      o.setMask(R.colorWrite);
    const le = R.stencilWrite;
    u.setTest(le),
      le &&
        (u.setMask(R.stencilWriteMask),
        u.setFunc(R.stencilFunc, R.stencilRef, R.stencilFuncMask),
        u.setOp(R.stencilFail, R.stencilZFail, R.stencilZPass)),
      Q(R.polygonOffset, R.polygonOffsetFactor, R.polygonOffsetUnits),
      R.alphaToCoverage === !0
        ? Fe(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Pe(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ge(R) {
    D !== R && (R ? n.frontFace(n.CW) : n.frontFace(n.CCW), (D = R));
  }
  function Ue(R) {
    R !== W0
      ? (Fe(n.CULL_FACE),
        R !== z &&
          (R === Cl
            ? n.cullFace(n.BACK)
            : R === q0
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : Pe(n.CULL_FACE),
      (z = R);
  }
  function J(R) {
    R !== $ && (C && n.lineWidth(R), ($ = R));
  }
  function Q(R, re, K) {
    R
      ? (Fe(n.POLYGON_OFFSET_FILL),
        (I !== re || G !== K) && (n.polygonOffset(re, K), (I = re), (G = K)))
      : Pe(n.POLYGON_OFFSET_FILL);
  }
  function ce(R) {
    R ? Fe(n.SCISSOR_TEST) : Pe(n.SCISSOR_TEST);
  }
  function Ce(R) {
    R === void 0 && (R = n.TEXTURE0 + L - 1),
      ie !== R && (n.activeTexture(R), (ie = R));
  }
  function Ne(R, re, K) {
    K === void 0 && (ie === null ? (K = n.TEXTURE0 + L - 1) : (K = ie));
    let le = ne[K];
    le === void 0 && ((le = { type: void 0, texture: void 0 }), (ne[K] = le)),
      (le.type !== R || le.texture !== re) &&
        (ie !== K && (n.activeTexture(K), (ie = K)),
        n.bindTexture(R, re || Ae[R]),
        (le.type = R),
        (le.texture = re));
  }
  function w() {
    const R = ne[ie];
    R !== void 0 &&
      R.type !== void 0 &&
      (n.bindTexture(R.type, null), (R.type = void 0), (R.texture = void 0));
  }
  function b() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function F() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function V() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function j() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function X() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function oe() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function ee() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function q() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function P() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function ue() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (R) {
      console.error("THREE.WebGLState:", R);
    }
  }
  function ye(R) {
    te.equals(R) === !1 && (n.scissor(R.x, R.y, R.z, R.w), te.copy(R));
  }
  function fe(R) {
    ve.equals(R) === !1 && (n.viewport(R.x, R.y, R.z, R.w), ve.copy(R));
  }
  function Me(R, re) {
    let K = f.get(re);
    K === void 0 && ((K = new WeakMap()), f.set(re, K));
    let le = K.get(R);
    le === void 0 && ((le = n.getUniformBlockIndex(re, R.name)), K.set(R, le));
  }
  function _(R, re) {
    const le = f.get(re).get(R);
    l.get(re) !== le &&
      (n.uniformBlockBinding(re, le, R.__bindingPointIndex), l.set(re, le));
  }
  function U() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      r === !0 &&
        (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (h = {}),
      (ie = null),
      (ne = {}),
      (d = {}),
      (g = new WeakMap()),
      (x = []),
      (m = null),
      (p = !1),
      (S = null),
      (v = null),
      (y = null),
      (E = null),
      (M = null),
      (T = null),
      (N = null),
      (A = !1),
      (D = null),
      (z = null),
      ($ = null),
      (I = null),
      (G = null),
      te.set(0, 0, n.canvas.width, n.canvas.height),
      ve.set(0, 0, n.canvas.width, n.canvas.height),
      o.reset(),
      c.reset(),
      u.reset();
  }
  return {
    buffers: { color: o, depth: c, stencil: u },
    enable: Fe,
    disable: Pe,
    bindFramebuffer: Te,
    drawBuffers: ze,
    useProgram: Ee,
    setBlending: he,
    setMaterial: _e,
    setFlipSided: ge,
    setCullFace: Ue,
    setLineWidth: J,
    setPolygonOffset: Q,
    setScissorTest: ce,
    activeTexture: Ce,
    bindTexture: Ne,
    unbindTexture: w,
    compressedTexImage2D: b,
    compressedTexImage3D: F,
    texImage2D: P,
    texImage3D: ue,
    updateUBOMapping: Me,
    uniformBlockBinding: _,
    texStorage2D: ee,
    texStorage3D: q,
    texSubImage2D: V,
    texSubImage3D: j,
    compressedTexSubImage2D: X,
    compressedTexSubImage3D: oe,
    scissor: ye,
    viewport: fe,
    reset: U,
  };
}
function ew(n, e, t, r, i, a, s) {
  const o = i.isWebGL2,
    c = i.maxTextures,
    u = i.maxCubemapSize,
    l = i.maxTextureSize,
    f = i.maxSamples,
    h = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    d =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    g = new WeakMap();
  let x;
  const m = new WeakMap();
  let p = !1;
  try {
    p =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function S(w, b) {
    return p ? new OffscreenCanvas(w, b) : rs("canvas");
  }
  function v(w, b, F, V) {
    let j = 1;
    if (
      ((w.width > V || w.height > V) && (j = V / Math.max(w.width, w.height)),
      j < 1 || b === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && w instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && w instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && w instanceof ImageBitmap)
      ) {
        const X = b ? Do : Math.floor,
          oe = X(j * w.width),
          ee = X(j * w.height);
        x === void 0 && (x = S(oe, ee));
        const q = F ? S(oe, ee) : x;
        return (
          (q.width = oe),
          (q.height = ee),
          q.getContext("2d").drawImage(w, 0, 0, oe, ee),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              w.width +
              "x" +
              w.height +
              ") to (" +
              oe +
              "x" +
              ee +
              ")."
          ),
          q
        );
      } else
        return (
          "data" in w &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                w.width +
                "x" +
                w.height +
                ")."
            ),
          w
        );
    return w;
  }
  function y(w) {
    return dc(w.width) && dc(w.height);
  }
  function E(w) {
    return o
      ? !1
      : w.wrapS !== Pn ||
          w.wrapT !== Pn ||
          (w.minFilter !== Qt && w.minFilter !== wn);
  }
  function M(w, b) {
    return w.generateMipmaps && b && w.minFilter !== Qt && w.minFilter !== wn;
  }
  function T(w) {
    n.generateMipmap(w);
  }
  function N(w, b, F, V, j = !1) {
    if (o === !1) return b;
    if (w !== null) {
      if (n[w] !== void 0) return n[w];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          w +
          "'"
      );
    }
    let X = b;
    return (
      b === n.RED &&
        (F === n.FLOAT && (X = n.R32F),
        F === n.HALF_FLOAT && (X = n.R16F),
        F === n.UNSIGNED_BYTE && (X = n.R8)),
      b === n.RED_INTEGER &&
        (F === n.UNSIGNED_BYTE && (X = n.R8UI),
        F === n.UNSIGNED_SHORT && (X = n.R16UI),
        F === n.UNSIGNED_INT && (X = n.R32UI),
        F === n.BYTE && (X = n.R8I),
        F === n.SHORT && (X = n.R16I),
        F === n.INT && (X = n.R32I)),
      b === n.RG &&
        (F === n.FLOAT && (X = n.RG32F),
        F === n.HALF_FLOAT && (X = n.RG16F),
        F === n.UNSIGNED_BYTE && (X = n.RG8)),
      b === n.RGBA &&
        (F === n.FLOAT && (X = n.RGBA32F),
        F === n.HALF_FLOAT && (X = n.RGBA16F),
        F === n.UNSIGNED_BYTE &&
          (X = V === gt && j === !1 ? n.SRGB8_ALPHA8 : n.RGBA8),
        F === n.UNSIGNED_SHORT_4_4_4_4 && (X = n.RGBA4),
        F === n.UNSIGNED_SHORT_5_5_5_1 && (X = n.RGB5_A1)),
      (X === n.R16F ||
        X === n.R32F ||
        X === n.RG16F ||
        X === n.RG32F ||
        X === n.RGBA16F ||
        X === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      X
    );
  }
  function A(w, b, F) {
    return M(w, F) === !0 ||
      (w.isFramebufferTexture && w.minFilter !== Qt && w.minFilter !== wn)
      ? Math.log2(Math.max(b.width, b.height)) + 1
      : w.mipmaps !== void 0 && w.mipmaps.length > 0
      ? w.mipmaps.length
      : w.isCompressedTexture && Array.isArray(w.image)
      ? b.mipmaps.length
      : 1;
  }
  function D(w) {
    return w === Qt || w === Il || w === mu ? n.NEAREST : n.LINEAR;
  }
  function z(w) {
    const b = w.target;
    b.removeEventListener("dispose", z), I(b), b.isVideoTexture && g.delete(b);
  }
  function $(w) {
    const b = w.target;
    b.removeEventListener("dispose", $), L(b);
  }
  function I(w) {
    const b = r.get(w);
    if (b.__webglInit === void 0) return;
    const F = w.source,
      V = m.get(F);
    if (V) {
      const j = V[b.__cacheKey];
      j.usedTimes--,
        j.usedTimes === 0 && G(w),
        Object.keys(V).length === 0 && m.delete(F);
    }
    r.remove(w);
  }
  function G(w) {
    const b = r.get(w);
    n.deleteTexture(b.__webglTexture);
    const F = w.source,
      V = m.get(F);
    delete V[b.__cacheKey], s.memory.textures--;
  }
  function L(w) {
    const b = w.texture,
      F = r.get(w),
      V = r.get(b);
    if (
      (V.__webglTexture !== void 0 &&
        (n.deleteTexture(V.__webglTexture), s.memory.textures--),
      w.depthTexture && w.depthTexture.dispose(),
      w.isWebGLCubeRenderTarget)
    )
      for (let j = 0; j < 6; j++) {
        if (Array.isArray(F.__webglFramebuffer[j]))
          for (let X = 0; X < F.__webglFramebuffer[j].length; X++)
            n.deleteFramebuffer(F.__webglFramebuffer[j][X]);
        else n.deleteFramebuffer(F.__webglFramebuffer[j]);
        F.__webglDepthbuffer && n.deleteRenderbuffer(F.__webglDepthbuffer[j]);
      }
    else {
      if (Array.isArray(F.__webglFramebuffer))
        for (let j = 0; j < F.__webglFramebuffer.length; j++)
          n.deleteFramebuffer(F.__webglFramebuffer[j]);
      else n.deleteFramebuffer(F.__webglFramebuffer);
      if (
        (F.__webglDepthbuffer && n.deleteRenderbuffer(F.__webglDepthbuffer),
        F.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(F.__webglMultisampledFramebuffer),
        F.__webglColorRenderbuffer)
      )
        for (let j = 0; j < F.__webglColorRenderbuffer.length; j++)
          F.__webglColorRenderbuffer[j] &&
            n.deleteRenderbuffer(F.__webglColorRenderbuffer[j]);
      F.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(F.__webglDepthRenderbuffer);
    }
    if (w.isWebGLMultipleRenderTargets)
      for (let j = 0, X = b.length; j < X; j++) {
        const oe = r.get(b[j]);
        oe.__webglTexture &&
          (n.deleteTexture(oe.__webglTexture), s.memory.textures--),
          r.remove(b[j]);
      }
    r.remove(b), r.remove(w);
  }
  let C = 0;
  function k() {
    C = 0;
  }
  function Z() {
    const w = C;
    return (
      w >= c &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            w +
            " texture units while this GPU supports only " +
            c
        ),
      (C += 1),
      w
    );
  }
  function ie(w) {
    const b = [];
    return (
      b.push(w.wrapS),
      b.push(w.wrapT),
      b.push(w.wrapR || 0),
      b.push(w.magFilter),
      b.push(w.minFilter),
      b.push(w.anisotropy),
      b.push(w.internalFormat),
      b.push(w.format),
      b.push(w.type),
      b.push(w.generateMipmaps),
      b.push(w.premultiplyAlpha),
      b.push(w.flipY),
      b.push(w.unpackAlignment),
      b.push(w.colorSpace),
      b.join()
    );
  }
  function ne(w, b) {
    const F = r.get(w);
    if (
      (w.isVideoTexture && Ce(w),
      w.isRenderTargetTexture === !1 &&
        w.version > 0 &&
        F.__version !== w.version)
    ) {
      const V = w.image;
      if (V === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (V.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Te(F, w, b);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, F.__webglTexture, n.TEXTURE0 + b);
  }
  function Y(w, b) {
    const F = r.get(w);
    if (w.version > 0 && F.__version !== w.version) {
      Te(F, w, b);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, F.__webglTexture, n.TEXTURE0 + b);
  }
  function W(w, b) {
    const F = r.get(w);
    if (w.version > 0 && F.__version !== w.version) {
      Te(F, w, b);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, F.__webglTexture, n.TEXTURE0 + b);
  }
  function te(w, b) {
    const F = r.get(w);
    if (w.version > 0 && F.__version !== w.version) {
      ze(F, w, b);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, F.__webglTexture, n.TEXTURE0 + b);
  }
  const ve = { [lc]: n.REPEAT, [Pn]: n.CLAMP_TO_EDGE, [fc]: n.MIRRORED_REPEAT },
    be = {
      [Qt]: n.NEAREST,
      [Il]: n.NEAREST_MIPMAP_NEAREST,
      [mu]: n.NEAREST_MIPMAP_LINEAR,
      [wn]: n.LINEAR,
      [xv]: n.LINEAR_MIPMAP_NEAREST,
      [es]: n.LINEAR_MIPMAP_LINEAR,
    },
    Ae = {
      [Pv]: n.NEVER,
      [kv]: n.ALWAYS,
      [Lv]: n.LESS,
      [Ov]: n.LEQUAL,
      [Iv]: n.EQUAL,
      [zv]: n.GEQUAL,
      [Uv]: n.GREATER,
      [Bv]: n.NOTEQUAL,
    };
  function Fe(w, b, F) {
    if (
      (F
        ? (n.texParameteri(w, n.TEXTURE_WRAP_S, ve[b.wrapS]),
          n.texParameteri(w, n.TEXTURE_WRAP_T, ve[b.wrapT]),
          (w === n.TEXTURE_3D || w === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(w, n.TEXTURE_WRAP_R, ve[b.wrapR]),
          n.texParameteri(w, n.TEXTURE_MAG_FILTER, be[b.magFilter]),
          n.texParameteri(w, n.TEXTURE_MIN_FILTER, be[b.minFilter]))
        : (n.texParameteri(w, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
          n.texParameteri(w, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
          (w === n.TEXTURE_3D || w === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(w, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
          (b.wrapS !== Pn || b.wrapT !== Pn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(w, n.TEXTURE_MAG_FILTER, D(b.magFilter)),
          n.texParameteri(w, n.TEXTURE_MIN_FILTER, D(b.minFilter)),
          b.minFilter !== Qt &&
            b.minFilter !== wn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      b.compareFunction &&
        (n.texParameteri(w, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(w, n.TEXTURE_COMPARE_FUNC, Ae[b.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const V = e.get("EXT_texture_filter_anisotropic");
      if (
        b.magFilter === Qt ||
        (b.minFilter !== mu && b.minFilter !== es) ||
        (b.type === Sr && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          b.type === ts &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (b.anisotropy > 1 || r.get(b).__currentAnisotropy) &&
        (n.texParameterf(
          w,
          V.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(b.anisotropy, i.getMaxAnisotropy())
        ),
        (r.get(b).__currentAnisotropy = b.anisotropy));
    }
  }
  function Pe(w, b) {
    let F = !1;
    w.__webglInit === void 0 &&
      ((w.__webglInit = !0), b.addEventListener("dispose", z));
    const V = b.source;
    let j = m.get(V);
    j === void 0 && ((j = {}), m.set(V, j));
    const X = ie(b);
    if (X !== w.__cacheKey) {
      j[X] === void 0 &&
        ((j[X] = { texture: n.createTexture(), usedTimes: 0 }),
        s.memory.textures++,
        (F = !0)),
        j[X].usedTimes++;
      const oe = j[w.__cacheKey];
      oe !== void 0 &&
        (j[w.__cacheKey].usedTimes--, oe.usedTimes === 0 && G(b)),
        (w.__cacheKey = X),
        (w.__webglTexture = j[X].texture);
    }
    return F;
  }
  function Te(w, b, F) {
    let V = n.TEXTURE_2D;
    (b.isDataArrayTexture || b.isCompressedArrayTexture) &&
      (V = n.TEXTURE_2D_ARRAY),
      b.isData3DTexture && (V = n.TEXTURE_3D);
    const j = Pe(w, b),
      X = b.source;
    t.bindTexture(V, w.__webglTexture, n.TEXTURE0 + F);
    const oe = r.get(X);
    if (X.version !== oe.__version || j === !0) {
      t.activeTexture(n.TEXTURE0 + F),
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, b.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, b.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const ee = E(b) && y(b.image) === !1;
      let q = v(b.image, ee, !1, l);
      q = Ne(b, q);
      const P = y(q) || o,
        ue = a.convert(b.format, b.colorSpace);
      let ye = a.convert(b.type),
        fe = N(b.internalFormat, ue, ye, b.colorSpace, b.isVideoTexture);
      Fe(V, b, P);
      let Me;
      const _ = b.mipmaps,
        U = o && b.isVideoTexture !== !0,
        R = oe.__version === void 0 || j === !0,
        re = A(b, q, P);
      if (b.isDepthTexture)
        (fe = n.DEPTH_COMPONENT),
          o
            ? b.type === Sr
              ? (fe = n.DEPTH_COMPONENT32F)
              : b.type === Er
              ? (fe = n.DEPTH_COMPONENT24)
              : b.type === Qr
              ? (fe = n.DEPTH24_STENCIL8)
              : (fe = n.DEPTH_COMPONENT16)
            : b.type === Sr &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          b.format === ei &&
            fe === n.DEPTH_COMPONENT &&
            b.type !== Uc &&
            b.type !== Er &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (b.type = Er),
            (ye = a.convert(b.type))),
          b.format === ua &&
            fe === n.DEPTH_COMPONENT &&
            ((fe = n.DEPTH_STENCIL),
            b.type !== Qr &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (b.type = Qr),
              (ye = a.convert(b.type)))),
          R &&
            (U
              ? t.texStorage2D(n.TEXTURE_2D, 1, fe, q.width, q.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  fe,
                  q.width,
                  q.height,
                  0,
                  ue,
                  ye,
                  null
                ));
      else if (b.isDataTexture)
        if (_.length > 0 && P) {
          U &&
            R &&
            t.texStorage2D(n.TEXTURE_2D, re, fe, _[0].width, _[0].height);
          for (let K = 0, le = _.length; K < le; K++)
            (Me = _[K]),
              U
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    K,
                    0,
                    0,
                    Me.width,
                    Me.height,
                    ue,
                    ye,
                    Me.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    K,
                    fe,
                    Me.width,
                    Me.height,
                    0,
                    ue,
                    ye,
                    Me.data
                  );
          b.generateMipmaps = !1;
        } else
          U
            ? (R && t.texStorage2D(n.TEXTURE_2D, re, fe, q.width, q.height),
              t.texSubImage2D(
                n.TEXTURE_2D,
                0,
                0,
                0,
                q.width,
                q.height,
                ue,
                ye,
                q.data
              ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                fe,
                q.width,
                q.height,
                0,
                ue,
                ye,
                q.data
              );
      else if (b.isCompressedTexture)
        if (b.isCompressedArrayTexture) {
          U &&
            R &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              re,
              fe,
              _[0].width,
              _[0].height,
              q.depth
            );
          for (let K = 0, le = _.length; K < le; K++)
            (Me = _[K]),
              b.format !== Ln
                ? ue !== null
                  ? U
                    ? t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        K,
                        0,
                        0,
                        0,
                        Me.width,
                        Me.height,
                        q.depth,
                        ue,
                        Me.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        K,
                        fe,
                        Me.width,
                        Me.height,
                        q.depth,
                        0,
                        Me.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : U
                ? t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    K,
                    0,
                    0,
                    0,
                    Me.width,
                    Me.height,
                    q.depth,
                    ue,
                    ye,
                    Me.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    K,
                    fe,
                    Me.width,
                    Me.height,
                    q.depth,
                    0,
                    ue,
                    ye,
                    Me.data
                  );
        } else {
          U &&
            R &&
            t.texStorage2D(n.TEXTURE_2D, re, fe, _[0].width, _[0].height);
          for (let K = 0, le = _.length; K < le; K++)
            (Me = _[K]),
              b.format !== Ln
                ? ue !== null
                  ? U
                    ? t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        K,
                        0,
                        0,
                        Me.width,
                        Me.height,
                        ue,
                        Me.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        K,
                        fe,
                        Me.width,
                        Me.height,
                        0,
                        Me.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : U
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    K,
                    0,
                    0,
                    Me.width,
                    Me.height,
                    ue,
                    ye,
                    Me.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    K,
                    fe,
                    Me.width,
                    Me.height,
                    0,
                    ue,
                    ye,
                    Me.data
                  );
        }
      else if (b.isDataArrayTexture)
        U
          ? (R &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                re,
                fe,
                q.width,
                q.height,
                q.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              q.width,
              q.height,
              q.depth,
              ue,
              ye,
              q.data
            ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              fe,
              q.width,
              q.height,
              q.depth,
              0,
              ue,
              ye,
              q.data
            );
      else if (b.isData3DTexture)
        U
          ? (R &&
              t.texStorage3D(n.TEXTURE_3D, re, fe, q.width, q.height, q.depth),
            t.texSubImage3D(
              n.TEXTURE_3D,
              0,
              0,
              0,
              0,
              q.width,
              q.height,
              q.depth,
              ue,
              ye,
              q.data
            ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              fe,
              q.width,
              q.height,
              q.depth,
              0,
              ue,
              ye,
              q.data
            );
      else if (b.isFramebufferTexture) {
        if (R)
          if (U) t.texStorage2D(n.TEXTURE_2D, re, fe, q.width, q.height);
          else {
            let K = q.width,
              le = q.height;
            for (let Se = 0; Se < re; Se++)
              t.texImage2D(n.TEXTURE_2D, Se, fe, K, le, 0, ue, ye, null),
                (K >>= 1),
                (le >>= 1);
          }
      } else if (_.length > 0 && P) {
        U && R && t.texStorage2D(n.TEXTURE_2D, re, fe, _[0].width, _[0].height);
        for (let K = 0, le = _.length; K < le; K++)
          (Me = _[K]),
            U
              ? t.texSubImage2D(n.TEXTURE_2D, K, 0, 0, ue, ye, Me)
              : t.texImage2D(n.TEXTURE_2D, K, fe, ue, ye, Me);
        b.generateMipmaps = !1;
      } else
        U
          ? (R && t.texStorage2D(n.TEXTURE_2D, re, fe, q.width, q.height),
            t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ue, ye, q))
          : t.texImage2D(n.TEXTURE_2D, 0, fe, ue, ye, q);
      M(b, P) && T(V), (oe.__version = X.version), b.onUpdate && b.onUpdate(b);
    }
    w.__version = b.version;
  }
  function ze(w, b, F) {
    if (b.image.length !== 6) return;
    const V = Pe(w, b),
      j = b.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, w.__webglTexture, n.TEXTURE0 + F);
    const X = r.get(j);
    if (j.version !== X.__version || V === !0) {
      t.activeTexture(n.TEXTURE0 + F),
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, b.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, b.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const oe = b.isCompressedTexture || b.image[0].isCompressedTexture,
        ee = b.image[0] && b.image[0].isDataTexture,
        q = [];
      for (let K = 0; K < 6; K++)
        !oe && !ee
          ? (q[K] = v(b.image[K], !1, !0, u))
          : (q[K] = ee ? b.image[K].image : b.image[K]),
          (q[K] = Ne(b, q[K]));
      const P = q[0],
        ue = y(P) || o,
        ye = a.convert(b.format, b.colorSpace),
        fe = a.convert(b.type),
        Me = N(b.internalFormat, ye, fe, b.colorSpace),
        _ = o && b.isVideoTexture !== !0,
        U = X.__version === void 0 || V === !0;
      let R = A(b, P, ue);
      Fe(n.TEXTURE_CUBE_MAP, b, ue);
      let re;
      if (oe) {
        _ && U && t.texStorage2D(n.TEXTURE_CUBE_MAP, R, Me, P.width, P.height);
        for (let K = 0; K < 6; K++) {
          re = q[K].mipmaps;
          for (let le = 0; le < re.length; le++) {
            const Se = re[le];
            b.format !== Ln
              ? ye !== null
                ? _
                  ? t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                      le,
                      0,
                      0,
                      Se.width,
                      Se.height,
                      ye,
                      Se.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                      le,
                      Me,
                      Se.width,
                      Se.height,
                      0,
                      Se.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : _
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                  le,
                  0,
                  0,
                  Se.width,
                  Se.height,
                  ye,
                  fe,
                  Se.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                  le,
                  Me,
                  Se.width,
                  Se.height,
                  0,
                  ye,
                  fe,
                  Se.data
                );
          }
        }
      } else {
        (re = b.mipmaps),
          _ &&
            U &&
            (re.length > 0 && R++,
            t.texStorage2D(n.TEXTURE_CUBE_MAP, R, Me, q[0].width, q[0].height));
        for (let K = 0; K < 6; K++)
          if (ee) {
            _
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                  0,
                  0,
                  0,
                  q[K].width,
                  q[K].height,
                  ye,
                  fe,
                  q[K].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                  0,
                  Me,
                  q[K].width,
                  q[K].height,
                  0,
                  ye,
                  fe,
                  q[K].data
                );
            for (let le = 0; le < re.length; le++) {
              const Ye = re[le].image[K].image;
              _
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                    le + 1,
                    0,
                    0,
                    Ye.width,
                    Ye.height,
                    ye,
                    fe,
                    Ye.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                    le + 1,
                    Me,
                    Ye.width,
                    Ye.height,
                    0,
                    ye,
                    fe,
                    Ye.data
                  );
            }
          } else {
            _
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                  0,
                  0,
                  0,
                  ye,
                  fe,
                  q[K]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                  0,
                  Me,
                  ye,
                  fe,
                  q[K]
                );
            for (let le = 0; le < re.length; le++) {
              const Se = re[le];
              _
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                    le + 1,
                    0,
                    0,
                    ye,
                    fe,
                    Se.image[K]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                    le + 1,
                    Me,
                    ye,
                    fe,
                    Se.image[K]
                  );
            }
          }
      }
      M(b, ue) && T(n.TEXTURE_CUBE_MAP),
        (X.__version = j.version),
        b.onUpdate && b.onUpdate(b);
    }
    w.__version = b.version;
  }
  function Ee(w, b, F, V, j, X) {
    const oe = a.convert(F.format, F.colorSpace),
      ee = a.convert(F.type),
      q = N(F.internalFormat, oe, ee, F.colorSpace);
    if (!r.get(b).__hasExternalTextures) {
      const ue = Math.max(1, b.width >> X),
        ye = Math.max(1, b.height >> X);
      j === n.TEXTURE_3D || j === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(j, X, q, ue, ye, b.depth, 0, oe, ee, null)
        : t.texImage2D(j, X, q, ue, ye, 0, oe, ee, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, w),
      ce(b)
        ? h.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            V,
            j,
            r.get(F).__webglTexture,
            0,
            Q(b)
          )
        : (j === n.TEXTURE_2D ||
            (j >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              j <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            V,
            j,
            r.get(F).__webglTexture,
            X
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function H(w, b, F) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, w), b.depthBuffer && !b.stencilBuffer)
    ) {
      let V = n.DEPTH_COMPONENT16;
      if (F || ce(b)) {
        const j = b.depthTexture;
        j &&
          j.isDepthTexture &&
          (j.type === Sr
            ? (V = n.DEPTH_COMPONENT32F)
            : j.type === Er && (V = n.DEPTH_COMPONENT24));
        const X = Q(b);
        ce(b)
          ? h.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              X,
              V,
              b.width,
              b.height
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              X,
              V,
              b.width,
              b.height
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, V, b.width, b.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        w
      );
    } else if (b.depthBuffer && b.stencilBuffer) {
      const V = Q(b);
      F && ce(b) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            V,
            n.DEPTH24_STENCIL8,
            b.width,
            b.height
          )
        : ce(b)
        ? h.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            V,
            n.DEPTH24_STENCIL8,
            b.width,
            b.height
          )
        : n.renderbufferStorage(
            n.RENDERBUFFER,
            n.DEPTH_STENCIL,
            b.width,
            b.height
          ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          w
        );
    } else {
      const V = b.isWebGLMultipleRenderTargets === !0 ? b.texture : [b.texture];
      for (let j = 0; j < V.length; j++) {
        const X = V[j],
          oe = a.convert(X.format, X.colorSpace),
          ee = a.convert(X.type),
          q = N(X.internalFormat, oe, ee, X.colorSpace),
          P = Q(b);
        F && ce(b) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              P,
              q,
              b.width,
              b.height
            )
          : ce(b)
          ? h.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              P,
              q,
              b.width,
              b.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, q, b.width, b.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function we(w, b) {
    if (b && b.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, w),
      !(b.depthTexture && b.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(b.depthTexture).__webglTexture ||
      b.depthTexture.image.width !== b.width ||
      b.depthTexture.image.height !== b.height) &&
      ((b.depthTexture.image.width = b.width),
      (b.depthTexture.image.height = b.height),
      (b.depthTexture.needsUpdate = !0)),
      ne(b.depthTexture, 0);
    const V = r.get(b.depthTexture).__webglTexture,
      j = Q(b);
    if (b.depthTexture.format === ei)
      ce(b)
        ? h.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            V,
            0,
            j
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            V,
            0
          );
    else if (b.depthTexture.format === ua)
      ce(b)
        ? h.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            V,
            0,
            j
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            V,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function he(w) {
    const b = r.get(w),
      F = w.isWebGLCubeRenderTarget === !0;
    if (w.depthTexture && !b.__autoAllocateDepthBuffer) {
      if (F)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      we(b.__webglFramebuffer, w);
    } else if (F) {
      b.__webglDepthbuffer = [];
      for (let V = 0; V < 6; V++)
        t.bindFramebuffer(n.FRAMEBUFFER, b.__webglFramebuffer[V]),
          (b.__webglDepthbuffer[V] = n.createRenderbuffer()),
          H(b.__webglDepthbuffer[V], w, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, b.__webglFramebuffer),
        (b.__webglDepthbuffer = n.createRenderbuffer()),
        H(b.__webglDepthbuffer, w, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function _e(w, b, F) {
    const V = r.get(w);
    b !== void 0 &&
      Ee(
        V.__webglFramebuffer,
        w,
        w.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      F !== void 0 && he(w);
  }
  function ge(w) {
    const b = w.texture,
      F = r.get(w),
      V = r.get(b);
    w.addEventListener("dispose", $),
      w.isWebGLMultipleRenderTargets !== !0 &&
        (V.__webglTexture === void 0 && (V.__webglTexture = n.createTexture()),
        (V.__version = b.version),
        s.memory.textures++);
    const j = w.isWebGLCubeRenderTarget === !0,
      X = w.isWebGLMultipleRenderTargets === !0,
      oe = y(w) || o;
    if (j) {
      F.__webglFramebuffer = [];
      for (let ee = 0; ee < 6; ee++)
        if (o && b.mipmaps && b.mipmaps.length > 0) {
          F.__webglFramebuffer[ee] = [];
          for (let q = 0; q < b.mipmaps.length; q++)
            F.__webglFramebuffer[ee][q] = n.createFramebuffer();
        } else F.__webglFramebuffer[ee] = n.createFramebuffer();
    } else {
      if (o && b.mipmaps && b.mipmaps.length > 0) {
        F.__webglFramebuffer = [];
        for (let ee = 0; ee < b.mipmaps.length; ee++)
          F.__webglFramebuffer[ee] = n.createFramebuffer();
      } else F.__webglFramebuffer = n.createFramebuffer();
      if (X)
        if (i.drawBuffers) {
          const ee = w.texture;
          for (let q = 0, P = ee.length; q < P; q++) {
            const ue = r.get(ee[q]);
            ue.__webglTexture === void 0 &&
              ((ue.__webglTexture = n.createTexture()), s.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && w.samples > 0 && ce(w) === !1) {
        const ee = X ? b : [b];
        (F.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (F.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, F.__webglMultisampledFramebuffer);
        for (let q = 0; q < ee.length; q++) {
          const P = ee[q];
          (F.__webglColorRenderbuffer[q] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, F.__webglColorRenderbuffer[q]);
          const ue = a.convert(P.format, P.colorSpace),
            ye = a.convert(P.type),
            fe = N(
              P.internalFormat,
              ue,
              ye,
              P.colorSpace,
              w.isXRRenderTarget === !0
            ),
            Me = Q(w);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Me,
            fe,
            w.width,
            w.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + q,
              n.RENDERBUFFER,
              F.__webglColorRenderbuffer[q]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          w.depthBuffer &&
            ((F.__webglDepthRenderbuffer = n.createRenderbuffer()),
            H(F.__webglDepthRenderbuffer, w, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (j) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, V.__webglTexture),
        Fe(n.TEXTURE_CUBE_MAP, b, oe);
      for (let ee = 0; ee < 6; ee++)
        if (o && b.mipmaps && b.mipmaps.length > 0)
          for (let q = 0; q < b.mipmaps.length; q++)
            Ee(
              F.__webglFramebuffer[ee][q],
              w,
              b,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
              q
            );
        else
          Ee(
            F.__webglFramebuffer[ee],
            w,
            b,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
            0
          );
      M(b, oe) && T(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (X) {
      const ee = w.texture;
      for (let q = 0, P = ee.length; q < P; q++) {
        const ue = ee[q],
          ye = r.get(ue);
        t.bindTexture(n.TEXTURE_2D, ye.__webglTexture),
          Fe(n.TEXTURE_2D, ue, oe),
          Ee(
            F.__webglFramebuffer,
            w,
            ue,
            n.COLOR_ATTACHMENT0 + q,
            n.TEXTURE_2D,
            0
          ),
          M(ue, oe) && T(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let ee = n.TEXTURE_2D;
      if (
        ((w.isWebGL3DRenderTarget || w.isWebGLArrayRenderTarget) &&
          (o
            ? (ee = w.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        t.bindTexture(ee, V.__webglTexture),
        Fe(ee, b, oe),
        o && b.mipmaps && b.mipmaps.length > 0)
      )
        for (let q = 0; q < b.mipmaps.length; q++)
          Ee(F.__webglFramebuffer[q], w, b, n.COLOR_ATTACHMENT0, ee, q);
      else Ee(F.__webglFramebuffer, w, b, n.COLOR_ATTACHMENT0, ee, 0);
      M(b, oe) && T(ee), t.unbindTexture();
    }
    w.depthBuffer && he(w);
  }
  function Ue(w) {
    const b = y(w) || o,
      F = w.isWebGLMultipleRenderTargets === !0 ? w.texture : [w.texture];
    for (let V = 0, j = F.length; V < j; V++) {
      const X = F[V];
      if (M(X, b)) {
        const oe = w.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          ee = r.get(X).__webglTexture;
        t.bindTexture(oe, ee), T(oe), t.unbindTexture();
      }
    }
  }
  function J(w) {
    if (o && w.samples > 0 && ce(w) === !1) {
      const b = w.isWebGLMultipleRenderTargets ? w.texture : [w.texture],
        F = w.width,
        V = w.height;
      let j = n.COLOR_BUFFER_BIT;
      const X = [],
        oe = w.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        ee = r.get(w),
        q = w.isWebGLMultipleRenderTargets === !0;
      if (q)
        for (let P = 0; P < b.length; P++)
          t.bindFramebuffer(n.FRAMEBUFFER, ee.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + P,
              n.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(n.FRAMEBUFFER, ee.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + P,
              n.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(n.READ_FRAMEBUFFER, ee.__webglMultisampledFramebuffer),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ee.__webglFramebuffer);
      for (let P = 0; P < b.length; P++) {
        X.push(n.COLOR_ATTACHMENT0 + P), w.depthBuffer && X.push(oe);
        const ue =
          ee.__ignoreDepthValues !== void 0 ? ee.__ignoreDepthValues : !1;
        if (
          (ue === !1 &&
            (w.depthBuffer && (j |= n.DEPTH_BUFFER_BIT),
            w.stencilBuffer && (j |= n.STENCIL_BUFFER_BIT)),
          q &&
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              ee.__webglColorRenderbuffer[P]
            ),
          ue === !0 &&
            (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [oe]),
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [oe])),
          q)
        ) {
          const ye = r.get(b[P]).__webglTexture;
          n.framebufferTexture2D(
            n.DRAW_FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            ye,
            0
          );
        }
        n.blitFramebuffer(0, 0, F, V, 0, 0, F, V, j, n.NEAREST),
          d && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, X);
      }
      if (
        (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        q)
      )
        for (let P = 0; P < b.length; P++) {
          t.bindFramebuffer(n.FRAMEBUFFER, ee.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + P,
              n.RENDERBUFFER,
              ee.__webglColorRenderbuffer[P]
            );
          const ue = r.get(b[P]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, ee.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + P,
              n.TEXTURE_2D,
              ue,
              0
            );
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ee.__webglMultisampledFramebuffer);
    }
  }
  function Q(w) {
    return Math.min(f, w.samples);
  }
  function ce(w) {
    const b = r.get(w);
    return (
      o &&
      w.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      b.__useRenderToTexture !== !1
    );
  }
  function Ce(w) {
    const b = s.render.frame;
    g.get(w) !== b && (g.set(w, b), w.update());
  }
  function Ne(w, b) {
    const F = w.colorSpace,
      V = w.format,
      j = w.type;
    return (
      w.isCompressedTexture === !0 ||
        w.isVideoTexture === !0 ||
        w.format === hc ||
        (F !== Gn &&
          F !== ni &&
          (F === gt || F === Go
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && V === Ln
                ? ((w.format = hc),
                  (w.minFilter = wn),
                  (w.generateMipmaps = !1))
                : (b = Ip.sRGBToLinear(b))
              : (V !== Ln || j !== Nr) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                F
              ))),
      b
    );
  }
  (this.allocateTextureUnit = Z),
    (this.resetTextureUnits = k),
    (this.setTexture2D = ne),
    (this.setTexture2DArray = Y),
    (this.setTexture3D = W),
    (this.setTextureCube = te),
    (this.rebindTextures = _e),
    (this.setupRenderTarget = ge),
    (this.updateRenderTargetMipmap = Ue),
    (this.updateMultisampleRenderTarget = J),
    (this.setupDepthRenderbuffer = he),
    (this.setupFrameBufferTexture = Ee),
    (this.useMultisampledRTT = ce);
}
const tw = 0,
  Tt = 1;
function nw(n, e, t) {
  const r = t.isWebGL2;
  function i(a, s = ni) {
    let o;
    const c = s === gt || s === Go ? Tt : tw;
    if (a === Nr) return n.UNSIGNED_BYTE;
    if (a === Tp) return n.UNSIGNED_SHORT_4_4_4_4;
    if (a === Cp) return n.UNSIGNED_SHORT_5_5_5_1;
    if (a === bv) return n.BYTE;
    if (a === _v) return n.SHORT;
    if (a === Uc) return n.UNSIGNED_SHORT;
    if (a === Dp) return n.INT;
    if (a === Er) return n.UNSIGNED_INT;
    if (a === Sr) return n.FLOAT;
    if (a === ts)
      return r
        ? n.HALF_FLOAT
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (a === wv) return n.ALPHA;
    if (a === Ln) return n.RGBA;
    if (a === Ev) return n.LUMINANCE;
    if (a === Sv) return n.LUMINANCE_ALPHA;
    if (a === ei) return n.DEPTH_COMPONENT;
    if (a === ua) return n.DEPTH_STENCIL;
    if (a === hc)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (a === Mv) return n.RED;
    if (a === Np) return n.RED_INTEGER;
    if (a === Av) return n.RG;
    if (a === Rp) return n.RG_INTEGER;
    if (a === Fp) return n.RGBA_INTEGER;
    if (a === gu || a === vu || a === yu || a === xu)
      if (c === Tt)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (a === gu) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (a === vu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (a === yu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (a === xu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (a === gu) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (a === vu) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (a === yu) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (a === xu) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (a === Ol || a === Ul || a === Bl || a === zl)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (a === Ol) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (a === Ul) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (a === Bl) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (a === zl) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (a === Dv)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (a === kl || a === Hl)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (a === kl)
          return c === Tt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (a === Hl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      a === Gl ||
      a === Vl ||
      a === Wl ||
      a === ql ||
      a === $l ||
      a === jl ||
      a === Xl ||
      a === Yl ||
      a === Zl ||
      a === Jl ||
      a === Kl ||
      a === Ql ||
      a === ef ||
      a === tf
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (a === Gl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (a === Vl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (a === Wl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (a === ql)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (a === $l)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (a === jl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (a === Xl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (a === Yl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (a === Zl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (a === Jl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (a === Kl)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (a === Ql)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (a === ef)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (a === tf)
          return c === Tt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (a === bu || a === nf || a === rf)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (a === bu)
          return c === Tt
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (a === nf) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (a === rf) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (a === Tv || a === af || a === sf || a === of)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (a === bu) return o.COMPRESSED_RED_RGTC1_EXT;
        if (a === af) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (a === sf) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (a === of) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return a === Qr
      ? r
        ? n.UNSIGNED_INT_24_8
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : n[a] !== void 0
      ? n[a]
      : null;
  }
  return { convert: i };
}
class rw extends an {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ka extends st {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const iw = { type: "move" };
class Gu {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ka()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ka()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new B()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new B())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ka()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new B()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new B())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      a = null,
      s = null;
    const o = this._targetRay,
      c = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        s = !0;
        for (const x of e.hand.values()) {
          const m = t.getJointPose(x, r),
            p = this._getHandJoint(u, x);
          m !== null &&
            (p.matrix.fromArray(m.transform.matrix),
            p.matrix.decompose(p.position, p.rotation, p.scale),
            (p.matrixWorldNeedsUpdate = !0),
            (p.jointRadius = m.radius)),
            (p.visible = m !== null);
        }
        const l = u.joints["index-finger-tip"],
          f = u.joints["thumb-tip"],
          h = l.position.distanceTo(f.position),
          d = 0.02,
          g = 0.005;
        u.inputState.pinching && h > d + g
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            h <= d - g &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        c !== null &&
          e.gripSpace &&
          ((a = t.getPose(e.gripSpace, r)),
          a !== null &&
            (c.matrix.fromArray(a.transform.matrix),
            c.matrix.decompose(c.position, c.rotation, c.scale),
            (c.matrixWorldNeedsUpdate = !0),
            a.linearVelocity
              ? ((c.hasLinearVelocity = !0),
                c.linearVelocity.copy(a.linearVelocity))
              : (c.hasLinearVelocity = !1),
            a.angularVelocity
              ? ((c.hasAngularVelocity = !0),
                c.angularVelocity.copy(a.angularVelocity))
              : (c.hasAngularVelocity = !1)));
      o !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && a !== null && (i = a),
        i !== null &&
          (o.matrix.fromArray(i.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(i.linearVelocity))
            : (o.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(i.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(iw)));
    }
    return (
      o !== null && (o.visible = i !== null),
      c !== null && (c.visible = a !== null),
      u !== null && (u.visible = s !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new ka();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
class aw extends sn {
  constructor(e, t, r, i, a, s, o, c, u, l) {
    if (((l = l !== void 0 ? l : ei), l !== ei && l !== ua))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && l === ei && (r = Er),
      r === void 0 && l === ua && (r = Qr),
      super(null, i, a, s, o, c, l, r, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = o !== void 0 ? o : Qt),
      (this.minFilter = c !== void 0 ? c : Qt),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class sw extends ci {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      a = 1,
      s = null,
      o = "local-floor",
      c = 1,
      u = null,
      l = null,
      f = null,
      h = null,
      d = null,
      g = null;
    const x = t.getContextAttributes();
    let m = null,
      p = null;
    const S = [],
      v = [],
      y = new an();
    y.layers.enable(1), (y.viewport = new xt());
    const E = new an();
    E.layers.enable(2), (E.viewport = new xt());
    const M = [y, E],
      T = new rw();
    T.layers.enable(1), T.layers.enable(2);
    let N = null,
      A = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Y) {
        let W = S[Y];
        return (
          W === void 0 && ((W = new Gu()), (S[Y] = W)), W.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (Y) {
        let W = S[Y];
        return W === void 0 && ((W = new Gu()), (S[Y] = W)), W.getGripSpace();
      }),
      (this.getHand = function (Y) {
        let W = S[Y];
        return W === void 0 && ((W = new Gu()), (S[Y] = W)), W.getHandSpace();
      });
    function D(Y) {
      const W = v.indexOf(Y.inputSource);
      if (W === -1) return;
      const te = S[W];
      te !== void 0 &&
        (te.update(Y.inputSource, Y.frame, u || s),
        te.dispatchEvent({ type: Y.type, data: Y.inputSource }));
    }
    function z() {
      i.removeEventListener("select", D),
        i.removeEventListener("selectstart", D),
        i.removeEventListener("selectend", D),
        i.removeEventListener("squeeze", D),
        i.removeEventListener("squeezestart", D),
        i.removeEventListener("squeezeend", D),
        i.removeEventListener("end", z),
        i.removeEventListener("inputsourceschange", $);
      for (let Y = 0; Y < S.length; Y++) {
        const W = v[Y];
        W !== null && ((v[Y] = null), S[Y].disconnect(W));
      }
      (N = null),
        (A = null),
        e.setRenderTarget(m),
        (d = null),
        (h = null),
        (f = null),
        (i = null),
        (p = null),
        ne.stop(),
        (r.isPresenting = !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (Y) {
      (a = Y),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (Y) {
        (o = Y),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return u || s;
      }),
      (this.setReferenceSpace = function (Y) {
        u = Y;
      }),
      (this.getBaseLayer = function () {
        return h !== null ? h : d;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return g;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (Y) {
        if (((i = Y), i !== null)) {
          if (
            ((m = e.getRenderTarget()),
            i.addEventListener("select", D),
            i.addEventListener("selectstart", D),
            i.addEventListener("selectend", D),
            i.addEventListener("squeeze", D),
            i.addEventListener("squeezestart", D),
            i.addEventListener("squeezeend", D),
            i.addEventListener("end", z),
            i.addEventListener("inputsourceschange", $),
            x.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const W = {
              antialias: i.renderState.layers === void 0 ? x.antialias : !0,
              alpha: !0,
              depth: x.depth,
              stencil: x.stencil,
              framebufferScaleFactor: a,
            };
            (d = new XRWebGLLayer(i, t, W)),
              i.updateRenderState({ baseLayer: d }),
              (p = new ri(d.framebufferWidth, d.framebufferHeight, {
                format: Ln,
                type: Nr,
                colorSpace: e.outputColorSpace,
                stencilBuffer: x.stencil,
              }));
          } else {
            let W = null,
              te = null,
              ve = null;
            x.depth &&
              ((ve = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (W = x.stencil ? ua : ei),
              (te = x.stencil ? Qr : Er));
            const be = {
              colorFormat: t.RGBA8,
              depthFormat: ve,
              scaleFactor: a,
            };
            (f = new XRWebGLBinding(i, t)),
              (h = f.createProjectionLayer(be)),
              i.updateRenderState({ layers: [h] }),
              (p = new ri(h.textureWidth, h.textureHeight, {
                format: Ln,
                type: Nr,
                depthTexture: new aw(
                  h.textureWidth,
                  h.textureHeight,
                  te,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  W
                ),
                stencilBuffer: x.stencil,
                colorSpace: e.outputColorSpace,
                samples: x.antialias ? 4 : 0,
              }));
            const Ae = e.properties.get(p);
            Ae.__ignoreDepthValues = h.ignoreDepthValues;
          }
          (p.isXRRenderTarget = !0),
            this.setFoveation(c),
            (u = null),
            (s = await i.requestReferenceSpace(o)),
            ne.setContext(i),
            ne.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function $(Y) {
      for (let W = 0; W < Y.removed.length; W++) {
        const te = Y.removed[W],
          ve = v.indexOf(te);
        ve >= 0 && ((v[ve] = null), S[ve].disconnect(te));
      }
      for (let W = 0; W < Y.added.length; W++) {
        const te = Y.added[W];
        let ve = v.indexOf(te);
        if (ve === -1) {
          for (let Ae = 0; Ae < S.length; Ae++)
            if (Ae >= v.length) {
              v.push(te), (ve = Ae);
              break;
            } else if (v[Ae] === null) {
              (v[Ae] = te), (ve = Ae);
              break;
            }
          if (ve === -1) break;
        }
        const be = S[ve];
        be && be.connect(te);
      }
    }
    const I = new B(),
      G = new B();
    function L(Y, W, te) {
      I.setFromMatrixPosition(W.matrixWorld),
        G.setFromMatrixPosition(te.matrixWorld);
      const ve = I.distanceTo(G),
        be = W.projectionMatrix.elements,
        Ae = te.projectionMatrix.elements,
        Fe = be[14] / (be[10] - 1),
        Pe = be[14] / (be[10] + 1),
        Te = (be[9] + 1) / be[5],
        ze = (be[9] - 1) / be[5],
        Ee = (be[8] - 1) / be[0],
        H = (Ae[8] + 1) / Ae[0],
        we = Fe * Ee,
        he = Fe * H,
        _e = ve / (-Ee + H),
        ge = _e * -Ee;
      W.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale),
        Y.translateX(ge),
        Y.translateZ(_e),
        Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale),
        Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
      const Ue = Fe + _e,
        J = Pe + _e,
        Q = we - ge,
        ce = he + (ve - ge),
        Ce = ((Te * Pe) / J) * Ue,
        Ne = ((ze * Pe) / J) * Ue;
      Y.projectionMatrix.makePerspective(Q, ce, Ce, Ne, Ue, J),
        Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert();
    }
    function C(Y, W) {
      W === null
        ? Y.matrixWorld.copy(Y.matrix)
        : Y.matrixWorld.multiplyMatrices(W.matrixWorld, Y.matrix),
        Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
    }
    this.updateCamera = function (Y) {
      if (i === null) return;
      (T.near = E.near = y.near = Y.near),
        (T.far = E.far = y.far = Y.far),
        (N !== T.near || A !== T.far) &&
          (i.updateRenderState({ depthNear: T.near, depthFar: T.far }),
          (N = T.near),
          (A = T.far));
      const W = Y.parent,
        te = T.cameras;
      C(T, W);
      for (let ve = 0; ve < te.length; ve++) C(te[ve], W);
      te.length === 2
        ? L(T, y, E)
        : T.projectionMatrix.copy(y.projectionMatrix),
        k(Y, T, W);
    };
    function k(Y, W, te) {
      te === null
        ? Y.matrix.copy(W.matrixWorld)
        : (Y.matrix.copy(te.matrixWorld),
          Y.matrix.invert(),
          Y.matrix.multiply(W.matrixWorld)),
        Y.matrix.decompose(Y.position, Y.quaternion, Y.scale),
        Y.updateMatrixWorld(!0),
        Y.projectionMatrix.copy(W.projectionMatrix),
        Y.projectionMatrixInverse.copy(W.projectionMatrixInverse),
        Y.isPerspectiveCamera &&
          ((Y.fov = ns * 2 * Math.atan(1 / Y.projectionMatrix.elements[5])),
          (Y.zoom = 1));
    }
    (this.getCamera = function () {
      return T;
    }),
      (this.getFoveation = function () {
        if (!(h === null && d === null)) return c;
      }),
      (this.setFoveation = function (Y) {
        (c = Y),
          h !== null && (h.fixedFoveation = Y),
          d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = Y);
      });
    let Z = null;
    function ie(Y, W) {
      if (((l = W.getViewerPose(u || s)), (g = W), l !== null)) {
        const te = l.views;
        d !== null &&
          (e.setRenderTargetFramebuffer(p, d.framebuffer),
          e.setRenderTarget(p));
        let ve = !1;
        te.length !== T.cameras.length && ((T.cameras.length = 0), (ve = !0));
        for (let be = 0; be < te.length; be++) {
          const Ae = te[be];
          let Fe = null;
          if (d !== null) Fe = d.getViewport(Ae);
          else {
            const Te = f.getViewSubImage(h, Ae);
            (Fe = Te.viewport),
              be === 0 &&
                (e.setRenderTargetTextures(
                  p,
                  Te.colorTexture,
                  h.ignoreDepthValues ? void 0 : Te.depthStencilTexture
                ),
                e.setRenderTarget(p));
          }
          let Pe = M[be];
          Pe === void 0 &&
            ((Pe = new an()),
            Pe.layers.enable(be),
            (Pe.viewport = new xt()),
            (M[be] = Pe)),
            Pe.matrix.fromArray(Ae.transform.matrix),
            Pe.matrix.decompose(Pe.position, Pe.quaternion, Pe.scale),
            Pe.projectionMatrix.fromArray(Ae.projectionMatrix),
            Pe.projectionMatrixInverse.copy(Pe.projectionMatrix).invert(),
            Pe.viewport.set(Fe.x, Fe.y, Fe.width, Fe.height),
            be === 0 &&
              (T.matrix.copy(Pe.matrix),
              T.matrix.decompose(T.position, T.quaternion, T.scale)),
            ve === !0 && T.cameras.push(Pe);
        }
      }
      for (let te = 0; te < S.length; te++) {
        const ve = v[te],
          be = S[te];
        ve !== null && be !== void 0 && be.update(ve, W, u || s);
      }
      Z && Z(Y, W),
        W.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: W }),
        (g = null);
    }
    const ne = new Wp();
    ne.setAnimationLoop(ie),
      (this.setAnimationLoop = function (Y) {
        Z = Y;
      }),
      (this.dispose = function () {});
  }
}
function ow(n, e) {
  function t(m, p) {
    m.matrixAutoUpdate === !0 && m.updateMatrix(), p.value.copy(m.matrix);
  }
  function r(m, p) {
    p.color.getRGB(m.fogColor.value, Hp(n)),
      p.isFog
        ? ((m.fogNear.value = p.near), (m.fogFar.value = p.far))
        : p.isFogExp2 && (m.fogDensity.value = p.density);
  }
  function i(m, p, S, v, y) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial
      ? a(m, p)
      : p.isMeshToonMaterial
      ? (a(m, p), f(m, p))
      : p.isMeshPhongMaterial
      ? (a(m, p), l(m, p))
      : p.isMeshStandardMaterial
      ? (a(m, p), h(m, p), p.isMeshPhysicalMaterial && d(m, p, y))
      : p.isMeshMatcapMaterial
      ? (a(m, p), g(m, p))
      : p.isMeshDepthMaterial
      ? a(m, p)
      : p.isMeshDistanceMaterial
      ? (a(m, p), x(m, p))
      : p.isMeshNormalMaterial
      ? a(m, p)
      : p.isLineBasicMaterial
      ? (s(m, p), p.isLineDashedMaterial && o(m, p))
      : p.isPointsMaterial
      ? c(m, p, S, v)
      : p.isSpriteMaterial
      ? u(m, p)
      : p.isShadowMaterial
      ? (m.color.value.copy(p.color), (m.opacity.value = p.opacity))
      : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function a(m, p) {
    (m.opacity.value = p.opacity),
      p.color && m.diffuse.value.copy(p.color),
      p.emissive &&
        m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
      p.map && ((m.map.value = p.map), t(p.map, m.mapTransform)),
      p.alphaMap &&
        ((m.alphaMap.value = p.alphaMap), t(p.alphaMap, m.alphaMapTransform)),
      p.bumpMap &&
        ((m.bumpMap.value = p.bumpMap),
        t(p.bumpMap, m.bumpMapTransform),
        (m.bumpScale.value = p.bumpScale),
        p.side === en && (m.bumpScale.value *= -1)),
      p.normalMap &&
        ((m.normalMap.value = p.normalMap),
        t(p.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(p.normalScale),
        p.side === en && m.normalScale.value.negate()),
      p.displacementMap &&
        ((m.displacementMap.value = p.displacementMap),
        t(p.displacementMap, m.displacementMapTransform),
        (m.displacementScale.value = p.displacementScale),
        (m.displacementBias.value = p.displacementBias)),
      p.emissiveMap &&
        ((m.emissiveMap.value = p.emissiveMap),
        t(p.emissiveMap, m.emissiveMapTransform)),
      p.specularMap &&
        ((m.specularMap.value = p.specularMap),
        t(p.specularMap, m.specularMapTransform)),
      p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
    const S = e.get(p).envMap;
    if (
      (S &&
        ((m.envMap.value = S),
        (m.flipEnvMap.value =
          S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
        (m.reflectivity.value = p.reflectivity),
        (m.ior.value = p.ior),
        (m.refractionRatio.value = p.refractionRatio)),
      p.lightMap)
    ) {
      m.lightMap.value = p.lightMap;
      const v = n._useLegacyLights === !0 ? Math.PI : 1;
      (m.lightMapIntensity.value = p.lightMapIntensity * v),
        t(p.lightMap, m.lightMapTransform);
    }
    p.aoMap &&
      ((m.aoMap.value = p.aoMap),
      (m.aoMapIntensity.value = p.aoMapIntensity),
      t(p.aoMap, m.aoMapTransform));
  }
  function s(m, p) {
    m.diffuse.value.copy(p.color),
      (m.opacity.value = p.opacity),
      p.map && ((m.map.value = p.map), t(p.map, m.mapTransform));
  }
  function o(m, p) {
    (m.dashSize.value = p.dashSize),
      (m.totalSize.value = p.dashSize + p.gapSize),
      (m.scale.value = p.scale);
  }
  function c(m, p, S, v) {
    m.diffuse.value.copy(p.color),
      (m.opacity.value = p.opacity),
      (m.size.value = p.size * S),
      (m.scale.value = v * 0.5),
      p.map && ((m.map.value = p.map), t(p.map, m.uvTransform)),
      p.alphaMap &&
        ((m.alphaMap.value = p.alphaMap), t(p.alphaMap, m.alphaMapTransform)),
      p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
  }
  function u(m, p) {
    m.diffuse.value.copy(p.color),
      (m.opacity.value = p.opacity),
      (m.rotation.value = p.rotation),
      p.map && ((m.map.value = p.map), t(p.map, m.mapTransform)),
      p.alphaMap &&
        ((m.alphaMap.value = p.alphaMap), t(p.alphaMap, m.alphaMapTransform)),
      p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
  }
  function l(m, p) {
    m.specular.value.copy(p.specular),
      (m.shininess.value = Math.max(p.shininess, 1e-4));
  }
  function f(m, p) {
    p.gradientMap && (m.gradientMap.value = p.gradientMap);
  }
  function h(m, p) {
    (m.metalness.value = p.metalness),
      p.metalnessMap &&
        ((m.metalnessMap.value = p.metalnessMap),
        t(p.metalnessMap, m.metalnessMapTransform)),
      (m.roughness.value = p.roughness),
      p.roughnessMap &&
        ((m.roughnessMap.value = p.roughnessMap),
        t(p.roughnessMap, m.roughnessMapTransform)),
      e.get(p).envMap && (m.envMapIntensity.value = p.envMapIntensity);
  }
  function d(m, p, S) {
    (m.ior.value = p.ior),
      p.sheen > 0 &&
        (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        (m.sheenRoughness.value = p.sheenRoughness),
        p.sheenColorMap &&
          ((m.sheenColorMap.value = p.sheenColorMap),
          t(p.sheenColorMap, m.sheenColorMapTransform)),
        p.sheenRoughnessMap &&
          ((m.sheenRoughnessMap.value = p.sheenRoughnessMap),
          t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
      p.clearcoat > 0 &&
        ((m.clearcoat.value = p.clearcoat),
        (m.clearcoatRoughness.value = p.clearcoatRoughness),
        p.clearcoatMap &&
          ((m.clearcoatMap.value = p.clearcoatMap),
          t(p.clearcoatMap, m.clearcoatMapTransform)),
        p.clearcoatRoughnessMap &&
          ((m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
          t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap &&
          ((m.clearcoatNormalMap.value = p.clearcoatNormalMap),
          t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform),
          m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
          p.side === en && m.clearcoatNormalScale.value.negate())),
      p.iridescence > 0 &&
        ((m.iridescence.value = p.iridescence),
        (m.iridescenceIOR.value = p.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1]),
        p.iridescenceMap &&
          ((m.iridescenceMap.value = p.iridescenceMap),
          t(p.iridescenceMap, m.iridescenceMapTransform)),
        p.iridescenceThicknessMap &&
          ((m.iridescenceThicknessMap.value = p.iridescenceThicknessMap),
          t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
      p.transmission > 0 &&
        ((m.transmission.value = p.transmission),
        (m.transmissionSamplerMap.value = S.texture),
        m.transmissionSamplerSize.value.set(S.width, S.height),
        p.transmissionMap &&
          ((m.transmissionMap.value = p.transmissionMap),
          t(p.transmissionMap, m.transmissionMapTransform)),
        (m.thickness.value = p.thickness),
        p.thicknessMap &&
          ((m.thicknessMap.value = p.thicknessMap),
          t(p.thicknessMap, m.thicknessMapTransform)),
        (m.attenuationDistance.value = p.attenuationDistance),
        m.attenuationColor.value.copy(p.attenuationColor)),
      p.anisotropy > 0 &&
        (m.anisotropyVector.value.set(
          p.anisotropy * Math.cos(p.anisotropyRotation),
          p.anisotropy * Math.sin(p.anisotropyRotation)
        ),
        p.anisotropyMap &&
          ((m.anisotropyMap.value = p.anisotropyMap),
          t(p.anisotropyMap, m.anisotropyMapTransform))),
      (m.specularIntensity.value = p.specularIntensity),
      m.specularColor.value.copy(p.specularColor),
      p.specularColorMap &&
        ((m.specularColorMap.value = p.specularColorMap),
        t(p.specularColorMap, m.specularColorMapTransform)),
      p.specularIntensityMap &&
        ((m.specularIntensityMap.value = p.specularIntensityMap),
        t(p.specularIntensityMap, m.specularIntensityMapTransform));
  }
  function g(m, p) {
    p.matcap && (m.matcap.value = p.matcap);
  }
  function x(m, p) {
    const S = e.get(p).light;
    m.referencePosition.value.setFromMatrixPosition(S.matrixWorld),
      (m.nearDistance.value = S.shadow.camera.near),
      (m.farDistance.value = S.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function uw(n, e, t, r) {
  let i = {},
    a = {},
    s = [];
  const o = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function c(S, v) {
    const y = v.program;
    r.uniformBlockBinding(S, y);
  }
  function u(S, v) {
    let y = i[S.id];
    y === void 0 &&
      (g(S), (y = l(S)), (i[S.id] = y), S.addEventListener("dispose", m));
    const E = v.program;
    r.updateUBOMapping(S, E);
    const M = e.render.frame;
    a[S.id] !== M && (h(S), (a[S.id] = M));
  }
  function l(S) {
    const v = f();
    S.__bindingPointIndex = v;
    const y = n.createBuffer(),
      E = S.__size,
      M = S.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, y),
      n.bufferData(n.UNIFORM_BUFFER, E, M),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, v, y),
      y
    );
  }
  function f() {
    for (let S = 0; S < o; S++) if (s.indexOf(S) === -1) return s.push(S), S;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function h(S) {
    const v = i[S.id],
      y = S.uniforms,
      E = S.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, v);
    for (let M = 0, T = y.length; M < T; M++) {
      const N = y[M];
      if (d(N, M, E) === !0) {
        const A = N.__offset,
          D = Array.isArray(N.value) ? N.value : [N.value];
        let z = 0;
        for (let $ = 0; $ < D.length; $++) {
          const I = D[$],
            G = x(I);
          typeof I == "number"
            ? ((N.__data[0] = I),
              n.bufferSubData(n.UNIFORM_BUFFER, A + z, N.__data))
            : I.isMatrix3
            ? ((N.__data[0] = I.elements[0]),
              (N.__data[1] = I.elements[1]),
              (N.__data[2] = I.elements[2]),
              (N.__data[3] = I.elements[0]),
              (N.__data[4] = I.elements[3]),
              (N.__data[5] = I.elements[4]),
              (N.__data[6] = I.elements[5]),
              (N.__data[7] = I.elements[0]),
              (N.__data[8] = I.elements[6]),
              (N.__data[9] = I.elements[7]),
              (N.__data[10] = I.elements[8]),
              (N.__data[11] = I.elements[0]))
            : (I.toArray(N.__data, z),
              (z += G.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(n.UNIFORM_BUFFER, A, N.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function d(S, v, y) {
    const E = S.value;
    if (y[v] === void 0) {
      if (typeof E == "number") y[v] = E;
      else {
        const M = Array.isArray(E) ? E : [E],
          T = [];
        for (let N = 0; N < M.length; N++) T.push(M[N].clone());
        y[v] = T;
      }
      return !0;
    } else if (typeof E == "number") {
      if (y[v] !== E) return (y[v] = E), !0;
    } else {
      const M = Array.isArray(y[v]) ? y[v] : [y[v]],
        T = Array.isArray(E) ? E : [E];
      for (let N = 0; N < M.length; N++) {
        const A = M[N];
        if (A.equals(T[N]) === !1) return A.copy(T[N]), !0;
      }
    }
    return !1;
  }
  function g(S) {
    const v = S.uniforms;
    let y = 0;
    const E = 16;
    let M = 0;
    for (let T = 0, N = v.length; T < N; T++) {
      const A = v[T],
        D = { boundary: 0, storage: 0 },
        z = Array.isArray(A.value) ? A.value : [A.value];
      for (let $ = 0, I = z.length; $ < I; $++) {
        const G = z[$],
          L = x(G);
        (D.boundary += L.boundary), (D.storage += L.storage);
      }
      if (
        ((A.__data = new Float32Array(
          D.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (A.__offset = y),
        T > 0)
      ) {
        M = y % E;
        const $ = E - M;
        M !== 0 && $ - D.boundary < 0 && ((y += E - M), (A.__offset = y));
      }
      y += D.storage;
    }
    return (
      (M = y % E), M > 0 && (y += E - M), (S.__size = y), (S.__cache = {}), this
    );
  }
  function x(S) {
    const v = { boundary: 0, storage: 0 };
    return (
      typeof S == "number"
        ? ((v.boundary = 4), (v.storage = 4))
        : S.isVector2
        ? ((v.boundary = 8), (v.storage = 8))
        : S.isVector3 || S.isColor
        ? ((v.boundary = 16), (v.storage = 12))
        : S.isVector4
        ? ((v.boundary = 16), (v.storage = 16))
        : S.isMatrix3
        ? ((v.boundary = 48), (v.storage = 48))
        : S.isMatrix4
        ? ((v.boundary = 64), (v.storage = 64))
        : S.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            S
          ),
      v
    );
  }
  function m(S) {
    const v = S.target;
    v.removeEventListener("dispose", m);
    const y = s.indexOf(v.__bindingPointIndex);
    s.splice(y, 1), n.deleteBuffer(i[v.id]), delete i[v.id], delete a[v.id];
  }
  function p() {
    for (const S in i) n.deleteBuffer(i[S]);
    (s = []), (i = {}), (a = {});
  }
  return { bind: c, update: u, dispose: p };
}
class Vc {
  constructor(e = {}) {
    const {
      canvas: t = ty(),
      context: r = null,
      depth: i = !0,
      stencil: a = !0,
      alpha: s = !1,
      antialias: o = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: l = "default",
      failIfMajorPerformanceCaveat: f = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let h;
    r !== null ? (h = r.getContextAttributes().alpha) : (h = s);
    const d = new Uint32Array(4),
      g = new Int32Array(4);
    let x = null,
      m = null;
    const p = [],
      S = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = gt),
      (this._useLegacyLights = !1),
      (this.toneMapping = Cr),
      (this.toneMappingExposure = 1);
    const v = this;
    let y = !1,
      E = 0,
      M = 0,
      T = null,
      N = -1,
      A = null;
    const D = new xt(),
      z = new xt();
    let $ = null;
    const I = new tt(0);
    let G = 0,
      L = t.width,
      C = t.height,
      k = 1,
      Z = null,
      ie = null;
    const ne = new xt(0, 0, L, C),
      Y = new xt(0, 0, L, C);
    let W = !1;
    const te = new Hc();
    let ve = !1,
      be = !1,
      Ae = null;
    const Fe = new ut(),
      Pe = new De(),
      Te = new B(),
      ze = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ee() {
      return T === null ? k : 1;
    }
    let H = r;
    function we(O, ae) {
      for (let de = 0; de < O.length; de++) {
        const se = O[de],
          pe = t.getContext(se, ae);
        if (pe !== null) return pe;
      }
      return null;
    }
    try {
      const O = {
        alpha: !0,
        depth: i,
        stencil: a,
        antialias: o,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: l,
        failIfMajorPerformanceCaveat: f,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Ic}`),
        t.addEventListener("webglcontextlost", re, !1),
        t.addEventListener("webglcontextrestored", K, !1),
        t.addEventListener("webglcontextcreationerror", le, !1),
        H === null)
      ) {
        const ae = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (v.isWebGL1Renderer === !0 && ae.shift(), (H = we(ae, O)), H === null)
        )
          throw we(ae)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        H instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        H.getShaderPrecisionFormat === void 0 &&
          (H.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (O) {
      throw (console.error("THREE.WebGLRenderer: " + O.message), O);
    }
    let he,
      _e,
      ge,
      Ue,
      J,
      Q,
      ce,
      Ce,
      Ne,
      w,
      b,
      F,
      V,
      j,
      X,
      oe,
      ee,
      q,
      P,
      ue,
      ye,
      fe,
      Me,
      _;
    function U() {
      (he = new yb(H)),
        (_e = new hb(H, he, e)),
        he.init(_e),
        (fe = new nw(H, he, _e)),
        (ge = new Q_(H, he, _e)),
        (Ue = new _b(H)),
        (J = new z_()),
        (Q = new ew(H, he, ge, J, _e, fe, Ue)),
        (ce = new pb(v)),
        (Ce = new vb(v)),
        (Ne = new Ry(H, _e)),
        (Me = new lb(H, he, Ne, _e)),
        (w = new xb(H, Ne, Ue, Me)),
        (b = new Mb(H, w, Ne, Ue)),
        (P = new Sb(H, _e, Q)),
        (oe = new db(J)),
        (F = new B_(v, ce, Ce, he, _e, Me, oe)),
        (V = new ow(v, J)),
        (j = new H_()),
        (X = new j_(he, _e)),
        (q = new cb(v, ce, Ce, ge, b, h, c)),
        (ee = new K_(v, b, _e)),
        (_ = new uw(H, Ue, _e, ge)),
        (ue = new fb(H, he, Ue, _e)),
        (ye = new bb(H, he, Ue, _e)),
        (Ue.programs = F.programs),
        (v.capabilities = _e),
        (v.extensions = he),
        (v.properties = J),
        (v.renderLists = j),
        (v.shadowMap = ee),
        (v.state = ge),
        (v.info = Ue);
    }
    U();
    const R = new sw(v, H);
    (this.xr = R),
      (this.getContext = function () {
        return H;
      }),
      (this.getContextAttributes = function () {
        return H.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const O = he.get("WEBGL_lose_context");
        O && O.loseContext();
      }),
      (this.forceContextRestore = function () {
        const O = he.get("WEBGL_lose_context");
        O && O.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return k;
      }),
      (this.setPixelRatio = function (O) {
        O !== void 0 && ((k = O), this.setSize(L, C, !1));
      }),
      (this.getSize = function (O) {
        return O.set(L, C);
      }),
      (this.setSize = function (O, ae, de = !0) {
        if (R.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (L = O),
          (C = ae),
          (t.width = Math.floor(O * k)),
          (t.height = Math.floor(ae * k)),
          de === !0 &&
            ((t.style.width = O + "px"), (t.style.height = ae + "px")),
          this.setViewport(0, 0, O, ae);
      }),
      (this.getDrawingBufferSize = function (O) {
        return O.set(L * k, C * k).floor();
      }),
      (this.setDrawingBufferSize = function (O, ae, de) {
        (L = O),
          (C = ae),
          (k = de),
          (t.width = Math.floor(O * de)),
          (t.height = Math.floor(ae * de)),
          this.setViewport(0, 0, O, ae);
      }),
      (this.getCurrentViewport = function (O) {
        return O.copy(D);
      }),
      (this.getViewport = function (O) {
        return O.copy(ne);
      }),
      (this.setViewport = function (O, ae, de, se) {
        O.isVector4 ? ne.set(O.x, O.y, O.z, O.w) : ne.set(O, ae, de, se),
          ge.viewport(D.copy(ne).multiplyScalar(k).floor());
      }),
      (this.getScissor = function (O) {
        return O.copy(Y);
      }),
      (this.setScissor = function (O, ae, de, se) {
        O.isVector4 ? Y.set(O.x, O.y, O.z, O.w) : Y.set(O, ae, de, se),
          ge.scissor(z.copy(Y).multiplyScalar(k).floor());
      }),
      (this.getScissorTest = function () {
        return W;
      }),
      (this.setScissorTest = function (O) {
        ge.setScissorTest((W = O));
      }),
      (this.setOpaqueSort = function (O) {
        Z = O;
      }),
      (this.setTransparentSort = function (O) {
        ie = O;
      }),
      (this.getClearColor = function (O) {
        return O.copy(q.getClearColor());
      }),
      (this.setClearColor = function () {
        q.setClearColor.apply(q, arguments);
      }),
      (this.getClearAlpha = function () {
        return q.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        q.setClearAlpha.apply(q, arguments);
      }),
      (this.clear = function (O = !0, ae = !0, de = !0) {
        let se = 0;
        if (O) {
          let pe = !1;
          if (T !== null) {
            const Be = T.texture.format;
            pe = Be === Fp || Be === Rp || Be === Np;
          }
          if (pe) {
            const Be = T.texture.type,
              Ge =
                Be === Nr ||
                Be === Er ||
                Be === Uc ||
                Be === Qr ||
                Be === Tp ||
                Be === Cp,
              qe = q.getClearColor(),
              $e = q.getClearAlpha(),
              Xe = qe.r,
              Ie = qe.g,
              He = qe.b;
            Ge
              ? ((d[0] = Xe),
                (d[1] = Ie),
                (d[2] = He),
                (d[3] = $e),
                H.clearBufferuiv(H.COLOR, 0, d))
              : ((g[0] = Xe),
                (g[1] = Ie),
                (g[2] = He),
                (g[3] = $e),
                H.clearBufferiv(H.COLOR, 0, g));
          } else se |= H.COLOR_BUFFER_BIT;
        }
        ae && (se |= H.DEPTH_BUFFER_BIT),
          de && (se |= H.STENCIL_BUFFER_BIT),
          H.clear(se);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", re, !1),
          t.removeEventListener("webglcontextrestored", K, !1),
          t.removeEventListener("webglcontextcreationerror", le, !1),
          j.dispose(),
          X.dispose(),
          J.dispose(),
          ce.dispose(),
          Ce.dispose(),
          b.dispose(),
          Me.dispose(),
          _.dispose(),
          F.dispose(),
          R.dispose(),
          R.removeEventListener("sessionstart", lt),
          R.removeEventListener("sessionend", vn),
          Ae && (Ae.dispose(), (Ae = null)),
          zt.stop();
      });
    function re(O) {
      O.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (y = !0);
    }
    function K() {
      console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
      const O = Ue.autoReset,
        ae = ee.enabled,
        de = ee.autoUpdate,
        se = ee.needsUpdate,
        pe = ee.type;
      U(),
        (Ue.autoReset = O),
        (ee.enabled = ae),
        (ee.autoUpdate = de),
        (ee.needsUpdate = se),
        (ee.type = pe);
    }
    function le(O) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        O.statusMessage
      );
    }
    function Se(O) {
      const ae = O.target;
      ae.removeEventListener("dispose", Se), Ye(ae);
    }
    function Ye(O) {
      it(O), J.remove(O);
    }
    function it(O) {
      const ae = J.get(O).programs;
      ae !== void 0 &&
        (ae.forEach(function (de) {
          F.releaseProgram(de);
        }),
        O.isShaderMaterial && F.releaseShaderCache(O));
    }
    (this.renderBufferDirect = function (O, ae, de, se, pe, Be) {
      ae === null && (ae = ze);
      const Ge = pe.isMesh && pe.matrixWorld.determinant() < 0,
        qe = ou(O, ae, de, se, pe);
      ge.setMaterial(se, Ge);
      let $e = de.index,
        Xe = 1;
      if (se.wireframe === !0) {
        if ((($e = w.getWireframeAttribute(de)), $e === void 0)) return;
        Xe = 2;
      }
      const Ie = de.drawRange,
        He = de.attributes.position;
      let vt = Ie.start * Xe,
        pt = (Ie.start + Ie.count) * Xe;
      Be !== null &&
        ((vt = Math.max(vt, Be.start * Xe)),
        (pt = Math.min(pt, (Be.start + Be.count) * Xe))),
        $e !== null
          ? ((vt = Math.max(vt, 0)), (pt = Math.min(pt, $e.count)))
          : He != null &&
            ((vt = Math.max(vt, 0)), (pt = Math.min(pt, He.count)));
      const Lt = pt - vt;
      if (Lt < 0 || Lt === 1 / 0) return;
      Me.setup(pe, se, qe, de, $e);
      let An,
        St = ue;
      if (
        ($e !== null && ((An = Ne.get($e)), (St = ye), St.setIndex(An)),
        pe.isMesh)
      )
        se.wireframe === !0
          ? (ge.setLineWidth(se.wireframeLinewidth * Ee()), St.setMode(H.LINES))
          : St.setMode(H.TRIANGLES);
      else if (pe.isLine) {
        let Ke = se.linewidth;
        Ke === void 0 && (Ke = 1),
          ge.setLineWidth(Ke * Ee()),
          pe.isLineSegments
            ? St.setMode(H.LINES)
            : pe.isLineLoop
            ? St.setMode(H.LINE_LOOP)
            : St.setMode(H.LINE_STRIP);
      } else
        pe.isPoints
          ? St.setMode(H.POINTS)
          : pe.isSprite && St.setMode(H.TRIANGLES);
      if (pe.isInstancedMesh) St.renderInstances(vt, Lt, pe.count);
      else if (de.isInstancedBufferGeometry) {
        const Ke =
            de._maxInstanceCount !== void 0 ? de._maxInstanceCount : 1 / 0,
          lu = Math.min(de.instanceCount, Ke);
        St.renderInstances(vt, Lt, lu);
      } else St.render(vt, Lt);
    }),
      (this.compile = function (O, ae) {
        function de(se, pe, Be) {
          se.transparent === !0 && se.side === jt && se.forceSinglePass === !1
            ? ((se.side = en),
              (se.needsUpdate = !0),
              xi(se, pe, Be),
              (se.side = lr),
              (se.needsUpdate = !0),
              xi(se, pe, Be),
              (se.side = jt))
            : xi(se, pe, Be);
        }
        (m = X.get(O)),
          m.init(),
          S.push(m),
          O.traverseVisible(function (se) {
            se.isLight &&
              se.layers.test(ae.layers) &&
              (m.pushLight(se), se.castShadow && m.pushShadow(se));
          }),
          m.setupLights(v._useLegacyLights),
          O.traverse(function (se) {
            const pe = se.material;
            if (pe)
              if (Array.isArray(pe))
                for (let Be = 0; Be < pe.length; Be++) {
                  const Ge = pe[Be];
                  de(Ge, O, se);
                }
              else de(pe, O, se);
          }),
          S.pop(),
          (m = null);
      });
    let ct = null;
    function Yt(O) {
      ct && ct(O);
    }
    function lt() {
      zt.stop();
    }
    function vn() {
      zt.start();
    }
    const zt = new Wp();
    zt.setAnimationLoop(Yt),
      typeof self < "u" && zt.setContext(self),
      (this.setAnimationLoop = function (O) {
        (ct = O), R.setAnimationLoop(O), O === null ? zt.stop() : zt.start();
      }),
      R.addEventListener("sessionstart", lt),
      R.addEventListener("sessionend", vn),
      (this.render = function (O, ae) {
        if (ae !== void 0 && ae.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (y === !0) return;
        O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(),
          ae.parent === null &&
            ae.matrixWorldAutoUpdate === !0 &&
            ae.updateMatrixWorld(),
          R.enabled === !0 &&
            R.isPresenting === !0 &&
            (R.cameraAutoUpdate === !0 && R.updateCamera(ae),
            (ae = R.getCamera())),
          O.isScene === !0 && O.onBeforeRender(v, O, ae, T),
          (m = X.get(O, S.length)),
          m.init(),
          S.push(m),
          Fe.multiplyMatrices(ae.projectionMatrix, ae.matrixWorldInverse),
          te.setFromProjectionMatrix(Fe),
          (be = this.localClippingEnabled),
          (ve = oe.init(this.clippingPlanes, be)),
          (x = j.get(O, p.length)),
          x.init(),
          p.push(x),
          _s(O, ae, 0, v.sortObjects),
          x.finish(),
          v.sortObjects === !0 && x.sort(Z, ie),
          this.info.render.frame++,
          ve === !0 && oe.beginShadows();
        const de = m.state.shadowsArray;
        if (
          (ee.render(de, O, ae),
          ve === !0 && oe.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          q.render(x, O),
          m.setupLights(v._useLegacyLights),
          ae.isArrayCamera)
        ) {
          const se = ae.cameras;
          for (let pe = 0, Be = se.length; pe < Be; pe++) {
            const Ge = se[pe];
            ws(x, O, Ge, Ge.viewport);
          }
        } else ws(x, O, ae);
        T !== null &&
          (Q.updateMultisampleRenderTarget(T), Q.updateRenderTargetMipmap(T)),
          O.isScene === !0 && O.onAfterRender(v, O, ae),
          Me.resetDefaultState(),
          (N = -1),
          (A = null),
          S.pop(),
          S.length > 0 ? (m = S[S.length - 1]) : (m = null),
          p.pop(),
          p.length > 0 ? (x = p[p.length - 1]) : (x = null);
      });
    function _s(O, ae, de, se) {
      if (O.visible === !1) return;
      if (O.layers.test(ae.layers)) {
        if (O.isGroup) de = O.renderOrder;
        else if (O.isLOD) O.autoUpdate === !0 && O.update(ae);
        else if (O.isLight) m.pushLight(O), O.castShadow && m.pushShadow(O);
        else if (O.isSprite) {
          if (!O.frustumCulled || te.intersectsSprite(O)) {
            se && Te.setFromMatrixPosition(O.matrixWorld).applyMatrix4(Fe);
            const Ge = b.update(O),
              qe = O.material;
            qe.visible && x.push(O, Ge, qe, de, Te.z, null);
          }
        } else if (
          (O.isMesh || O.isLine || O.isPoints) &&
          (!O.frustumCulled || te.intersectsObject(O))
        ) {
          const Ge = b.update(O),
            qe = O.material;
          if (
            (se &&
              (O.boundingSphere !== void 0
                ? (O.boundingSphere === null && O.computeBoundingSphere(),
                  Te.copy(O.boundingSphere.center))
                : (Ge.boundingSphere === null && Ge.computeBoundingSphere(),
                  Te.copy(Ge.boundingSphere.center)),
              Te.applyMatrix4(O.matrixWorld).applyMatrix4(Fe)),
            Array.isArray(qe))
          ) {
            const $e = Ge.groups;
            for (let Xe = 0, Ie = $e.length; Xe < Ie; Xe++) {
              const He = $e[Xe],
                vt = qe[He.materialIndex];
              vt && vt.visible && x.push(O, Ge, vt, de, Te.z, He);
            }
          } else qe.visible && x.push(O, Ge, qe, de, Te.z, null);
        }
      }
      const Be = O.children;
      for (let Ge = 0, qe = Be.length; Ge < qe; Ge++) _s(Be[Ge], ae, de, se);
    }
    function ws(O, ae, de, se) {
      const pe = O.opaque,
        Be = O.transmissive,
        Ge = O.transparent;
      m.setupLightsView(de),
        ve === !0 && oe.setGlobalState(v.clippingPlanes, de),
        Be.length > 0 && su(pe, Be, ae, de),
        se && ge.viewport(D.copy(se)),
        pe.length > 0 && yi(pe, ae, de),
        Be.length > 0 && yi(Be, ae, de),
        Ge.length > 0 && yi(Ge, ae, de),
        ge.buffers.depth.setTest(!0),
        ge.buffers.depth.setMask(!0),
        ge.buffers.color.setMask(!0),
        ge.setPolygonOffset(!1);
    }
    function su(O, ae, de, se) {
      const pe = _e.isWebGL2;
      Ae === null &&
        (Ae = new ri(1, 1, {
          generateMipmaps: !0,
          type: he.has("EXT_color_buffer_half_float") ? ts : Nr,
          minFilter: es,
          samples: pe ? 4 : 0,
        })),
        v.getDrawingBufferSize(Pe),
        pe ? Ae.setSize(Pe.x, Pe.y) : Ae.setSize(Do(Pe.x), Do(Pe.y));
      const Be = v.getRenderTarget();
      v.setRenderTarget(Ae),
        v.getClearColor(I),
        (G = v.getClearAlpha()),
        G < 1 && v.setClearColor(16777215, 0.5),
        v.clear();
      const Ge = v.toneMapping;
      (v.toneMapping = Cr),
        yi(O, de, se),
        Q.updateMultisampleRenderTarget(Ae),
        Q.updateRenderTargetMipmap(Ae);
      let qe = !1;
      for (let $e = 0, Xe = ae.length; $e < Xe; $e++) {
        const Ie = ae[$e],
          He = Ie.object,
          vt = Ie.geometry,
          pt = Ie.material,
          Lt = Ie.group;
        if (pt.side === jt && He.layers.test(se.layers)) {
          const An = pt.side;
          (pt.side = en),
            (pt.needsUpdate = !0),
            Es(He, de, se, vt, pt, Lt),
            (pt.side = An),
            (pt.needsUpdate = !0),
            (qe = !0);
        }
      }
      qe === !0 &&
        (Q.updateMultisampleRenderTarget(Ae), Q.updateRenderTargetMipmap(Ae)),
        v.setRenderTarget(Be),
        v.setClearColor(I, G),
        (v.toneMapping = Ge);
    }
    function yi(O, ae, de) {
      const se = ae.isScene === !0 ? ae.overrideMaterial : null;
      for (let pe = 0, Be = O.length; pe < Be; pe++) {
        const Ge = O[pe],
          qe = Ge.object,
          $e = Ge.geometry,
          Xe = se === null ? Ge.material : se,
          Ie = Ge.group;
        qe.layers.test(de.layers) && Es(qe, ae, de, $e, Xe, Ie);
      }
    }
    function Es(O, ae, de, se, pe, Be) {
      O.onBeforeRender(v, ae, de, se, pe, Be),
        O.modelViewMatrix.multiplyMatrices(
          de.matrixWorldInverse,
          O.matrixWorld
        ),
        O.normalMatrix.getNormalMatrix(O.modelViewMatrix),
        pe.onBeforeRender(v, ae, de, se, O, Be),
        pe.transparent === !0 && pe.side === jt && pe.forceSinglePass === !1
          ? ((pe.side = en),
            (pe.needsUpdate = !0),
            v.renderBufferDirect(de, ae, se, pe, O, Be),
            (pe.side = lr),
            (pe.needsUpdate = !0),
            v.renderBufferDirect(de, ae, se, pe, O, Be),
            (pe.side = jt))
          : v.renderBufferDirect(de, ae, se, pe, O, Be),
        O.onAfterRender(v, ae, de, se, pe, Be);
    }
    function xi(O, ae, de) {
      ae.isScene !== !0 && (ae = ze);
      const se = J.get(O),
        pe = m.state.lights,
        Be = m.state.shadowsArray,
        Ge = pe.state.version,
        qe = F.getParameters(O, pe.state, Be, ae, de),
        $e = F.getProgramCacheKey(qe);
      let Xe = se.programs;
      (se.environment = O.isMeshStandardMaterial ? ae.environment : null),
        (se.fog = ae.fog),
        (se.envMap = (O.isMeshStandardMaterial ? Ce : ce).get(
          O.envMap || se.environment
        )),
        Xe === void 0 &&
          (O.addEventListener("dispose", Se),
          (Xe = new Map()),
          (se.programs = Xe));
      let Ie = Xe.get($e);
      if (Ie !== void 0) {
        if (se.currentProgram === Ie && se.lightsStateVersion === Ge)
          return Ss(O, qe), Ie;
      } else
        (qe.uniforms = F.getUniforms(O)),
          O.onBuild(de, qe, v),
          O.onBeforeCompile(qe, v),
          (Ie = F.acquireProgram(qe, $e)),
          Xe.set($e, Ie),
          (se.uniforms = qe.uniforms);
      const He = se.uniforms;
      ((!O.isShaderMaterial && !O.isRawShaderMaterial) || O.clipping === !0) &&
        (He.clippingPlanes = oe.uniform),
        Ss(O, qe),
        (se.needsLights = cu(O)),
        (se.lightsStateVersion = Ge),
        se.needsLights &&
          ((He.ambientLightColor.value = pe.state.ambient),
          (He.lightProbe.value = pe.state.probe),
          (He.directionalLights.value = pe.state.directional),
          (He.directionalLightShadows.value = pe.state.directionalShadow),
          (He.spotLights.value = pe.state.spot),
          (He.spotLightShadows.value = pe.state.spotShadow),
          (He.rectAreaLights.value = pe.state.rectArea),
          (He.ltc_1.value = pe.state.rectAreaLTC1),
          (He.ltc_2.value = pe.state.rectAreaLTC2),
          (He.pointLights.value = pe.state.point),
          (He.pointLightShadows.value = pe.state.pointShadow),
          (He.hemisphereLights.value = pe.state.hemi),
          (He.directionalShadowMap.value = pe.state.directionalShadowMap),
          (He.directionalShadowMatrix.value = pe.state.directionalShadowMatrix),
          (He.spotShadowMap.value = pe.state.spotShadowMap),
          (He.spotLightMatrix.value = pe.state.spotLightMatrix),
          (He.spotLightMap.value = pe.state.spotLightMap),
          (He.pointShadowMap.value = pe.state.pointShadowMap),
          (He.pointShadowMatrix.value = pe.state.pointShadowMatrix));
      const vt = Ie.getUniforms(),
        pt = bo.seqWithValue(vt.seq, He);
      return (se.currentProgram = Ie), (se.uniformsList = pt), Ie;
    }
    function Ss(O, ae) {
      const de = J.get(O);
      (de.outputColorSpace = ae.outputColorSpace),
        (de.instancing = ae.instancing),
        (de.instancingColor = ae.instancingColor),
        (de.skinning = ae.skinning),
        (de.morphTargets = ae.morphTargets),
        (de.morphNormals = ae.morphNormals),
        (de.morphColors = ae.morphColors),
        (de.morphTargetsCount = ae.morphTargetsCount),
        (de.numClippingPlanes = ae.numClippingPlanes),
        (de.numIntersection = ae.numClipIntersection),
        (de.vertexAlphas = ae.vertexAlphas),
        (de.vertexTangents = ae.vertexTangents),
        (de.toneMapping = ae.toneMapping);
    }
    function ou(O, ae, de, se, pe) {
      ae.isScene !== !0 && (ae = ze), Q.resetTextureUnits();
      const Be = ae.fog,
        Ge = se.isMeshStandardMaterial ? ae.environment : null,
        qe =
          T === null
            ? v.outputColorSpace
            : T.isXRRenderTarget === !0
            ? T.texture.colorSpace
            : Gn,
        $e = (se.isMeshStandardMaterial ? Ce : ce).get(se.envMap || Ge),
        Xe =
          se.vertexColors === !0 &&
          !!de.attributes.color &&
          de.attributes.color.itemSize === 4,
        Ie = !!de.attributes.tangent && (!!se.normalMap || se.anisotropy > 0),
        He = !!de.morphAttributes.position,
        vt = !!de.morphAttributes.normal,
        pt = !!de.morphAttributes.color;
      let Lt = Cr;
      se.toneMapped &&
        (T === null || T.isXRRenderTarget === !0) &&
        (Lt = v.toneMapping);
      const An =
          de.morphAttributes.position ||
          de.morphAttributes.normal ||
          de.morphAttributes.color,
        St = An !== void 0 ? An.length : 0,
        Ke = J.get(se),
        lu = m.state.lights;
      if (ve === !0 && (be === !0 || O !== A)) {
        const ln = O === A && se.id === N;
        oe.setState(se, O, ln);
      }
      let Mt = !1;
      se.version === Ke.__version
        ? ((Ke.needsLights && Ke.lightsStateVersion !== lu.state.version) ||
            Ke.outputColorSpace !== qe ||
            (pe.isInstancedMesh && Ke.instancing === !1) ||
            (!pe.isInstancedMesh && Ke.instancing === !0) ||
            (pe.isSkinnedMesh && Ke.skinning === !1) ||
            (!pe.isSkinnedMesh && Ke.skinning === !0) ||
            (pe.isInstancedMesh &&
              Ke.instancingColor === !0 &&
              pe.instanceColor === null) ||
            (pe.isInstancedMesh &&
              Ke.instancingColor === !1 &&
              pe.instanceColor !== null) ||
            Ke.envMap !== $e ||
            (se.fog === !0 && Ke.fog !== Be) ||
            (Ke.numClippingPlanes !== void 0 &&
              (Ke.numClippingPlanes !== oe.numPlanes ||
                Ke.numIntersection !== oe.numIntersection)) ||
            Ke.vertexAlphas !== Xe ||
            Ke.vertexTangents !== Ie ||
            Ke.morphTargets !== He ||
            Ke.morphNormals !== vt ||
            Ke.morphColors !== pt ||
            Ke.toneMapping !== Lt ||
            (_e.isWebGL2 === !0 && Ke.morphTargetsCount !== St)) &&
          (Mt = !0)
        : ((Mt = !0), (Ke.__version = se.version));
      let zr = Ke.currentProgram;
      Mt === !0 && (zr = xi(se, ae, pe));
      let Al = !1,
        Ma = !1,
        fu = !1;
      const Zt = zr.getUniforms(),
        kr = Ke.uniforms;
      if (
        (ge.useProgram(zr.program) && ((Al = !0), (Ma = !0), (fu = !0)),
        se.id !== N && ((N = se.id), (Ma = !0)),
        Al || A !== O)
      ) {
        Zt.setValue(H, "projectionMatrix", O.projectionMatrix),
          Zt.setValue(H, "viewMatrix", O.matrixWorldInverse);
        const ln = Zt.map.cameraPosition;
        ln !== void 0 &&
          ln.setValue(H, Te.setFromMatrixPosition(O.matrixWorld)),
          _e.logarithmicDepthBuffer &&
            Zt.setValue(
              H,
              "logDepthBufFC",
              2 / (Math.log(O.far + 1) / Math.LN2)
            ),
          (se.isMeshPhongMaterial ||
            se.isMeshToonMaterial ||
            se.isMeshLambertMaterial ||
            se.isMeshBasicMaterial ||
            se.isMeshStandardMaterial ||
            se.isShaderMaterial) &&
            Zt.setValue(H, "isOrthographic", O.isOrthographicCamera === !0),
          A !== O && ((A = O), (Ma = !0), (fu = !0));
      }
      if (pe.isSkinnedMesh) {
        Zt.setOptional(H, pe, "bindMatrix"),
          Zt.setOptional(H, pe, "bindMatrixInverse");
        const ln = pe.skeleton;
        ln &&
          (_e.floatVertexTextures
            ? (ln.boneTexture === null && ln.computeBoneTexture(),
              Zt.setValue(H, "boneTexture", ln.boneTexture, Q),
              Zt.setValue(H, "boneTextureSize", ln.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const hu = de.morphAttributes;
      if (
        ((hu.position !== void 0 ||
          hu.normal !== void 0 ||
          (hu.color !== void 0 && _e.isWebGL2 === !0)) &&
          P.update(pe, de, zr),
        (Ma || Ke.receiveShadow !== pe.receiveShadow) &&
          ((Ke.receiveShadow = pe.receiveShadow),
          Zt.setValue(H, "receiveShadow", pe.receiveShadow)),
        se.isMeshGouraudMaterial &&
          se.envMap !== null &&
          ((kr.envMap.value = $e),
          (kr.flipEnvMap.value =
            $e.isCubeTexture && $e.isRenderTargetTexture === !1 ? -1 : 1)),
        Ma &&
          (Zt.setValue(H, "toneMappingExposure", v.toneMappingExposure),
          Ke.needsLights && uu(kr, fu),
          Be && se.fog === !0 && V.refreshFogUniforms(kr, Be),
          V.refreshMaterialUniforms(kr, se, k, C, Ae),
          bo.upload(H, Ke.uniformsList, kr, Q)),
        se.isShaderMaterial &&
          se.uniformsNeedUpdate === !0 &&
          (bo.upload(H, Ke.uniformsList, kr, Q), (se.uniformsNeedUpdate = !1)),
        se.isSpriteMaterial && Zt.setValue(H, "center", pe.center),
        Zt.setValue(H, "modelViewMatrix", pe.modelViewMatrix),
        Zt.setValue(H, "normalMatrix", pe.normalMatrix),
        Zt.setValue(H, "modelMatrix", pe.matrixWorld),
        se.isShaderMaterial || se.isRawShaderMaterial)
      ) {
        const ln = se.uniformsGroups;
        for (let du = 0, k0 = ln.length; du < k0; du++)
          if (_e.isWebGL2) {
            const Dl = ln[du];
            _.update(Dl, zr), _.bind(Dl, zr);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return zr;
    }
    function uu(O, ae) {
      (O.ambientLightColor.needsUpdate = ae),
        (O.lightProbe.needsUpdate = ae),
        (O.directionalLights.needsUpdate = ae),
        (O.directionalLightShadows.needsUpdate = ae),
        (O.pointLights.needsUpdate = ae),
        (O.pointLightShadows.needsUpdate = ae),
        (O.spotLights.needsUpdate = ae),
        (O.spotLightShadows.needsUpdate = ae),
        (O.rectAreaLights.needsUpdate = ae),
        (O.hemisphereLights.needsUpdate = ae);
    }
    function cu(O) {
      return (
        O.isMeshLambertMaterial ||
        O.isMeshToonMaterial ||
        O.isMeshPhongMaterial ||
        O.isMeshStandardMaterial ||
        O.isShadowMaterial ||
        (O.isShaderMaterial && O.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return E;
    }),
      (this.getActiveMipmapLevel = function () {
        return M;
      }),
      (this.getRenderTarget = function () {
        return T;
      }),
      (this.setRenderTargetTextures = function (O, ae, de) {
        (J.get(O.texture).__webglTexture = ae),
          (J.get(O.depthTexture).__webglTexture = de);
        const se = J.get(O);
        (se.__hasExternalTextures = !0),
          se.__hasExternalTextures &&
            ((se.__autoAllocateDepthBuffer = de === void 0),
            se.__autoAllocateDepthBuffer ||
              (he.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (se.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (O, ae) {
        const de = J.get(O);
        (de.__webglFramebuffer = ae),
          (de.__useDefaultFramebuffer = ae === void 0);
      }),
      (this.setRenderTarget = function (O, ae = 0, de = 0) {
        (T = O), (E = ae), (M = de);
        let se = !0,
          pe = null,
          Be = !1,
          Ge = !1;
        if (O) {
          const $e = J.get(O);
          $e.__useDefaultFramebuffer !== void 0
            ? (ge.bindFramebuffer(H.FRAMEBUFFER, null), (se = !1))
            : $e.__webglFramebuffer === void 0
            ? Q.setupRenderTarget(O)
            : $e.__hasExternalTextures &&
              Q.rebindTextures(
                O,
                J.get(O.texture).__webglTexture,
                J.get(O.depthTexture).__webglTexture
              );
          const Xe = O.texture;
          (Xe.isData3DTexture ||
            Xe.isDataArrayTexture ||
            Xe.isCompressedArrayTexture) &&
            (Ge = !0);
          const Ie = J.get(O).__webglFramebuffer;
          O.isWebGLCubeRenderTarget
            ? (Array.isArray(Ie[ae]) ? (pe = Ie[ae][de]) : (pe = Ie[ae]),
              (Be = !0))
            : _e.isWebGL2 && O.samples > 0 && Q.useMultisampledRTT(O) === !1
            ? (pe = J.get(O).__webglMultisampledFramebuffer)
            : Array.isArray(Ie)
            ? (pe = Ie[de])
            : (pe = Ie),
            D.copy(O.viewport),
            z.copy(O.scissor),
            ($ = O.scissorTest);
        } else
          D.copy(ne).multiplyScalar(k).floor(),
            z.copy(Y).multiplyScalar(k).floor(),
            ($ = W);
        if (
          (ge.bindFramebuffer(H.FRAMEBUFFER, pe) &&
            _e.drawBuffers &&
            se &&
            ge.drawBuffers(O, pe),
          ge.viewport(D),
          ge.scissor(z),
          ge.setScissorTest($),
          Be)
        ) {
          const $e = J.get(O.texture);
          H.framebufferTexture2D(
            H.FRAMEBUFFER,
            H.COLOR_ATTACHMENT0,
            H.TEXTURE_CUBE_MAP_POSITIVE_X + ae,
            $e.__webglTexture,
            de
          );
        } else if (Ge) {
          const $e = J.get(O.texture),
            Xe = ae || 0;
          H.framebufferTextureLayer(
            H.FRAMEBUFFER,
            H.COLOR_ATTACHMENT0,
            $e.__webglTexture,
            de || 0,
            Xe
          );
        }
        N = -1;
      }),
      (this.readRenderTargetPixels = function (O, ae, de, se, pe, Be, Ge) {
        if (!(O && O.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let qe = J.get(O).__webglFramebuffer;
        if ((O.isWebGLCubeRenderTarget && Ge !== void 0 && (qe = qe[Ge]), qe)) {
          ge.bindFramebuffer(H.FRAMEBUFFER, qe);
          try {
            const $e = O.texture,
              Xe = $e.format,
              Ie = $e.type;
            if (
              Xe !== Ln &&
              fe.convert(Xe) !==
                H.getParameter(H.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const He =
              Ie === ts &&
              (he.has("EXT_color_buffer_half_float") ||
                (_e.isWebGL2 && he.has("EXT_color_buffer_float")));
            if (
              Ie !== Nr &&
              fe.convert(Ie) !==
                H.getParameter(H.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                Ie === Sr &&
                (_e.isWebGL2 ||
                  he.has("OES_texture_float") ||
                  he.has("WEBGL_color_buffer_float"))
              ) &&
              !He
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            ae >= 0 &&
              ae <= O.width - se &&
              de >= 0 &&
              de <= O.height - pe &&
              H.readPixels(ae, de, se, pe, fe.convert(Xe), fe.convert(Ie), Be);
          } finally {
            const $e = T !== null ? J.get(T).__webglFramebuffer : null;
            ge.bindFramebuffer(H.FRAMEBUFFER, $e);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (O, ae, de = 0) {
        const se = Math.pow(2, -de),
          pe = Math.floor(ae.image.width * se),
          Be = Math.floor(ae.image.height * se);
        Q.setTexture2D(ae, 0),
          H.copyTexSubImage2D(H.TEXTURE_2D, de, 0, 0, O.x, O.y, pe, Be),
          ge.unbindTexture();
      }),
      (this.copyTextureToTexture = function (O, ae, de, se = 0) {
        const pe = ae.image.width,
          Be = ae.image.height,
          Ge = fe.convert(de.format),
          qe = fe.convert(de.type);
        Q.setTexture2D(de, 0),
          H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, de.flipY),
          H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, de.premultiplyAlpha),
          H.pixelStorei(H.UNPACK_ALIGNMENT, de.unpackAlignment),
          ae.isDataTexture
            ? H.texSubImage2D(
                H.TEXTURE_2D,
                se,
                O.x,
                O.y,
                pe,
                Be,
                Ge,
                qe,
                ae.image.data
              )
            : ae.isCompressedTexture
            ? H.compressedTexSubImage2D(
                H.TEXTURE_2D,
                se,
                O.x,
                O.y,
                ae.mipmaps[0].width,
                ae.mipmaps[0].height,
                Ge,
                ae.mipmaps[0].data
              )
            : H.texSubImage2D(H.TEXTURE_2D, se, O.x, O.y, Ge, qe, ae.image),
          se === 0 && de.generateMipmaps && H.generateMipmap(H.TEXTURE_2D),
          ge.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (O, ae, de, se, pe = 0) {
        if (v.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const Be = O.max.x - O.min.x + 1,
          Ge = O.max.y - O.min.y + 1,
          qe = O.max.z - O.min.z + 1,
          $e = fe.convert(se.format),
          Xe = fe.convert(se.type);
        let Ie;
        if (se.isData3DTexture) Q.setTexture3D(se, 0), (Ie = H.TEXTURE_3D);
        else if (se.isDataArrayTexture)
          Q.setTexture2DArray(se, 0), (Ie = H.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, se.flipY),
          H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, se.premultiplyAlpha),
          H.pixelStorei(H.UNPACK_ALIGNMENT, se.unpackAlignment);
        const He = H.getParameter(H.UNPACK_ROW_LENGTH),
          vt = H.getParameter(H.UNPACK_IMAGE_HEIGHT),
          pt = H.getParameter(H.UNPACK_SKIP_PIXELS),
          Lt = H.getParameter(H.UNPACK_SKIP_ROWS),
          An = H.getParameter(H.UNPACK_SKIP_IMAGES),
          St = de.isCompressedTexture ? de.mipmaps[0] : de.image;
        H.pixelStorei(H.UNPACK_ROW_LENGTH, St.width),
          H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, St.height),
          H.pixelStorei(H.UNPACK_SKIP_PIXELS, O.min.x),
          H.pixelStorei(H.UNPACK_SKIP_ROWS, O.min.y),
          H.pixelStorei(H.UNPACK_SKIP_IMAGES, O.min.z),
          de.isDataTexture || de.isData3DTexture
            ? H.texSubImage3D(
                Ie,
                pe,
                ae.x,
                ae.y,
                ae.z,
                Be,
                Ge,
                qe,
                $e,
                Xe,
                St.data
              )
            : de.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              H.compressedTexSubImage3D(
                Ie,
                pe,
                ae.x,
                ae.y,
                ae.z,
                Be,
                Ge,
                qe,
                $e,
                St.data
              ))
            : H.texSubImage3D(Ie, pe, ae.x, ae.y, ae.z, Be, Ge, qe, $e, Xe, St),
          H.pixelStorei(H.UNPACK_ROW_LENGTH, He),
          H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, vt),
          H.pixelStorei(H.UNPACK_SKIP_PIXELS, pt),
          H.pixelStorei(H.UNPACK_SKIP_ROWS, Lt),
          H.pixelStorei(H.UNPACK_SKIP_IMAGES, An),
          pe === 0 && se.generateMipmaps && H.generateMipmap(Ie),
          ge.unbindTexture();
      }),
      (this.initTexture = function (O) {
        O.isCubeTexture
          ? Q.setTextureCube(O, 0)
          : O.isData3DTexture
          ? Q.setTexture3D(O, 0)
          : O.isDataArrayTexture || O.isCompressedArrayTexture
          ? Q.setTexture2DArray(O, 0)
          : Q.setTexture2D(O, 0),
          ge.unbindTexture();
      }),
      (this.resetState = function () {
        (E = 0), (M = 0), (T = null), ge.reset(), Me.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return sr;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === gt ? ti : Pp
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === ti ? gt : Gn);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class cw extends Vc {}
cw.prototype.isWebGL1Renderer = !0;
class Zp extends st {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class jf extends gn {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Bi = new ut(),
  Xf = new ut(),
  qs = [],
  Yf = new Ir(),
  lw = new ut(),
  Na = new Re(),
  Ra = new ma();
class Jp extends Re {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new jf(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, lw);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Ir()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Bi),
        Yf.copy(e.boundingBox).applyMatrix4(Bi),
        this.boundingBox.union(Yf);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new ma()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Bi),
        Ra.copy(e.boundingSphere).applyMatrix4(Bi),
        this.boundingSphere.union(Ra);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((Na.geometry = this.geometry),
      (Na.material = this.material),
      Na.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Ra.copy(this.boundingSphere),
        Ra.applyMatrix4(r),
        e.ray.intersectsSphere(Ra) !== !1))
    )
      for (let a = 0; a < i; a++) {
        this.getMatrixAt(a, Bi),
          Xf.multiplyMatrices(r, Bi),
          (Na.matrixWorld = Xf),
          Na.raycast(e, qs);
        for (let s = 0, o = qs.length; s < o; s++) {
          const c = qs[s];
          (c.instanceId = a), (c.object = this), t.push(c);
        }
        qs.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new jf(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class hi extends fi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new tt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Zf = new B(),
  Jf = new B(),
  Kf = new ut(),
  Vu = new Vo(),
  $s = new ma();
class _n extends st {
  constructor(e = new wt(), t = new hi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, a = t.count; i < a; i++)
        Zf.fromBufferAttribute(t, i - 1),
          Jf.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += Zf.distanceTo(Jf));
      e.setAttribute("lineDistance", new nt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      a = e.params.Line.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      $s.copy(r.boundingSphere),
      $s.applyMatrix4(i),
      ($s.radius += a),
      e.ray.intersectsSphere($s) === !1)
    )
      return;
    Kf.copy(i).invert(), Vu.copy(e.ray).applyMatrix4(Kf);
    const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = o * o,
      u = new B(),
      l = new B(),
      f = new B(),
      h = new B(),
      d = this.isLineSegments ? 2 : 1,
      g = r.index,
      m = r.attributes.position;
    if (g !== null) {
      const p = Math.max(0, s.start),
        S = Math.min(g.count, s.start + s.count);
      for (let v = p, y = S - 1; v < y; v += d) {
        const E = g.getX(v),
          M = g.getX(v + 1);
        if (
          (u.fromBufferAttribute(m, E),
          l.fromBufferAttribute(m, M),
          Vu.distanceSqToSegment(u, l, h, f) > c)
        )
          continue;
        h.applyMatrix4(this.matrixWorld);
        const N = e.ray.origin.distanceTo(h);
        N < e.near ||
          N > e.far ||
          t.push({
            distance: N,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const p = Math.max(0, s.start),
        S = Math.min(m.count, s.start + s.count);
      for (let v = p, y = S - 1; v < y; v += d) {
        if (
          (u.fromBufferAttribute(m, v),
          l.fromBufferAttribute(m, v + 1),
          Vu.distanceSqToSegment(u, l, h, f) > c)
        )
          continue;
        h.applyMatrix4(this.matrixWorld);
        const M = e.ray.origin.distanceTo(h);
        M < e.near ||
          M > e.far ||
          t.push({
            distance: M,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let a = 0, s = i.length; a < s; a++) {
          const o = i[a].name || String(a);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = a);
        }
      }
    }
  }
}
const Qf = new B(),
  eh = new B();
class Kp extends _n {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, a = t.count; i < a; i += 2)
        Qf.fromBufferAttribute(t, i),
          eh.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + Qf.distanceTo(eh));
      e.setAttribute("lineDistance", new nt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class jn {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      a = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      (r = this.getPoint(s / e)), (a += r.distanceTo(i)), t.push(a), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const a = r.length;
    let s;
    t ? (s = t) : (s = e * r[a - 1]);
    let o = 0,
      c = a - 1,
      u;
    for (; o <= c; )
      if (((i = Math.floor(o + (c - o) / 2)), (u = r[i] - s), u < 0)) o = i + 1;
      else if (u > 0) c = i - 1;
      else {
        c = i;
        break;
      }
    if (((i = c), r[i] === s)) return i / (a - 1);
    const l = r[i],
      h = r[i + 1] - l,
      d = (s - l) / h;
    return (i + d) / (a - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      a = e + 1e-4;
    i < 0 && (i = 0), a > 1 && (a = 1);
    const s = this.getPoint(i),
      o = this.getPoint(a),
      c = t || (s.isVector2 ? new De() : new B());
    return c.copy(o).sub(s).normalize(), c;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new B(),
      i = [],
      a = [],
      s = [],
      o = new B(),
      c = new ut();
    for (let d = 0; d <= e; d++) {
      const g = d / e;
      i[d] = this.getTangentAt(g, new B());
    }
    (a[0] = new B()), (s[0] = new B());
    let u = Number.MAX_VALUE;
    const l = Math.abs(i[0].x),
      f = Math.abs(i[0].y),
      h = Math.abs(i[0].z);
    l <= u && ((u = l), r.set(1, 0, 0)),
      f <= u && ((u = f), r.set(0, 1, 0)),
      h <= u && r.set(0, 0, 1),
      o.crossVectors(i[0], r).normalize(),
      a[0].crossVectors(i[0], o),
      s[0].crossVectors(i[0], a[0]);
    for (let d = 1; d <= e; d++) {
      if (
        ((a[d] = a[d - 1].clone()),
        (s[d] = s[d - 1].clone()),
        o.crossVectors(i[d - 1], i[d]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize();
        const g = Math.acos(Ut(i[d - 1].dot(i[d]), -1, 1));
        a[d].applyMatrix4(c.makeRotationAxis(o, g));
      }
      s[d].crossVectors(i[d], a[d]);
    }
    if (t === !0) {
      let d = Math.acos(Ut(a[0].dot(a[e]), -1, 1));
      (d /= e), i[0].dot(o.crossVectors(a[0], a[e])) > 0 && (d = -d);
      for (let g = 1; g <= e; g++)
        a[g].applyMatrix4(c.makeRotationAxis(i[g], d * g)),
          s[g].crossVectors(i[g], a[g]);
    }
    return { tangents: i, normals: a, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Wc extends jn {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    a = 0,
    s = Math.PI * 2,
    o = !1,
    c = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = a),
      (this.aEndAngle = s),
      (this.aClockwise = o),
      (this.aRotation = c);
  }
  getPoint(e, t) {
    const r = t || new De(),
      i = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += i;
    for (; a > i; ) a -= i;
    a < Number.EPSILON && (s ? (a = 0) : (a = i)),
      this.aClockwise === !0 && !s && (a === i ? (a = -i) : (a = a - i));
    const o = this.aStartAngle + e * a;
    let c = this.aX + this.xRadius * Math.cos(o),
      u = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const l = Math.cos(this.aRotation),
        f = Math.sin(this.aRotation),
        h = c - this.aX,
        d = u - this.aY;
      (c = h * l - d * f + this.aX), (u = h * f + d * l + this.aY);
    }
    return r.set(c, u);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class fw extends Wc {
  constructor(e, t, r, i, a, s) {
    super(e, t, r, r, i, a, s),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function qc() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(a, s, o, c) {
    (n = a),
      (e = o),
      (t = -3 * a + 3 * s - 2 * o - c),
      (r = 2 * a - 2 * s + o + c);
  }
  return {
    initCatmullRom: function (a, s, o, c, u) {
      i(s, o, u * (o - a), u * (c - s));
    },
    initNonuniformCatmullRom: function (a, s, o, c, u, l, f) {
      let h = (s - a) / u - (o - a) / (u + l) + (o - s) / l,
        d = (o - s) / l - (c - s) / (l + f) + (c - o) / f;
      (h *= l), (d *= l), i(s, o, h, d);
    },
    calc: function (a) {
      const s = a * a,
        o = s * a;
      return n + e * a + t * s + r * o;
    },
  };
}
const js = new B(),
  Wu = new qc(),
  qu = new qc(),
  $u = new qc();
class Qp extends jn {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new B()) {
    const r = t,
      i = this.points,
      a = i.length,
      s = (a - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(s),
      c = s - o;
    this.closed
      ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a)
      : c === 0 && o === a - 1 && ((o = a - 2), (c = 1));
    let u, l;
    this.closed || o > 0
      ? (u = i[(o - 1) % a])
      : (js.subVectors(i[0], i[1]).add(i[0]), (u = js));
    const f = i[o % a],
      h = i[(o + 1) % a];
    if (
      (this.closed || o + 2 < a
        ? (l = i[(o + 2) % a])
        : (js.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), (l = js)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const d = this.curveType === "chordal" ? 0.5 : 0.25;
      let g = Math.pow(u.distanceToSquared(f), d),
        x = Math.pow(f.distanceToSquared(h), d),
        m = Math.pow(h.distanceToSquared(l), d);
      x < 1e-4 && (x = 1),
        g < 1e-4 && (g = x),
        m < 1e-4 && (m = x),
        Wu.initNonuniformCatmullRom(u.x, f.x, h.x, l.x, g, x, m),
        qu.initNonuniformCatmullRom(u.y, f.y, h.y, l.y, g, x, m),
        $u.initNonuniformCatmullRom(u.z, f.z, h.z, l.z, g, x, m);
    } else
      this.curveType === "catmullrom" &&
        (Wu.initCatmullRom(u.x, f.x, h.x, l.x, this.tension),
        qu.initCatmullRom(u.y, f.y, h.y, l.y, this.tension),
        $u.initCatmullRom(u.z, f.z, h.z, l.z, this.tension));
    return r.set(Wu.calc(c), qu.calc(c), $u.calc(c)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new B().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function th(n, e, t, r, i) {
  const a = (r - e) * 0.5,
    s = (i - t) * 0.5,
    o = n * n,
    c = n * o;
  return (
    (2 * t - 2 * r + a + s) * c + (-3 * t + 3 * r - 2 * a - s) * o + a * n + t
  );
}
function hw(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function dw(n, e) {
  return 2 * (1 - n) * n * e;
}
function pw(n, e) {
  return n * n * e;
}
function Xa(n, e, t, r) {
  return hw(n, e) + dw(n, t) + pw(n, r);
}
function mw(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function gw(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function vw(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function yw(n, e) {
  return n * n * n * e;
}
function Ya(n, e, t, r, i) {
  return mw(n, e) + gw(n, t) + vw(n, r) + yw(n, i);
}
class em extends jn {
  constructor(e = new De(), t = new De(), r = new De(), i = new De()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new De()) {
    const r = t,
      i = this.v0,
      a = this.v1,
      s = this.v2,
      o = this.v3;
    return r.set(Ya(e, i.x, a.x, s.x, o.x), Ya(e, i.y, a.y, s.y, o.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class xw extends jn {
  constructor(e = new B(), t = new B(), r = new B(), i = new B()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new B()) {
    const r = t,
      i = this.v0,
      a = this.v1,
      s = this.v2,
      o = this.v3;
    return (
      r.set(
        Ya(e, i.x, a.x, s.x, o.x),
        Ya(e, i.y, a.y, s.y, o.y),
        Ya(e, i.z, a.z, s.z, o.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class $c extends jn {
  constructor(e = new De(), t = new De()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new De()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new De()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class bw extends jn {
  constructor(e = new B(), t = new B()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new B()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new B()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class tm extends jn {
  constructor(e = new De(), t = new De(), r = new De()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new De()) {
    const r = t,
      i = this.v0,
      a = this.v1,
      s = this.v2;
    return r.set(Xa(e, i.x, a.x, s.x), Xa(e, i.y, a.y, s.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class nm extends jn {
  constructor(e = new B(), t = new B(), r = new B()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new B()) {
    const r = t,
      i = this.v0,
      a = this.v1,
      s = this.v2;
    return (
      r.set(Xa(e, i.x, a.x, s.x), Xa(e, i.y, a.y, s.y), Xa(e, i.z, a.z, s.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class rm extends jn {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new De()) {
    const r = t,
      i = this.points,
      a = (i.length - 1) * e,
      s = Math.floor(a),
      o = a - s,
      c = i[s === 0 ? s : s - 1],
      u = i[s],
      l = i[s > i.length - 2 ? i.length - 1 : s + 1],
      f = i[s > i.length - 3 ? i.length - 1 : s + 2];
    return r.set(th(o, c.x, u.x, l.x, f.x), th(o, c.y, u.y, l.y, f.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new De().fromArray(i));
    }
    return this;
  }
}
var jc = Object.freeze({
  __proto__: null,
  ArcCurve: fw,
  CatmullRomCurve3: Qp,
  CubicBezierCurve: em,
  CubicBezierCurve3: xw,
  EllipseCurve: Wc,
  LineCurve: $c,
  LineCurve3: bw,
  QuadraticBezierCurve: tm,
  QuadraticBezierCurve3: nm,
  SplineCurve: rm,
});
class _w extends jn {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new $c(t, e));
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let a = 0;
    for (; a < i.length; ) {
      if (i[a] >= r) {
        const s = i[a] - r,
          o = this.curves[a],
          c = o.getLength(),
          u = c === 0 ? 0 : 1 - s / c;
        return o.getPointAt(u, t);
      }
      a++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, a = this.curves; i < a.length; i++) {
      const s = a[i],
        o = s.isEllipseCurve
          ? e * 2
          : s.isLineCurve || s.isLineCurve3
          ? 1
          : s.isSplineCurve
          ? e * s.points.length
          : e,
        c = s.getPoints(o);
      for (let u = 0; u < c.length; u++) {
        const l = c[u];
        (r && r.equals(l)) || (t.push(l), (r = l));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new jc[i.type]().fromJSON(i));
    }
    return this;
  }
}
let nh = class extends _w {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new De()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new $c(this.currentPoint.clone(), new De(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const a = new tm(this.currentPoint.clone(), new De(e, t), new De(r, i));
    return this.curves.push(a), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, a, s) {
    const o = new em(
      this.currentPoint.clone(),
      new De(e, t),
      new De(r, i),
      new De(a, s)
    );
    return this.curves.push(o), this.currentPoint.set(a, s), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new rm(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, a, s) {
    const o = this.currentPoint.x,
      c = this.currentPoint.y;
    return this.absarc(e + o, t + c, r, i, a, s), this;
  }
  absarc(e, t, r, i, a, s) {
    return this.absellipse(e, t, r, r, i, a, s), this;
  }
  ellipse(e, t, r, i, a, s, o, c) {
    const u = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absellipse(e + u, t + l, r, i, a, s, o, c), this;
  }
  absellipse(e, t, r, i, a, s, o, c) {
    const u = new Wc(e, t, r, i, a, s, o, c);
    if (this.curves.length > 0) {
      const f = u.getPoint(0);
      f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
    }
    this.curves.push(u);
    const l = u.getPoint(1);
    return this.currentPoint.copy(l), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
};
class Ot extends wt {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    a = 1,
    s = !1,
    o = 0,
    c = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: a,
        openEnded: s,
        thetaStart: o,
        thetaLength: c,
      });
    const u = this;
    (i = Math.floor(i)), (a = Math.floor(a));
    const l = [],
      f = [],
      h = [],
      d = [];
    let g = 0;
    const x = [],
      m = r / 2;
    let p = 0;
    S(),
      s === !1 && (e > 0 && v(!0), t > 0 && v(!1)),
      this.setIndex(l),
      this.setAttribute("position", new nt(f, 3)),
      this.setAttribute("normal", new nt(h, 3)),
      this.setAttribute("uv", new nt(d, 2));
    function S() {
      const y = new B(),
        E = new B();
      let M = 0;
      const T = (t - e) / r;
      for (let N = 0; N <= a; N++) {
        const A = [],
          D = N / a,
          z = D * (t - e) + e;
        for (let $ = 0; $ <= i; $++) {
          const I = $ / i,
            G = I * c + o,
            L = Math.sin(G),
            C = Math.cos(G);
          (E.x = z * L),
            (E.y = -D * r + m),
            (E.z = z * C),
            f.push(E.x, E.y, E.z),
            y.set(L, T, C).normalize(),
            h.push(y.x, y.y, y.z),
            d.push(I, 1 - D),
            A.push(g++);
        }
        x.push(A);
      }
      for (let N = 0; N < i; N++)
        for (let A = 0; A < a; A++) {
          const D = x[A][N],
            z = x[A + 1][N],
            $ = x[A + 1][N + 1],
            I = x[A][N + 1];
          l.push(D, z, I), l.push(z, $, I), (M += 6);
        }
      u.addGroup(p, M, 0), (p += M);
    }
    function v(y) {
      const E = g,
        M = new De(),
        T = new B();
      let N = 0;
      const A = y === !0 ? e : t,
        D = y === !0 ? 1 : -1;
      for (let $ = 1; $ <= i; $++)
        f.push(0, m * D, 0), h.push(0, D, 0), d.push(0.5, 0.5), g++;
      const z = g;
      for (let $ = 0; $ <= i; $++) {
        const G = ($ / i) * c + o,
          L = Math.cos(G),
          C = Math.sin(G);
        (T.x = A * C),
          (T.y = m * D),
          (T.z = A * L),
          f.push(T.x, T.y, T.z),
          h.push(0, D, 0),
          (M.x = L * 0.5 + 0.5),
          (M.y = C * 0.5 * D + 0.5),
          d.push(M.x, M.y),
          g++;
      }
      for (let $ = 0; $ < i; $++) {
        const I = E + $,
          G = z + $;
        y === !0 ? l.push(G, G + 1, I) : l.push(G + 1, G, I), (N += 3);
      }
      u.addGroup(p, N, y === !0 ? 1 : 2), (p += N);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ot(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Xc extends Ot {
  constructor(e = 1, t = 1, r = 32, i = 1, a = !1, s = 0, o = Math.PI * 2) {
    super(0, e, t, r, i, a, s, o),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: a,
        thetaStart: s,
        thetaLength: o,
      });
  }
  static fromJSON(e) {
    return new Xc(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Yc extends wt {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const a = [],
      s = [];
    o(i),
      u(r),
      l(),
      this.setAttribute("position", new nt(a, 3)),
      this.setAttribute("normal", new nt(a.slice(), 3)),
      this.setAttribute("uv", new nt(s, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(S) {
      const v = new B(),
        y = new B(),
        E = new B();
      for (let M = 0; M < t.length; M += 3)
        d(t[M + 0], v), d(t[M + 1], y), d(t[M + 2], E), c(v, y, E, S);
    }
    function c(S, v, y, E) {
      const M = E + 1,
        T = [];
      for (let N = 0; N <= M; N++) {
        T[N] = [];
        const A = S.clone().lerp(y, N / M),
          D = v.clone().lerp(y, N / M),
          z = M - N;
        for (let $ = 0; $ <= z; $++)
          $ === 0 && N === M
            ? (T[N][$] = A)
            : (T[N][$] = A.clone().lerp(D, $ / z));
      }
      for (let N = 0; N < M; N++)
        for (let A = 0; A < 2 * (M - N) - 1; A++) {
          const D = Math.floor(A / 2);
          A % 2 === 0
            ? (h(T[N][D + 1]), h(T[N + 1][D]), h(T[N][D]))
            : (h(T[N][D + 1]), h(T[N + 1][D + 1]), h(T[N + 1][D]));
        }
    }
    function u(S) {
      const v = new B();
      for (let y = 0; y < a.length; y += 3)
        (v.x = a[y + 0]),
          (v.y = a[y + 1]),
          (v.z = a[y + 2]),
          v.normalize().multiplyScalar(S),
          (a[y + 0] = v.x),
          (a[y + 1] = v.y),
          (a[y + 2] = v.z);
    }
    function l() {
      const S = new B();
      for (let v = 0; v < a.length; v += 3) {
        (S.x = a[v + 0]), (S.y = a[v + 1]), (S.z = a[v + 2]);
        const y = m(S) / 2 / Math.PI + 0.5,
          E = p(S) / Math.PI + 0.5;
        s.push(y, 1 - E);
      }
      g(), f();
    }
    function f() {
      for (let S = 0; S < s.length; S += 6) {
        const v = s[S + 0],
          y = s[S + 2],
          E = s[S + 4],
          M = Math.max(v, y, E),
          T = Math.min(v, y, E);
        M > 0.9 &&
          T < 0.1 &&
          (v < 0.2 && (s[S + 0] += 1),
          y < 0.2 && (s[S + 2] += 1),
          E < 0.2 && (s[S + 4] += 1));
      }
    }
    function h(S) {
      a.push(S.x, S.y, S.z);
    }
    function d(S, v) {
      const y = S * 3;
      (v.x = e[y + 0]), (v.y = e[y + 1]), (v.z = e[y + 2]);
    }
    function g() {
      const S = new B(),
        v = new B(),
        y = new B(),
        E = new B(),
        M = new De(),
        T = new De(),
        N = new De();
      for (let A = 0, D = 0; A < a.length; A += 9, D += 6) {
        S.set(a[A + 0], a[A + 1], a[A + 2]),
          v.set(a[A + 3], a[A + 4], a[A + 5]),
          y.set(a[A + 6], a[A + 7], a[A + 8]),
          M.set(s[D + 0], s[D + 1]),
          T.set(s[D + 2], s[D + 3]),
          N.set(s[D + 4], s[D + 5]),
          E.copy(S).add(v).add(y).divideScalar(3);
        const z = m(E);
        x(M, D + 0, S, z), x(T, D + 2, v, z), x(N, D + 4, y, z);
      }
    }
    function x(S, v, y, E) {
      E < 0 && S.x === 1 && (s[v] = S.x - 1),
        y.x === 0 && y.z === 0 && (s[v] = E / 2 / Math.PI + 0.5);
    }
    function m(S) {
      return Math.atan2(S.z, -S.x);
    }
    function p(S) {
      return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yc(e.vertices, e.indices, e.radius, e.details);
  }
}
class im extends nh {
  constructor(e) {
    super(e), (this.uuid = li()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new nh().fromJSON(i));
    }
    return this;
  }
}
const ww = {
  triangulate: function (n, e, t = 2) {
    const r = e && e.length,
      i = r ? e[0] * t : n.length;
    let a = am(n, 0, i, t, !0);
    const s = [];
    if (!a || a.next === a.prev) return s;
    let o, c, u, l, f, h, d;
    if ((r && (a = Dw(n, e, a, t)), n.length > 80 * t)) {
      (o = u = n[0]), (c = l = n[1]);
      for (let g = t; g < i; g += t)
        (f = n[g]),
          (h = n[g + 1]),
          f < o && (o = f),
          h < c && (c = h),
          f > u && (u = f),
          h > l && (l = h);
      (d = Math.max(u - o, l - c)), (d = d !== 0 ? 32767 / d : 0);
    }
    return is(a, s, t, o, c, d, 0), s;
  },
};
function am(n, e, t, r, i) {
  let a, s;
  if (i === Bw(n, e, t, r) > 0)
    for (a = e; a < t; a += r) s = rh(a, n[a], n[a + 1], s);
  else for (a = t - r; a >= e; a -= r) s = rh(a, n[a], n[a + 1], s);
  return s && qo(s, s.next) && (ss(s), (s = s.next)), s;
}
function ai(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (qo(t, t.next) || _t(t.prev, t, t.next) === 0))
    ) {
      if ((ss(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function is(n, e, t, r, i, a, s) {
  if (!n) return;
  !s && a && Fw(n, r, i, a);
  let o = n,
    c,
    u;
  for (; n.prev !== n.next; ) {
    if (((c = n.prev), (u = n.next), a ? Sw(n, r, i, a) : Ew(n))) {
      e.push((c.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((u.i / t) | 0),
        ss(n),
        (n = u.next),
        (o = u.next);
      continue;
    }
    if (((n = u), n === o)) {
      s
        ? s === 1
          ? ((n = Mw(ai(n), e, t)), is(n, e, t, r, i, a, 2))
          : s === 2 && Aw(n, e, t, r, i, a)
        : is(ai(n), e, t, r, i, a, 1);
      break;
    }
  }
}
function Ew(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (_t(e, t, r) >= 0) return !1;
  const i = e.x,
    a = t.x,
    s = r.x,
    o = e.y,
    c = t.y,
    u = r.y,
    l = i < a ? (i < s ? i : s) : a < s ? a : s,
    f = o < c ? (o < u ? o : u) : c < u ? c : u,
    h = i > a ? (i > s ? i : s) : a > s ? a : s,
    d = o > c ? (o > u ? o : u) : c > u ? c : u;
  let g = r.next;
  for (; g !== e; ) {
    if (
      g.x >= l &&
      g.x <= h &&
      g.y >= f &&
      g.y <= d &&
      ji(i, o, a, c, s, u, g.x, g.y) &&
      _t(g.prev, g, g.next) >= 0
    )
      return !1;
    g = g.next;
  }
  return !0;
}
function Sw(n, e, t, r) {
  const i = n.prev,
    a = n,
    s = n.next;
  if (_t(i, a, s) >= 0) return !1;
  const o = i.x,
    c = a.x,
    u = s.x,
    l = i.y,
    f = a.y,
    h = s.y,
    d = o < c ? (o < u ? o : u) : c < u ? c : u,
    g = l < f ? (l < h ? l : h) : f < h ? f : h,
    x = o > c ? (o > u ? o : u) : c > u ? c : u,
    m = l > f ? (l > h ? l : h) : f > h ? f : h,
    p = mc(d, g, e, t, r),
    S = mc(x, m, e, t, r);
  let v = n.prevZ,
    y = n.nextZ;
  for (; v && v.z >= p && y && y.z <= S; ) {
    if (
      (v.x >= d &&
        v.x <= x &&
        v.y >= g &&
        v.y <= m &&
        v !== i &&
        v !== s &&
        ji(o, l, c, f, u, h, v.x, v.y) &&
        _t(v.prev, v, v.next) >= 0) ||
      ((v = v.prevZ),
      y.x >= d &&
        y.x <= x &&
        y.y >= g &&
        y.y <= m &&
        y !== i &&
        y !== s &&
        ji(o, l, c, f, u, h, y.x, y.y) &&
        _t(y.prev, y, y.next) >= 0)
    )
      return !1;
    y = y.nextZ;
  }
  for (; v && v.z >= p; ) {
    if (
      v.x >= d &&
      v.x <= x &&
      v.y >= g &&
      v.y <= m &&
      v !== i &&
      v !== s &&
      ji(o, l, c, f, u, h, v.x, v.y) &&
      _t(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.prevZ;
  }
  for (; y && y.z <= S; ) {
    if (
      y.x >= d &&
      y.x <= x &&
      y.y >= g &&
      y.y <= m &&
      y !== i &&
      y !== s &&
      ji(o, l, c, f, u, h, y.x, y.y) &&
      _t(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.nextZ;
  }
  return !0;
}
function Mw(n, e, t) {
  let r = n;
  do {
    const i = r.prev,
      a = r.next.next;
    !qo(i, a) &&
      sm(i, r, r.next, a) &&
      as(i, a) &&
      as(a, i) &&
      (e.push((i.i / t) | 0),
      e.push((r.i / t) | 0),
      e.push((a.i / t) | 0),
      ss(r),
      ss(r.next),
      (r = n = a)),
      (r = r.next);
  } while (r !== n);
  return ai(r);
}
function Aw(n, e, t, r, i, a) {
  let s = n;
  do {
    let o = s.next.next;
    for (; o !== s.prev; ) {
      if (s.i !== o.i && Iw(s, o)) {
        let c = om(s, o);
        (s = ai(s, s.next)),
          (c = ai(c, c.next)),
          is(s, e, t, r, i, a, 0),
          is(c, e, t, r, i, a, 0);
        return;
      }
      o = o.next;
    }
    s = s.next;
  } while (s !== n);
}
function Dw(n, e, t, r) {
  const i = [];
  let a, s, o, c, u;
  for (a = 0, s = e.length; a < s; a++)
    (o = e[a] * r),
      (c = a < s - 1 ? e[a + 1] * r : n.length),
      (u = am(n, o, c, r, !1)),
      u === u.next && (u.steiner = !0),
      i.push(Lw(u));
  for (i.sort(Tw), a = 0; a < i.length; a++) t = Cw(i[a], t);
  return t;
}
function Tw(n, e) {
  return n.x - e.x;
}
function Cw(n, e) {
  const t = Nw(n, e);
  if (!t) return e;
  const r = om(t, n);
  return ai(r, r.next), ai(t, t.next);
}
function Nw(n, e) {
  let t = e,
    r = -1 / 0,
    i;
  const a = n.x,
    s = n.y;
  do {
    if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
      const h = t.x + ((s - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        h <= a &&
        h > r &&
        ((r = h), (i = t.x < t.next.x ? t : t.next), h === a)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const o = i,
    c = i.x,
    u = i.y;
  let l = 1 / 0,
    f;
  t = i;
  do
    a >= t.x &&
      t.x >= c &&
      a !== t.x &&
      ji(s < u ? a : r, s, c, u, s < u ? r : a, s, t.x, t.y) &&
      ((f = Math.abs(s - t.y) / (a - t.x)),
      as(t, n) &&
        (f < l || (f === l && (t.x > i.x || (t.x === i.x && Rw(i, t))))) &&
        ((i = t), (l = f))),
      (t = t.next);
  while (t !== o);
  return i;
}
function Rw(n, e) {
  return _t(n.prev, n, e.prev) < 0 && _t(e.next, n, n.next) < 0;
}
function Fw(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = mc(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), Pw(i);
}
function Pw(n) {
  let e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u = 1;
  do {
    for (t = n, n = null, a = null, s = 0; t; ) {
      for (s++, r = t, o = 0, e = 0; e < u && (o++, (r = r.nextZ), !!r); e++);
      for (c = u; o > 0 || (c > 0 && r); )
        o !== 0 && (c === 0 || !r || t.z <= r.z)
          ? ((i = t), (t = t.nextZ), o--)
          : ((i = r), (r = r.nextZ), c--),
          a ? (a.nextZ = i) : (n = i),
          (i.prevZ = a),
          (a = i);
      t = r;
    }
    (a.nextZ = null), (u *= 2);
  } while (s > 1);
  return n;
}
function mc(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function Lw(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function ji(n, e, t, r, i, a, s, o) {
  return (
    (i - s) * (e - o) >= (n - s) * (a - o) &&
    (n - s) * (r - o) >= (t - s) * (e - o) &&
    (t - s) * (a - o) >= (i - s) * (r - o)
  );
}
function Iw(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !Ow(n, e) &&
    ((as(n, e) &&
      as(e, n) &&
      Uw(n, e) &&
      (_t(n.prev, n, e.prev) || _t(n, e.prev, e))) ||
      (qo(n, e) && _t(n.prev, n, n.next) > 0 && _t(e.prev, e, e.next) > 0))
  );
}
function _t(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function qo(n, e) {
  return n.x === e.x && n.y === e.y;
}
function sm(n, e, t, r) {
  const i = Ys(_t(n, e, t)),
    a = Ys(_t(n, e, r)),
    s = Ys(_t(t, r, n)),
    o = Ys(_t(t, r, e));
  return !!(
    (i !== a && s !== o) ||
    (i === 0 && Xs(n, t, e)) ||
    (a === 0 && Xs(n, r, e)) ||
    (s === 0 && Xs(t, n, r)) ||
    (o === 0 && Xs(t, e, r))
  );
}
function Xs(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Ys(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function Ow(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      sm(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function as(n, e) {
  return _t(n.prev, n, n.next) < 0
    ? _t(n, e, n.next) >= 0 && _t(n, n.prev, e) >= 0
    : _t(n, e, n.prev) < 0 || _t(n, n.next, e) < 0;
}
function Uw(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    a = (n.y + e.y) / 2;
  do
    t.y > a != t.next.y > a &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (a - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function om(n, e) {
  const t = new gc(n.i, n.x, n.y),
    r = new gc(e.i, e.x, e.y),
    i = n.next,
    a = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (a.next = r),
    (r.prev = a),
    r
  );
}
function rh(n, e, t, r) {
  const i = new gc(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function ss(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function gc(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function Bw(n, e, t, r) {
  let i = 0;
  for (let a = e, s = t - r; a < t; a += r)
    (i += (n[s] - n[a]) * (n[a + 1] + n[s + 1])), (s = a);
  return i;
}
class Za {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, a = 0; a < t; i = a++)
      r += e[i].x * e[a].y - e[a].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Za.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      a = [];
    ih(e), ah(r, e);
    let s = e.length;
    t.forEach(ih);
    for (let c = 0; c < t.length; c++)
      i.push(s), (s += t[c].length), ah(r, t[c]);
    const o = ww.triangulate(r, i);
    for (let c = 0; c < o.length; c += 3) a.push(o.slice(c, c + 3));
    return a;
  }
}
function ih(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function ah(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Zc extends wt {
  constructor(
    e = new im([
      new De(0.5, 0.5),
      new De(-0.5, 0.5),
      new De(-0.5, -0.5),
      new De(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      a = [];
    for (let o = 0, c = e.length; o < c; o++) {
      const u = e[o];
      s(u);
    }
    this.setAttribute("position", new nt(i, 3)),
      this.setAttribute("uv", new nt(a, 2)),
      this.computeVertexNormals();
    function s(o) {
      const c = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        l = t.steps !== void 0 ? t.steps : 1,
        f = t.depth !== void 0 ? t.depth : 1;
      let h = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        d = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        g = t.bevelSize !== void 0 ? t.bevelSize : d - 0.1,
        x = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        m = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const p = t.extrudePath,
        S = t.UVGenerator !== void 0 ? t.UVGenerator : zw;
      let v,
        y = !1,
        E,
        M,
        T,
        N;
      p &&
        ((v = p.getSpacedPoints(l)),
        (y = !0),
        (h = !1),
        (E = p.computeFrenetFrames(l, !1)),
        (M = new B()),
        (T = new B()),
        (N = new B())),
        h || ((m = 0), (d = 0), (g = 0), (x = 0));
      const A = o.extractPoints(u);
      let D = A.shape;
      const z = A.holes;
      if (!Za.isClockWise(D)) {
        D = D.reverse();
        for (let H = 0, we = z.length; H < we; H++) {
          const he = z[H];
          Za.isClockWise(he) && (z[H] = he.reverse());
        }
      }
      const I = Za.triangulateShape(D, z),
        G = D;
      for (let H = 0, we = z.length; H < we; H++) {
        const he = z[H];
        D = D.concat(he);
      }
      function L(H, we, he) {
        return (
          we || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          H.clone().addScaledVector(we, he)
        );
      }
      const C = D.length,
        k = I.length;
      function Z(H, we, he) {
        let _e, ge, Ue;
        const J = H.x - we.x,
          Q = H.y - we.y,
          ce = he.x - H.x,
          Ce = he.y - H.y,
          Ne = J * J + Q * Q,
          w = J * Ce - Q * ce;
        if (Math.abs(w) > Number.EPSILON) {
          const b = Math.sqrt(Ne),
            F = Math.sqrt(ce * ce + Ce * Ce),
            V = we.x - Q / b,
            j = we.y + J / b,
            X = he.x - Ce / F,
            oe = he.y + ce / F,
            ee = ((X - V) * Ce - (oe - j) * ce) / (J * Ce - Q * ce);
          (_e = V + J * ee - H.x), (ge = j + Q * ee - H.y);
          const q = _e * _e + ge * ge;
          if (q <= 2) return new De(_e, ge);
          Ue = Math.sqrt(q / 2);
        } else {
          let b = !1;
          J > Number.EPSILON
            ? ce > Number.EPSILON && (b = !0)
            : J < -Number.EPSILON
            ? ce < -Number.EPSILON && (b = !0)
            : Math.sign(Q) === Math.sign(Ce) && (b = !0),
            b
              ? ((_e = -Q), (ge = J), (Ue = Math.sqrt(Ne)))
              : ((_e = J), (ge = Q), (Ue = Math.sqrt(Ne / 2)));
        }
        return new De(_e / Ue, ge / Ue);
      }
      const ie = [];
      for (
        let H = 0, we = G.length, he = we - 1, _e = H + 1;
        H < we;
        H++, he++, _e++
      )
        he === we && (he = 0),
          _e === we && (_e = 0),
          (ie[H] = Z(G[H], G[he], G[_e]));
      const ne = [];
      let Y,
        W = ie.concat();
      for (let H = 0, we = z.length; H < we; H++) {
        const he = z[H];
        Y = [];
        for (
          let _e = 0, ge = he.length, Ue = ge - 1, J = _e + 1;
          _e < ge;
          _e++, Ue++, J++
        )
          Ue === ge && (Ue = 0),
            J === ge && (J = 0),
            (Y[_e] = Z(he[_e], he[Ue], he[J]));
        ne.push(Y), (W = W.concat(Y));
      }
      for (let H = 0; H < m; H++) {
        const we = H / m,
          he = d * Math.cos((we * Math.PI) / 2),
          _e = g * Math.sin((we * Math.PI) / 2) + x;
        for (let ge = 0, Ue = G.length; ge < Ue; ge++) {
          const J = L(G[ge], ie[ge], _e);
          Fe(J.x, J.y, -he);
        }
        for (let ge = 0, Ue = z.length; ge < Ue; ge++) {
          const J = z[ge];
          Y = ne[ge];
          for (let Q = 0, ce = J.length; Q < ce; Q++) {
            const Ce = L(J[Q], Y[Q], _e);
            Fe(Ce.x, Ce.y, -he);
          }
        }
      }
      const te = g + x;
      for (let H = 0; H < C; H++) {
        const we = h ? L(D[H], W[H], te) : D[H];
        y
          ? (T.copy(E.normals[0]).multiplyScalar(we.x),
            M.copy(E.binormals[0]).multiplyScalar(we.y),
            N.copy(v[0]).add(T).add(M),
            Fe(N.x, N.y, N.z))
          : Fe(we.x, we.y, 0);
      }
      for (let H = 1; H <= l; H++)
        for (let we = 0; we < C; we++) {
          const he = h ? L(D[we], W[we], te) : D[we];
          y
            ? (T.copy(E.normals[H]).multiplyScalar(he.x),
              M.copy(E.binormals[H]).multiplyScalar(he.y),
              N.copy(v[H]).add(T).add(M),
              Fe(N.x, N.y, N.z))
            : Fe(he.x, he.y, (f / l) * H);
        }
      for (let H = m - 1; H >= 0; H--) {
        const we = H / m,
          he = d * Math.cos((we * Math.PI) / 2),
          _e = g * Math.sin((we * Math.PI) / 2) + x;
        for (let ge = 0, Ue = G.length; ge < Ue; ge++) {
          const J = L(G[ge], ie[ge], _e);
          Fe(J.x, J.y, f + he);
        }
        for (let ge = 0, Ue = z.length; ge < Ue; ge++) {
          const J = z[ge];
          Y = ne[ge];
          for (let Q = 0, ce = J.length; Q < ce; Q++) {
            const Ce = L(J[Q], Y[Q], _e);
            y
              ? Fe(Ce.x, Ce.y + v[l - 1].y, v[l - 1].x + he)
              : Fe(Ce.x, Ce.y, f + he);
          }
        }
      }
      ve(), be();
      function ve() {
        const H = i.length / 3;
        if (h) {
          let we = 0,
            he = C * we;
          for (let _e = 0; _e < k; _e++) {
            const ge = I[_e];
            Pe(ge[2] + he, ge[1] + he, ge[0] + he);
          }
          (we = l + m * 2), (he = C * we);
          for (let _e = 0; _e < k; _e++) {
            const ge = I[_e];
            Pe(ge[0] + he, ge[1] + he, ge[2] + he);
          }
        } else {
          for (let we = 0; we < k; we++) {
            const he = I[we];
            Pe(he[2], he[1], he[0]);
          }
          for (let we = 0; we < k; we++) {
            const he = I[we];
            Pe(he[0] + C * l, he[1] + C * l, he[2] + C * l);
          }
        }
        r.addGroup(H, i.length / 3 - H, 0);
      }
      function be() {
        const H = i.length / 3;
        let we = 0;
        Ae(G, we), (we += G.length);
        for (let he = 0, _e = z.length; he < _e; he++) {
          const ge = z[he];
          Ae(ge, we), (we += ge.length);
        }
        r.addGroup(H, i.length / 3 - H, 1);
      }
      function Ae(H, we) {
        let he = H.length;
        for (; --he >= 0; ) {
          const _e = he;
          let ge = he - 1;
          ge < 0 && (ge = H.length - 1);
          for (let Ue = 0, J = l + m * 2; Ue < J; Ue++) {
            const Q = C * Ue,
              ce = C * (Ue + 1),
              Ce = we + _e + Q,
              Ne = we + ge + Q,
              w = we + ge + ce,
              b = we + _e + ce;
            Te(Ce, Ne, w, b);
          }
        }
      }
      function Fe(H, we, he) {
        c.push(H), c.push(we), c.push(he);
      }
      function Pe(H, we, he) {
        ze(H), ze(we), ze(he);
        const _e = i.length / 3,
          ge = S.generateTopUV(r, i, _e - 3, _e - 2, _e - 1);
        Ee(ge[0]), Ee(ge[1]), Ee(ge[2]);
      }
      function Te(H, we, he, _e) {
        ze(H), ze(we), ze(_e), ze(we), ze(he), ze(_e);
        const ge = i.length / 3,
          Ue = S.generateSideWallUV(r, i, ge - 6, ge - 3, ge - 2, ge - 1);
        Ee(Ue[0]), Ee(Ue[1]), Ee(Ue[3]), Ee(Ue[1]), Ee(Ue[2]), Ee(Ue[3]);
      }
      function ze(H) {
        i.push(c[H * 3 + 0]), i.push(c[H * 3 + 1]), i.push(c[H * 3 + 2]);
      }
      function Ee(H) {
        a.push(H.x), a.push(H.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return kw(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let a = 0, s = e.shapes.length; a < s; a++) {
      const o = t[e.shapes[a]];
      r.push(o);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new jc[i.type]().fromJSON(i)),
      new Zc(r, e.options)
    );
  }
}
const zw = {
  generateTopUV: function (n, e, t, r, i) {
    const a = e[t * 3],
      s = e[t * 3 + 1],
      o = e[r * 3],
      c = e[r * 3 + 1],
      u = e[i * 3],
      l = e[i * 3 + 1];
    return [new De(a, s), new De(o, c), new De(u, l)];
  },
  generateSideWallUV: function (n, e, t, r, i, a) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      c = e[t * 3 + 2],
      u = e[r * 3],
      l = e[r * 3 + 1],
      f = e[r * 3 + 2],
      h = e[i * 3],
      d = e[i * 3 + 1],
      g = e[i * 3 + 2],
      x = e[a * 3],
      m = e[a * 3 + 1],
      p = e[a * 3 + 2];
    return Math.abs(o - l) < Math.abs(s - u)
      ? [new De(s, 1 - c), new De(u, 1 - f), new De(h, 1 - g), new De(x, 1 - p)]
      : [
          new De(o, 1 - c),
          new De(l, 1 - f),
          new De(d, 1 - g),
          new De(m, 1 - p),
        ];
  },
};
function kw(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const a = n[r];
      t.shapes.push(a.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Xi extends Yc {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Xi(e.radius, e.detail);
  }
}
class di extends wt {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    a = Math.PI * 2,
    s = 0,
    o = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: a,
        thetaStart: s,
        thetaLength: o,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const c = Math.min(s + o, Math.PI);
    let u = 0;
    const l = [],
      f = new B(),
      h = new B(),
      d = [],
      g = [],
      x = [],
      m = [];
    for (let p = 0; p <= r; p++) {
      const S = [],
        v = p / r;
      let y = 0;
      p === 0 && s === 0
        ? (y = 0.5 / t)
        : p === r && c === Math.PI && (y = -0.5 / t);
      for (let E = 0; E <= t; E++) {
        const M = E / t;
        (f.x = -e * Math.cos(i + M * a) * Math.sin(s + v * o)),
          (f.y = e * Math.cos(s + v * o)),
          (f.z = e * Math.sin(i + M * a) * Math.sin(s + v * o)),
          g.push(f.x, f.y, f.z),
          h.copy(f).normalize(),
          x.push(h.x, h.y, h.z),
          m.push(M + y, 1 - v),
          S.push(u++);
      }
      l.push(S);
    }
    for (let p = 0; p < r; p++)
      for (let S = 0; S < t; S++) {
        const v = l[p][S + 1],
          y = l[p][S],
          E = l[p + 1][S],
          M = l[p + 1][S + 1];
        (p !== 0 || s > 0) && d.push(v, y, M),
          (p !== r - 1 || c < Math.PI) && d.push(y, E, M);
      }
    this.setIndex(d),
      this.setAttribute("position", new nt(g, 3)),
      this.setAttribute("normal", new nt(x, 3)),
      this.setAttribute("uv", new nt(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new di(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Zr extends wt {
  constructor(e = 1, t = 0.4, r = 12, i = 48, a = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: a,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const s = [],
      o = [],
      c = [],
      u = [],
      l = new B(),
      f = new B(),
      h = new B();
    for (let d = 0; d <= r; d++)
      for (let g = 0; g <= i; g++) {
        const x = (g / i) * a,
          m = (d / r) * Math.PI * 2;
        (f.x = (e + t * Math.cos(m)) * Math.cos(x)),
          (f.y = (e + t * Math.cos(m)) * Math.sin(x)),
          (f.z = t * Math.sin(m)),
          o.push(f.x, f.y, f.z),
          (l.x = e * Math.cos(x)),
          (l.y = e * Math.sin(x)),
          h.subVectors(f, l).normalize(),
          c.push(h.x, h.y, h.z),
          u.push(g / i),
          u.push(d / r);
      }
    for (let d = 1; d <= r; d++)
      for (let g = 1; g <= i; g++) {
        const x = (i + 1) * d + g - 1,
          m = (i + 1) * (d - 1) + g - 1,
          p = (i + 1) * (d - 1) + g,
          S = (i + 1) * d + g;
        s.push(x, m, S), s.push(m, p, S);
      }
    this.setIndex(s),
      this.setAttribute("position", new nt(o, 3)),
      this.setAttribute("normal", new nt(c, 3)),
      this.setAttribute("uv", new nt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Zr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Jc extends wt {
  constructor(
    e = new nm(new B(-1, -1, 0), new B(-1, 1, 0), new B(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    a = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: a,
      });
    const s = e.computeFrenetFrames(t, a);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals);
    const o = new B(),
      c = new B(),
      u = new De();
    let l = new B();
    const f = [],
      h = [],
      d = [],
      g = [];
    x(),
      this.setIndex(g),
      this.setAttribute("position", new nt(f, 3)),
      this.setAttribute("normal", new nt(h, 3)),
      this.setAttribute("uv", new nt(d, 2));
    function x() {
      for (let v = 0; v < t; v++) m(v);
      m(a === !1 ? t : 0), S(), p();
    }
    function m(v) {
      l = e.getPointAt(v / t, l);
      const y = s.normals[v],
        E = s.binormals[v];
      for (let M = 0; M <= i; M++) {
        const T = (M / i) * Math.PI * 2,
          N = Math.sin(T),
          A = -Math.cos(T);
        (c.x = A * y.x + N * E.x),
          (c.y = A * y.y + N * E.y),
          (c.z = A * y.z + N * E.z),
          c.normalize(),
          h.push(c.x, c.y, c.z),
          (o.x = l.x + r * c.x),
          (o.y = l.y + r * c.y),
          (o.z = l.z + r * c.z),
          f.push(o.x, o.y, o.z);
      }
    }
    function p() {
      for (let v = 1; v <= t; v++)
        for (let y = 1; y <= i; y++) {
          const E = (i + 1) * (v - 1) + (y - 1),
            M = (i + 1) * v + (y - 1),
            T = (i + 1) * v + y,
            N = (i + 1) * (v - 1) + y;
          g.push(E, M, N), g.push(M, T, N);
        }
    }
    function S() {
      for (let v = 0; v <= t; v++)
        for (let y = 0; y <= i; y++)
          (u.x = v / t), (u.y = y / i), d.push(u.x, u.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new Jc(
      new jc[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class Hw extends fi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new tt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new tt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Bc),
      (this.normalScale = new De(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Or extends fi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new tt(16777215)),
      (this.specular = new tt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new tt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Bc),
      (this.normalScale = new De(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Oc),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Gw extends hi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
const sh = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class Vw {
  constructor(e, t, r) {
    const i = this;
    let a = !1,
      s = 0,
      o = 0,
      c;
    const u = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (l) {
        o++, a === !1 && i.onStart !== void 0 && i.onStart(l, s, o), (a = !0);
      }),
      (this.itemEnd = function (l) {
        s++,
          i.onProgress !== void 0 && i.onProgress(l, s, o),
          s === o && ((a = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (l) {
        i.onError !== void 0 && i.onError(l);
      }),
      (this.resolveURL = function (l) {
        return c ? c(l) : l;
      }),
      (this.setURLModifier = function (l) {
        return (c = l), this;
      }),
      (this.addHandler = function (l, f) {
        return u.push(l, f), this;
      }),
      (this.removeHandler = function (l) {
        const f = u.indexOf(l);
        return f !== -1 && u.splice(f, 2), this;
      }),
      (this.getHandler = function (l) {
        for (let f = 0, h = u.length; f < h; f += 2) {
          const d = u[f],
            g = u[f + 1];
          if ((d.global && (d.lastIndex = 0), d.test(l))) return g;
        }
        return null;
      });
  }
}
const Ww = new Vw();
class Kc {
  constructor(e) {
    (this.manager = e !== void 0 ? e : Ww),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, a) {
      r.load(e, i, t, a);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
Kc.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class qw extends Kc {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const a = this,
      s = sh.get(e);
    if (s !== void 0)
      return (
        a.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), a.manager.itemEnd(e);
        }, 0),
        s
      );
    const o = rs("img");
    function c() {
      l(), sh.add(e, this), t && t(this), a.manager.itemEnd(e);
    }
    function u(f) {
      l(), i && i(f), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function l() {
      o.removeEventListener("load", c, !1),
        o.removeEventListener("error", u, !1);
    }
    return (
      o.addEventListener("load", c, !1),
      o.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      a.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class $w extends Kc {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = new sn(),
      s = new qw(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (o) {
          (a.image = o), (a.needsUpdate = !0), t !== void 0 && t(a);
        },
        r,
        i
      ),
      a
    );
  }
}
class $o extends st {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new tt(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class jw extends $o {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(st.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new tt(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const ju = new ut(),
  oh = new B(),
  uh = new B();
class um {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new De(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ut()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Hc()),
      (this._frameExtents = new De(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new xt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    oh.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(oh),
      uh.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(uh),
      t.updateMatrixWorld(),
      ju.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(ju),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(ju);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
const ch = new ut(),
  Fa = new B(),
  Xu = new B();
class Xw extends um {
  constructor() {
    super(new an(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new De(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new xt(2, 1, 1, 1),
        new xt(0, 1, 1, 1),
        new xt(3, 1, 1, 1),
        new xt(1, 1, 1, 1),
        new xt(3, 0, 1, 1),
        new xt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new B(1, 0, 0),
        new B(-1, 0, 0),
        new B(0, 0, 1),
        new B(0, 0, -1),
        new B(0, 1, 0),
        new B(0, -1, 0),
      ]),
      (this._cubeUps = [
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 0, 1),
        new B(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      a = e.distance || r.far;
    a !== r.far && ((r.far = a), r.updateProjectionMatrix()),
      Fa.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Fa),
      Xu.copy(r.position),
      Xu.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(Xu),
      r.updateMatrixWorld(),
      i.makeTranslation(-Fa.x, -Fa.y, -Fa.z),
      ch.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(ch);
  }
}
class os extends $o {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new Xw());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Yw extends um {
  constructor() {
    super(new qp(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class cm extends $o {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(st.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new st()),
      (this.shadow = new Yw());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Zw extends $o {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class lm {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new Vo(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new kc()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, r = []) {
    return vc(e, this, r, t), r.sort(lh), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, a = e.length; i < a; i++) vc(e[i], this, r, t);
    return r.sort(lh), r;
  }
}
function lh(n, e) {
  return n.distance - e.distance;
}
function vc(n, e, t, r) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), r === !0)) {
    const i = n.children;
    for (let a = 0, s = i.length; a < s; a++) vc(i[a], e, t, !0);
  }
}
class fh {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(Ut(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Jw extends Kp {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new tt(r)), (i = new tt(i));
    const a = t / 2,
      s = e / t,
      o = e / 2,
      c = [],
      u = [];
    for (let h = 0, d = 0, g = -o; h <= t; h++, g += s) {
      c.push(-o, 0, g, o, 0, g), c.push(g, 0, -o, g, 0, o);
      const x = h === a ? r : i;
      x.toArray(u, d),
        (d += 3),
        x.toArray(u, d),
        (d += 3),
        x.toArray(u, d),
        (d += 3),
        x.toArray(u, d),
        (d += 3);
    }
    const l = new wt();
    l.setAttribute("position", new nt(c, 3)),
      l.setAttribute("color", new nt(u, 3));
    const f = new hi({ vertexColors: !0, toneMapped: !1 });
    super(l, f), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Ic } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Ic));
const hh = { type: "change" },
  Yu = { type: "start" },
  dh = { type: "end" },
  Zs = new Vo(),
  ph = new br(),
  Kw = Math.cos(70 * Ba.DEG2RAD);
class fm extends ci {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new B()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: bi.ROTATE,
        MIDDLE: bi.DOLLY,
        RIGHT: bi.PAN,
      }),
      (this.touches = { ONE: _i.ROTATE, TWO: _i.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return o.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return o.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (P) {
        P.addEventListener("keydown", b), (this._domElementKeyEvents = P);
      }),
      (this.stopListenToKeyEvents = function () {
        this._domElementKeyEvents.removeEventListener("keydown", b),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = function () {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = function () {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(hh),
          r.update(),
          (a = i.NONE);
      }),
      (this.update = (function () {
        const P = new B(),
          ue = new Ht().setFromUnitVectors(e.up, new B(0, 1, 0)),
          ye = ue.clone().invert(),
          fe = new B(),
          Me = new Ht(),
          _ = new B(),
          U = 2 * Math.PI;
        return function (re = null) {
          const K = r.object.position;
          P.copy(K).sub(r.target),
            P.applyQuaternion(ue),
            o.setFromVector3(P),
            r.autoRotate && a === i.NONE && z(A(re)),
            r.enableDamping
              ? ((o.theta += c.theta * r.dampingFactor),
                (o.phi += c.phi * r.dampingFactor))
              : ((o.theta += c.theta), (o.phi += c.phi));
          let le = r.minAzimuthAngle,
            Se = r.maxAzimuthAngle;
          isFinite(le) &&
            isFinite(Se) &&
            (le < -Math.PI ? (le += U) : le > Math.PI && (le -= U),
            Se < -Math.PI ? (Se += U) : Se > Math.PI && (Se -= U),
            le <= Se
              ? (o.theta = Math.max(le, Math.min(Se, o.theta)))
              : (o.theta =
                  o.theta > (le + Se) / 2
                    ? Math.max(le, o.theta)
                    : Math.min(Se, o.theta))),
            (o.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, o.phi)
            )),
            o.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(l, r.dampingFactor)
              : r.target.add(l),
            (r.zoomToCursor && M) || r.object.isOrthographicCamera
              ? (o.radius = ie(o.radius))
              : (o.radius = ie(o.radius * u)),
            P.setFromSpherical(o),
            P.applyQuaternion(ye),
            K.copy(r.target).add(P),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((c.theta *= 1 - r.dampingFactor),
                (c.phi *= 1 - r.dampingFactor),
                l.multiplyScalar(1 - r.dampingFactor))
              : (c.set(0, 0, 0), l.set(0, 0, 0));
          let Ye = !1;
          if (r.zoomToCursor && M) {
            let it = null;
            if (r.object.isPerspectiveCamera) {
              const ct = P.length();
              it = ie(ct * u);
              const Yt = ct - it;
              r.object.position.addScaledVector(y, Yt),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const ct = new B(E.x, E.y, 0);
              ct.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / u)
                )),
                r.object.updateProjectionMatrix(),
                (Ye = !0);
              const Yt = new B(E.x, E.y, 0);
              Yt.unproject(r.object),
                r.object.position.sub(Yt).add(ct),
                r.object.updateMatrixWorld(),
                (it = P.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            it !== null &&
              (this.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar(it)
                    .add(r.object.position)
                : (Zs.origin.copy(r.object.position),
                  Zs.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(Zs.direction)) < Kw
                    ? e.lookAt(r.target)
                    : (ph.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      Zs.intersectPlane(ph, r.target))));
          } else
            r.object.isOrthographicCamera &&
              ((r.object.zoom = Math.max(
                r.minZoom,
                Math.min(r.maxZoom, r.object.zoom / u)
              )),
              r.object.updateProjectionMatrix(),
              (Ye = !0));
          return (
            (u = 1),
            (M = !1),
            Ye ||
            fe.distanceToSquared(r.object.position) > s ||
            8 * (1 - Me.dot(r.object.quaternion)) > s ||
            _.distanceToSquared(r.target) > 0
              ? (r.dispatchEvent(hh),
                fe.copy(r.object.position),
                Me.copy(r.object.quaternion),
                _.copy(r.target),
                (Ye = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        r.domElement.removeEventListener("contextmenu", j),
          r.domElement.removeEventListener("pointerdown", J),
          r.domElement.removeEventListener("pointercancel", ce),
          r.domElement.removeEventListener("wheel", w),
          r.domElement.removeEventListener("pointermove", Q),
          r.domElement.removeEventListener("pointerup", ce),
          r._domElementKeyEvents !== null &&
            (r._domElementKeyEvents.removeEventListener("keydown", b),
            (r._domElementKeyEvents = null));
      });
    const r = this,
      i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let a = i.NONE;
    const s = 1e-6,
      o = new fh(),
      c = new fh();
    let u = 1;
    const l = new B(),
      f = new De(),
      h = new De(),
      d = new De(),
      g = new De(),
      x = new De(),
      m = new De(),
      p = new De(),
      S = new De(),
      v = new De(),
      y = new B(),
      E = new De();
    let M = !1;
    const T = [],
      N = {};
    function A(P) {
      return P !== null
        ? ((2 * Math.PI) / 60) * r.autoRotateSpeed * P
        : ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function D() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function z(P) {
      c.theta -= P;
    }
    function $(P) {
      c.phi -= P;
    }
    const I = (function () {
        const P = new B();
        return function (ye, fe) {
          P.setFromMatrixColumn(fe, 0), P.multiplyScalar(-ye), l.add(P);
        };
      })(),
      G = (function () {
        const P = new B();
        return function (ye, fe) {
          r.screenSpacePanning === !0
            ? P.setFromMatrixColumn(fe, 1)
            : (P.setFromMatrixColumn(fe, 0), P.crossVectors(r.object.up, P)),
            P.multiplyScalar(ye),
            l.add(P);
        };
      })(),
      L = (function () {
        const P = new B();
        return function (ye, fe) {
          const Me = r.domElement;
          if (r.object.isPerspectiveCamera) {
            const _ = r.object.position;
            P.copy(_).sub(r.target);
            let U = P.length();
            (U *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              I((2 * ye * U) / Me.clientHeight, r.object.matrix),
              G((2 * fe * U) / Me.clientHeight, r.object.matrix);
          } else
            r.object.isOrthographicCamera
              ? (I(
                  (ye * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Me.clientWidth,
                  r.object.matrix
                ),
                G(
                  (fe * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Me.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function C(P) {
      r.object.isPerspectiveCamera || r.object.isOrthographicCamera
        ? (u /= P)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function k(P) {
      r.object.isPerspectiveCamera || r.object.isOrthographicCamera
        ? (u *= P)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function Z(P) {
      if (!r.zoomToCursor) return;
      M = !0;
      const ue = r.domElement.getBoundingClientRect(),
        ye = P.clientX - ue.left,
        fe = P.clientY - ue.top,
        Me = ue.width,
        _ = ue.height;
      (E.x = (ye / Me) * 2 - 1),
        (E.y = -(fe / _) * 2 + 1),
        y
          .set(E.x, E.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function ie(P) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, P));
    }
    function ne(P) {
      f.set(P.clientX, P.clientY);
    }
    function Y(P) {
      Z(P), p.set(P.clientX, P.clientY);
    }
    function W(P) {
      g.set(P.clientX, P.clientY);
    }
    function te(P) {
      h.set(P.clientX, P.clientY),
        d.subVectors(h, f).multiplyScalar(r.rotateSpeed);
      const ue = r.domElement;
      z((2 * Math.PI * d.x) / ue.clientHeight),
        $((2 * Math.PI * d.y) / ue.clientHeight),
        f.copy(h),
        r.update();
    }
    function ve(P) {
      S.set(P.clientX, P.clientY),
        v.subVectors(S, p),
        v.y > 0 ? C(D()) : v.y < 0 && k(D()),
        p.copy(S),
        r.update();
    }
    function be(P) {
      x.set(P.clientX, P.clientY),
        m.subVectors(x, g).multiplyScalar(r.panSpeed),
        L(m.x, m.y),
        g.copy(x),
        r.update();
    }
    function Ae(P) {
      Z(P), P.deltaY < 0 ? k(D()) : P.deltaY > 0 && C(D()), r.update();
    }
    function Fe(P) {
      let ue = !1;
      switch (P.code) {
        case r.keys.UP:
          P.ctrlKey || P.metaKey || P.shiftKey
            ? $((2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
            : L(0, r.keyPanSpeed),
            (ue = !0);
          break;
        case r.keys.BOTTOM:
          P.ctrlKey || P.metaKey || P.shiftKey
            ? $((-2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
            : L(0, -r.keyPanSpeed),
            (ue = !0);
          break;
        case r.keys.LEFT:
          P.ctrlKey || P.metaKey || P.shiftKey
            ? z((2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
            : L(r.keyPanSpeed, 0),
            (ue = !0);
          break;
        case r.keys.RIGHT:
          P.ctrlKey || P.metaKey || P.shiftKey
            ? z((-2 * Math.PI * r.rotateSpeed) / r.domElement.clientHeight)
            : L(-r.keyPanSpeed, 0),
            (ue = !0);
          break;
      }
      ue && (P.preventDefault(), r.update());
    }
    function Pe() {
      if (T.length === 1) f.set(T[0].pageX, T[0].pageY);
      else {
        const P = 0.5 * (T[0].pageX + T[1].pageX),
          ue = 0.5 * (T[0].pageY + T[1].pageY);
        f.set(P, ue);
      }
    }
    function Te() {
      if (T.length === 1) g.set(T[0].pageX, T[0].pageY);
      else {
        const P = 0.5 * (T[0].pageX + T[1].pageX),
          ue = 0.5 * (T[0].pageY + T[1].pageY);
        g.set(P, ue);
      }
    }
    function ze() {
      const P = T[0].pageX - T[1].pageX,
        ue = T[0].pageY - T[1].pageY,
        ye = Math.sqrt(P * P + ue * ue);
      p.set(0, ye);
    }
    function Ee() {
      r.enableZoom && ze(), r.enablePan && Te();
    }
    function H() {
      r.enableZoom && ze(), r.enableRotate && Pe();
    }
    function we(P) {
      if (T.length == 1) h.set(P.pageX, P.pageY);
      else {
        const ye = q(P),
          fe = 0.5 * (P.pageX + ye.x),
          Me = 0.5 * (P.pageY + ye.y);
        h.set(fe, Me);
      }
      d.subVectors(h, f).multiplyScalar(r.rotateSpeed);
      const ue = r.domElement;
      z((2 * Math.PI * d.x) / ue.clientHeight),
        $((2 * Math.PI * d.y) / ue.clientHeight),
        f.copy(h);
    }
    function he(P) {
      if (T.length === 1) x.set(P.pageX, P.pageY);
      else {
        const ue = q(P),
          ye = 0.5 * (P.pageX + ue.x),
          fe = 0.5 * (P.pageY + ue.y);
        x.set(ye, fe);
      }
      m.subVectors(x, g).multiplyScalar(r.panSpeed), L(m.x, m.y), g.copy(x);
    }
    function _e(P) {
      const ue = q(P),
        ye = P.pageX - ue.x,
        fe = P.pageY - ue.y,
        Me = Math.sqrt(ye * ye + fe * fe);
      S.set(0, Me),
        v.set(0, Math.pow(S.y / p.y, r.zoomSpeed)),
        C(v.y),
        p.copy(S);
    }
    function ge(P) {
      r.enableZoom && _e(P), r.enablePan && he(P);
    }
    function Ue(P) {
      r.enableZoom && _e(P), r.enableRotate && we(P);
    }
    function J(P) {
      r.enabled !== !1 &&
        (T.length === 0 &&
          (r.domElement.setPointerCapture(P.pointerId),
          r.domElement.addEventListener("pointermove", Q),
          r.domElement.addEventListener("pointerup", ce)),
        X(P),
        P.pointerType === "touch" ? F(P) : Ce(P));
    }
    function Q(P) {
      r.enabled !== !1 && (P.pointerType === "touch" ? V(P) : Ne(P));
    }
    function ce(P) {
      oe(P),
        T.length === 0 &&
          (r.domElement.releasePointerCapture(P.pointerId),
          r.domElement.removeEventListener("pointermove", Q),
          r.domElement.removeEventListener("pointerup", ce)),
        r.dispatchEvent(dh),
        (a = i.NONE);
    }
    function Ce(P) {
      let ue;
      switch (P.button) {
        case 0:
          ue = r.mouseButtons.LEFT;
          break;
        case 1:
          ue = r.mouseButtons.MIDDLE;
          break;
        case 2:
          ue = r.mouseButtons.RIGHT;
          break;
        default:
          ue = -1;
      }
      switch (ue) {
        case bi.DOLLY:
          if (r.enableZoom === !1) return;
          Y(P), (a = i.DOLLY);
          break;
        case bi.ROTATE:
          if (P.ctrlKey || P.metaKey || P.shiftKey) {
            if (r.enablePan === !1) return;
            W(P), (a = i.PAN);
          } else {
            if (r.enableRotate === !1) return;
            ne(P), (a = i.ROTATE);
          }
          break;
        case bi.PAN:
          if (P.ctrlKey || P.metaKey || P.shiftKey) {
            if (r.enableRotate === !1) return;
            ne(P), (a = i.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            W(P), (a = i.PAN);
          }
          break;
        default:
          a = i.NONE;
      }
      a !== i.NONE && r.dispatchEvent(Yu);
    }
    function Ne(P) {
      switch (a) {
        case i.ROTATE:
          if (r.enableRotate === !1) return;
          te(P);
          break;
        case i.DOLLY:
          if (r.enableZoom === !1) return;
          ve(P);
          break;
        case i.PAN:
          if (r.enablePan === !1) return;
          be(P);
          break;
      }
    }
    function w(P) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        a !== i.NONE ||
        (P.preventDefault(), r.dispatchEvent(Yu), Ae(P), r.dispatchEvent(dh));
    }
    function b(P) {
      r.enabled === !1 || r.enablePan === !1 || Fe(P);
    }
    function F(P) {
      switch ((ee(P), T.length)) {
        case 1:
          switch (r.touches.ONE) {
            case _i.ROTATE:
              if (r.enableRotate === !1) return;
              Pe(), (a = i.TOUCH_ROTATE);
              break;
            case _i.PAN:
              if (r.enablePan === !1) return;
              Te(), (a = i.TOUCH_PAN);
              break;
            default:
              a = i.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case _i.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              Ee(), (a = i.TOUCH_DOLLY_PAN);
              break;
            case _i.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              H(), (a = i.TOUCH_DOLLY_ROTATE);
              break;
            default:
              a = i.NONE;
          }
          break;
        default:
          a = i.NONE;
      }
      a !== i.NONE && r.dispatchEvent(Yu);
    }
    function V(P) {
      switch ((ee(P), a)) {
        case i.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          we(P), r.update();
          break;
        case i.TOUCH_PAN:
          if (r.enablePan === !1) return;
          he(P), r.update();
          break;
        case i.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          ge(P), r.update();
          break;
        case i.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          Ue(P), r.update();
          break;
        default:
          a = i.NONE;
      }
    }
    function j(P) {
      r.enabled !== !1 && P.preventDefault();
    }
    function X(P) {
      T.push(P);
    }
    function oe(P) {
      delete N[P.pointerId];
      for (let ue = 0; ue < T.length; ue++)
        if (T[ue].pointerId == P.pointerId) {
          T.splice(ue, 1);
          return;
        }
    }
    function ee(P) {
      let ue = N[P.pointerId];
      ue === void 0 && ((ue = new De()), (N[P.pointerId] = ue)),
        ue.set(P.pageX, P.pageY);
    }
    function q(P) {
      const ue = P.pointerId === T[0].pointerId ? T[1] : T[0];
      return N[ue.pointerId];
    }
    r.domElement.addEventListener("contextmenu", j),
      r.domElement.addEventListener("pointerdown", J),
      r.domElement.addEventListener("pointercancel", ce),
      r.domElement.addEventListener("wheel", w, { passive: !1 }),
      this.update();
  }
}
const qr = new lm(),
  rn = new B(),
  xr = new B(),
  yt = new Ht(),
  mh = { X: new B(1, 0, 0), Y: new B(0, 1, 0), Z: new B(0, 0, 1) },
  Zu = { type: "change" },
  gh = { type: "mouseDown" },
  vh = { type: "mouseUp", mode: null },
  yh = { type: "objectChange" };
class Qw extends st {
  constructor(e, t) {
    super(),
      t === void 0 &&
        (console.warn(
          'THREE.TransformControls: The second parameter "domElement" is now mandatory.'
        ),
        (t = document)),
      (this.isTransformControls = !0),
      (this.visible = !1),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none");
    const r = new aE();
    (this._gizmo = r), this.add(r);
    const i = new sE();
    (this._plane = i), this.add(i);
    const a = this;
    function s(S, v) {
      let y = v;
      Object.defineProperty(a, S, {
        get: function () {
          return y !== void 0 ? y : v;
        },
        set: function (E) {
          y !== E &&
            ((y = E),
            (i[S] = E),
            (r[S] = E),
            a.dispatchEvent({ type: S + "-changed", value: E }),
            a.dispatchEvent(Zu));
        },
      }),
        (a[S] = v),
        (i[S] = v),
        (r[S] = v);
    }
    s("camera", e),
      s("object", void 0),
      s("enabled", !0),
      s("axis", null),
      s("mode", "translate"),
      s("translationSnap", null),
      s("rotationSnap", null),
      s("scaleSnap", null),
      s("space", "world"),
      s("size", 1),
      s("dragging", !1),
      s("showX", !0),
      s("showY", !0),
      s("showZ", !0);
    const o = new B(),
      c = new B(),
      u = new Ht(),
      l = new Ht(),
      f = new B(),
      h = new Ht(),
      d = new B(),
      g = new B(),
      x = new B(),
      m = 0,
      p = new B();
    s("worldPosition", o),
      s("worldPositionStart", c),
      s("worldQuaternion", u),
      s("worldQuaternionStart", l),
      s("cameraPosition", f),
      s("cameraQuaternion", h),
      s("pointStart", d),
      s("pointEnd", g),
      s("rotationAxis", x),
      s("rotationAngle", m),
      s("eye", p),
      (this._offset = new B()),
      (this._startNorm = new B()),
      (this._endNorm = new B()),
      (this._cameraScale = new B()),
      (this._parentPosition = new B()),
      (this._parentQuaternion = new Ht()),
      (this._parentQuaternionInv = new Ht()),
      (this._parentScale = new B()),
      (this._worldScaleStart = new B()),
      (this._worldQuaternionInv = new Ht()),
      (this._worldScale = new B()),
      (this._positionStart = new B()),
      (this._quaternionStart = new Ht()),
      (this._scaleStart = new B()),
      (this._getPointer = eE.bind(this)),
      (this._onPointerDown = nE.bind(this)),
      (this._onPointerHover = tE.bind(this)),
      (this._onPointerMove = rE.bind(this)),
      (this._onPointerUp = iE.bind(this)),
      this.domElement.addEventListener("pointerdown", this._onPointerDown),
      this.domElement.addEventListener("pointermove", this._onPointerHover),
      this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 &&
      (this.object.updateMatrixWorld(),
      this.object.parent === null
        ? console.error(
            "TransformControls: The attached 3D object must be a part of the scene graph."
          )
        : this.object.parent.matrixWorld.decompose(
            this._parentPosition,
            this._parentQuaternion,
            this._parentScale
          ),
      this.object.matrixWorld.decompose(
        this.worldPosition,
        this.worldQuaternion,
        this._worldScale
      ),
      this._parentQuaternionInv.copy(this._parentQuaternion).invert(),
      this._worldQuaternionInv.copy(this.worldQuaternion).invert()),
      this.camera.updateMatrixWorld(),
      this.camera.matrixWorld.decompose(
        this.cameraPosition,
        this.cameraQuaternion,
        this._cameraScale
      ),
      this.camera.isOrthographicCamera
        ? this.camera.getWorldDirection(this.eye).negate()
        : this.eye
            .copy(this.cameraPosition)
            .sub(this.worldPosition)
            .normalize(),
      super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    qr.setFromCamera(e, this.camera);
    const t = Ju(this._gizmo.picker[this.mode], qr);
    t ? (this.axis = t.object.name) : (this.axis = null);
  }
  pointerDown(e) {
    if (
      !(this.object === void 0 || this.dragging === !0 || e.button !== 0) &&
      this.axis !== null
    ) {
      qr.setFromCamera(e, this.camera);
      const t = Ju(this._plane, qr, !0);
      t &&
        (this.object.updateMatrixWorld(),
        this.object.parent.updateMatrixWorld(),
        this._positionStart.copy(this.object.position),
        this._quaternionStart.copy(this.object.quaternion),
        this._scaleStart.copy(this.object.scale),
        this.object.matrixWorld.decompose(
          this.worldPositionStart,
          this.worldQuaternionStart,
          this._worldScaleStart
        ),
        this.pointStart.copy(t.point).sub(this.worldPositionStart)),
        (this.dragging = !0),
        (gh.mode = this.mode),
        this.dispatchEvent(gh);
    }
  }
  pointerMove(e) {
    const t = this.axis,
      r = this.mode,
      i = this.object;
    let a = this.space;
    if (
      (r === "scale"
        ? (a = "local")
        : (t === "E" || t === "XYZE" || t === "XYZ") && (a = "world"),
      i === void 0 || t === null || this.dragging === !1 || e.button !== -1)
    )
      return;
    qr.setFromCamera(e, this.camera);
    const s = Ju(this._plane, qr, !0);
    if (s) {
      if (
        (this.pointEnd.copy(s.point).sub(this.worldPositionStart),
        r === "translate")
      )
        this._offset.copy(this.pointEnd).sub(this.pointStart),
          a === "local" &&
            t !== "XYZ" &&
            this._offset.applyQuaternion(this._worldQuaternionInv),
          t.indexOf("X") === -1 && (this._offset.x = 0),
          t.indexOf("Y") === -1 && (this._offset.y = 0),
          t.indexOf("Z") === -1 && (this._offset.z = 0),
          a === "local" && t !== "XYZ"
            ? this._offset
                .applyQuaternion(this._quaternionStart)
                .divide(this._parentScale)
            : this._offset
                .applyQuaternion(this._parentQuaternionInv)
                .divide(this._parentScale),
          i.position.copy(this._offset).add(this._positionStart),
          this.translationSnap &&
            (a === "local" &&
              (i.position.applyQuaternion(
                yt.copy(this._quaternionStart).invert()
              ),
              t.search("X") !== -1 &&
                (i.position.x =
                  Math.round(i.position.x / this.translationSnap) *
                  this.translationSnap),
              t.search("Y") !== -1 &&
                (i.position.y =
                  Math.round(i.position.y / this.translationSnap) *
                  this.translationSnap),
              t.search("Z") !== -1 &&
                (i.position.z =
                  Math.round(i.position.z / this.translationSnap) *
                  this.translationSnap),
              i.position.applyQuaternion(this._quaternionStart)),
            a === "world" &&
              (i.parent &&
                i.position.add(rn.setFromMatrixPosition(i.parent.matrixWorld)),
              t.search("X") !== -1 &&
                (i.position.x =
                  Math.round(i.position.x / this.translationSnap) *
                  this.translationSnap),
              t.search("Y") !== -1 &&
                (i.position.y =
                  Math.round(i.position.y / this.translationSnap) *
                  this.translationSnap),
              t.search("Z") !== -1 &&
                (i.position.z =
                  Math.round(i.position.z / this.translationSnap) *
                  this.translationSnap),
              i.parent &&
                i.position.sub(
                  rn.setFromMatrixPosition(i.parent.matrixWorld)
                )));
      else if (r === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), xr.set(o, o, o);
        } else
          rn.copy(this.pointStart),
            xr.copy(this.pointEnd),
            rn.applyQuaternion(this._worldQuaternionInv),
            xr.applyQuaternion(this._worldQuaternionInv),
            xr.divide(rn),
            t.search("X") === -1 && (xr.x = 1),
            t.search("Y") === -1 && (xr.y = 1),
            t.search("Z") === -1 && (xr.z = 1);
        i.scale.copy(this._scaleStart).multiply(xr),
          this.scaleSnap &&
            (t.search("X") !== -1 &&
              (i.scale.x =
                Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap),
            t.search("Y") !== -1 &&
              (i.scale.y =
                Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap),
            t.search("Z") !== -1 &&
              (i.scale.z =
                Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap));
      } else if (r === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o =
          20 /
          this.worldPosition.distanceTo(
            rn.setFromMatrixPosition(this.camera.matrixWorld)
          );
        t === "E"
          ? (this.rotationAxis.copy(this.eye),
            (this.rotationAngle = this.pointEnd.angleTo(this.pointStart)),
            this._startNorm.copy(this.pointStart).normalize(),
            this._endNorm.copy(this.pointEnd).normalize(),
            (this.rotationAngle *=
              this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1))
          : t === "XYZE"
          ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),
            (this.rotationAngle =
              this._offset.dot(rn.copy(this.rotationAxis).cross(this.eye)) * o))
          : (t === "X" || t === "Y" || t === "Z") &&
            (this.rotationAxis.copy(mh[t]),
            rn.copy(mh[t]),
            a === "local" && rn.applyQuaternion(this.worldQuaternion),
            (this.rotationAngle =
              this._offset.dot(rn.cross(this.eye).normalize()) * o)),
          this.rotationSnap &&
            (this.rotationAngle =
              Math.round(this.rotationAngle / this.rotationSnap) *
              this.rotationSnap),
          a === "local" && t !== "E" && t !== "XYZE"
            ? (i.quaternion.copy(this._quaternionStart),
              i.quaternion
                .multiply(
                  yt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)
                )
                .normalize())
            : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv),
              i.quaternion.copy(
                yt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)
              ),
              i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Zu), this.dispatchEvent(yh);
    }
  }
  pointerUp(e) {
    e.button === 0 &&
      (this.dragging &&
        this.axis !== null &&
        ((vh.mode = this.mode), this.dispatchEvent(vh)),
      (this.dragging = !1),
      (this.axis = null));
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown),
      this.domElement.removeEventListener("pointermove", this._onPointerHover),
      this.domElement.removeEventListener("pointermove", this._onPointerMove),
      this.domElement.removeEventListener("pointerup", this._onPointerUp),
      this.traverse(function (e) {
        e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
      });
  }
  attach(e) {
    return (this.object = e), (this.visible = !0), this;
  }
  detach() {
    return (
      (this.object = void 0), (this.visible = !1), (this.axis = null), this
    );
  }
  reset() {
    this.enabled &&
      this.dragging &&
      (this.object.position.copy(this._positionStart),
      this.object.quaternion.copy(this._quaternionStart),
      this.object.scale.copy(this._scaleStart),
      this.dispatchEvent(Zu),
      this.dispatchEvent(yh),
      this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return qr;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function eE(n) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return { x: 0, y: 0, button: n.button };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: ((n.clientX - e.left) / e.width) * 2 - 1,
      y: (-(n.clientY - e.top) / e.height) * 2 + 1,
      button: n.button,
    };
  }
}
function tE(n) {
  if (this.enabled)
    switch (n.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(n));
        break;
    }
}
function nE(n) {
  this.enabled &&
    (document.pointerLockElement ||
      this.domElement.setPointerCapture(n.pointerId),
    this.domElement.addEventListener("pointermove", this._onPointerMove),
    this.pointerHover(this._getPointer(n)),
    this.pointerDown(this._getPointer(n)));
}
function rE(n) {
  this.enabled && this.pointerMove(this._getPointer(n));
}
function iE(n) {
  this.enabled &&
    (this.domElement.releasePointerCapture(n.pointerId),
    this.domElement.removeEventListener("pointermove", this._onPointerMove),
    this.pointerUp(this._getPointer(n)));
}
function Ju(n, e, t) {
  const r = e.intersectObject(n, !0);
  for (let i = 0; i < r.length; i++) if (r[i].object.visible || t) return r[i];
  return !1;
}
const Js = new ms(),
  ht = new B(0, 1, 0),
  xh = new B(0, 0, 0),
  bh = new ut(),
  Ks = new Ht(),
  _o = new Ht(),
  Bn = new B(),
  _h = new ut(),
  Ha = new B(1, 0, 0),
  Xr = new B(0, 1, 0),
  Ga = new B(0, 0, 1),
  Qs = new B(),
  Pa = new B(),
  La = new B();
class aE extends st {
  constructor() {
    super(),
      (this.isTransformControlsGizmo = !0),
      (this.type = "TransformControlsGizmo");
    const e = new Vn({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0,
      }),
      t = new hi({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0,
      }),
      r = e.clone();
    r.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const a = e.clone();
    a.color.setHex(16711680);
    const s = e.clone();
    s.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), (c.opacity = 0.5);
    const u = e.clone();
    u.color.setHex(65280), (u.opacity = 0.5);
    const l = e.clone();
    l.color.setHex(255), (l.opacity = 0.5);
    const f = e.clone();
    f.opacity = 0.25;
    const h = e.clone();
    h.color.setHex(16776960),
      (h.opacity = 0.25),
      e.clone().color.setHex(16776960);
    const g = e.clone();
    g.color.setHex(7895160);
    const x = new Ot(0, 0.04, 0.1, 12);
    x.translate(0, 0.05, 0);
    const m = new mt(0.08, 0.08, 0.08);
    m.translate(0, 0.04, 0);
    const p = new wt();
    p.setAttribute("position", new nt([0, 0, 0, 1, 0, 0], 3));
    const S = new Ot(0.0075, 0.0075, 0.5, 3);
    S.translate(0, 0.25, 0);
    function v(L, C) {
      const k = new Zr(L, 0.0075, 3, 64, C * Math.PI * 2);
      return k.rotateY(Math.PI / 2), k.rotateX(Math.PI / 2), k;
    }
    function y() {
      const L = new wt();
      return L.setAttribute("position", new nt([0, 0, 0, 1, 1, 1], 3)), L;
    }
    const E = {
        X: [
          [new Re(x, a), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
          [new Re(x, a), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
          [new Re(S, a), [0, 0, 0], [0, 0, -Math.PI / 2]],
        ],
        Y: [
          [new Re(x, s), [0, 0.5, 0]],
          [new Re(x, s), [0, -0.5, 0], [Math.PI, 0, 0]],
          [new Re(S, s)],
        ],
        Z: [
          [new Re(x, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
          [new Re(x, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
          [new Re(S, o), null, [Math.PI / 2, 0, 0]],
        ],
        XYZ: [[new Re(new Xi(0.1, 0), f.clone()), [0, 0, 0]]],
        XY: [[new Re(new mt(0.15, 0.15, 0.01), l.clone()), [0.15, 0.15, 0]]],
        YZ: [
          [
            new Re(new mt(0.15, 0.15, 0.01), c.clone()),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new Re(new mt(0.15, 0.15, 0.01), u.clone()),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
      },
      M = {
        X: [
          [
            new Re(new Ot(0.2, 0, 0.6, 4), r),
            [0.3, 0, 0],
            [0, 0, -Math.PI / 2],
          ],
          [
            new Re(new Ot(0.2, 0, 0.6, 4), r),
            [-0.3, 0, 0],
            [0, 0, Math.PI / 2],
          ],
        ],
        Y: [
          [new Re(new Ot(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
          [new Re(new Ot(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new Re(new Ot(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
          [
            new Re(new Ot(0.2, 0, 0.6, 4), r),
            [0, 0, -0.3],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new Re(new Xi(0.2, 0), r)]],
        XY: [[new Re(new mt(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]],
        YZ: [
          [
            new Re(new mt(0.2, 0.2, 0.01), r),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new Re(new mt(0.2, 0.2, 0.01), r),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
      },
      T = {
        START: [[new Re(new Xi(0.01, 2), i), null, null, null, "helper"]],
        END: [[new Re(new Xi(0.01, 2), i), null, null, null, "helper"]],
        DELTA: [[new _n(y(), i), null, null, null, "helper"]],
        X: [[new _n(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [
          [
            new _n(p, i.clone()),
            [0, -1e3, 0],
            [0, 0, Math.PI / 2],
            [1e6, 1, 1],
            "helper",
          ],
        ],
        Z: [
          [
            new _n(p, i.clone()),
            [0, 0, -1e3],
            [0, -Math.PI / 2, 0],
            [1e6, 1, 1],
            "helper",
          ],
        ],
      },
      N = {
        XYZE: [[new Re(v(0.5, 1), g), null, [0, Math.PI / 2, 0]]],
        X: [[new Re(v(0.5, 0.5), a)]],
        Y: [[new Re(v(0.5, 0.5), s), null, [0, 0, -Math.PI / 2]]],
        Z: [[new Re(v(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]],
        E: [[new Re(v(0.75, 1), h), null, [0, Math.PI / 2, 0]]],
      },
      A = {
        AXIS: [
          [new _n(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"],
        ],
      },
      D = {
        XYZE: [[new Re(new di(0.25, 10, 8), r)]],
        X: [
          [
            new Re(new Zr(0.5, 0.1, 4, 24), r),
            [0, 0, 0],
            [0, -Math.PI / 2, -Math.PI / 2],
          ],
        ],
        Y: [
          [new Re(new Zr(0.5, 0.1, 4, 24), r), [0, 0, 0], [Math.PI / 2, 0, 0]],
        ],
        Z: [
          [new Re(new Zr(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, 0, -Math.PI / 2]],
        ],
        E: [[new Re(new Zr(0.75, 0.1, 2, 24), r)]],
      },
      z = {
        X: [
          [new Re(m, a), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
          [new Re(S, a), [0, 0, 0], [0, 0, -Math.PI / 2]],
          [new Re(m, a), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        ],
        Y: [
          [new Re(m, s), [0, 0.5, 0]],
          [new Re(S, s)],
          [new Re(m, s), [0, -0.5, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new Re(m, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
          [new Re(S, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
          [new Re(m, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        ],
        XY: [[new Re(new mt(0.15, 0.15, 0.01), l), [0.15, 0.15, 0]]],
        YZ: [
          [
            new Re(new mt(0.15, 0.15, 0.01), c),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new Re(new mt(0.15, 0.15, 0.01), u),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new Re(new mt(0.1, 0.1, 0.1), f.clone())]],
      },
      $ = {
        X: [
          [
            new Re(new Ot(0.2, 0, 0.6, 4), r),
            [0.3, 0, 0],
            [0, 0, -Math.PI / 2],
          ],
          [
            new Re(new Ot(0.2, 0, 0.6, 4), r),
            [-0.3, 0, 0],
            [0, 0, Math.PI / 2],
          ],
        ],
        Y: [
          [new Re(new Ot(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
          [new Re(new Ot(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new Re(new Ot(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
          [
            new Re(new Ot(0.2, 0, 0.6, 4), r),
            [0, 0, -0.3],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XY: [[new Re(new mt(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]],
        YZ: [
          [
            new Re(new mt(0.2, 0.2, 0.01), r),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new Re(new mt(0.2, 0.2, 0.01), r),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new Re(new mt(0.2, 0.2, 0.2), r), [0, 0, 0]]],
      },
      I = {
        X: [[new _n(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [
          [
            new _n(p, i.clone()),
            [0, -1e3, 0],
            [0, 0, Math.PI / 2],
            [1e6, 1, 1],
            "helper",
          ],
        ],
        Z: [
          [
            new _n(p, i.clone()),
            [0, 0, -1e3],
            [0, -Math.PI / 2, 0],
            [1e6, 1, 1],
            "helper",
          ],
        ],
      };
    function G(L) {
      const C = new st();
      for (const k in L)
        for (let Z = L[k].length; Z--; ) {
          const ie = L[k][Z][0].clone(),
            ne = L[k][Z][1],
            Y = L[k][Z][2],
            W = L[k][Z][3],
            te = L[k][Z][4];
          (ie.name = k),
            (ie.tag = te),
            ne && ie.position.set(ne[0], ne[1], ne[2]),
            Y && ie.rotation.set(Y[0], Y[1], Y[2]),
            W && ie.scale.set(W[0], W[1], W[2]),
            ie.updateMatrix();
          const ve = ie.geometry.clone();
          ve.applyMatrix4(ie.matrix),
            (ie.geometry = ve),
            (ie.renderOrder = 1 / 0),
            ie.position.set(0, 0, 0),
            ie.rotation.set(0, 0, 0),
            ie.scale.set(1, 1, 1),
            C.add(ie);
        }
      return C;
    }
    (this.gizmo = {}),
      (this.picker = {}),
      (this.helper = {}),
      this.add((this.gizmo.translate = G(E))),
      this.add((this.gizmo.rotate = G(N))),
      this.add((this.gizmo.scale = G(z))),
      this.add((this.picker.translate = G(M))),
      this.add((this.picker.rotate = G(D))),
      this.add((this.picker.scale = G($))),
      this.add((this.helper.translate = G(T))),
      this.add((this.helper.rotate = G(A))),
      this.add((this.helper.scale = G(I))),
      (this.picker.translate.visible = !1),
      (this.picker.rotate.visible = !1),
      (this.picker.scale.visible = !1);
  }
  updateMatrixWorld(e) {
    const r =
      (this.mode === "scale" ? "local" : this.space) === "local"
        ? this.worldQuaternion
        : _o;
    (this.gizmo.translate.visible = this.mode === "translate"),
      (this.gizmo.rotate.visible = this.mode === "rotate"),
      (this.gizmo.scale.visible = this.mode === "scale"),
      (this.helper.translate.visible = this.mode === "translate"),
      (this.helper.rotate.visible = this.mode === "rotate"),
      (this.helper.scale.visible = this.mode === "scale");
    let i = [];
    (i = i.concat(this.picker[this.mode].children)),
      (i = i.concat(this.gizmo[this.mode].children)),
      (i = i.concat(this.helper[this.mode].children));
    for (let a = 0; a < i.length; a++) {
      const s = i[a];
      (s.visible = !0),
        s.rotation.set(0, 0, 0),
        s.position.copy(this.worldPosition);
      let o;
      if (
        (this.camera.isOrthographicCamera
          ? (o = (this.camera.top - this.camera.bottom) / this.camera.zoom)
          : (o =
              this.worldPosition.distanceTo(this.cameraPosition) *
              Math.min(
                (1.9 * Math.tan((Math.PI * this.camera.fov) / 360)) /
                  this.camera.zoom,
                7
              )),
        s.scale.set(1, 1, 1).multiplyScalar((o * this.size) / 4),
        s.tag === "helper")
      ) {
        (s.visible = !1),
          s.name === "AXIS"
            ? ((s.visible = !!this.axis),
              this.axis === "X" &&
                (yt.setFromEuler(Js.set(0, 0, 0)),
                s.quaternion.copy(r).multiply(yt),
                Math.abs(ht.copy(Ha).applyQuaternion(r).dot(this.eye)) > 0.9 &&
                  (s.visible = !1)),
              this.axis === "Y" &&
                (yt.setFromEuler(Js.set(0, 0, Math.PI / 2)),
                s.quaternion.copy(r).multiply(yt),
                Math.abs(ht.copy(Xr).applyQuaternion(r).dot(this.eye)) > 0.9 &&
                  (s.visible = !1)),
              this.axis === "Z" &&
                (yt.setFromEuler(Js.set(0, Math.PI / 2, 0)),
                s.quaternion.copy(r).multiply(yt),
                Math.abs(ht.copy(Ga).applyQuaternion(r).dot(this.eye)) > 0.9 &&
                  (s.visible = !1)),
              this.axis === "XYZE" &&
                (yt.setFromEuler(Js.set(0, Math.PI / 2, 0)),
                ht.copy(this.rotationAxis),
                s.quaternion.setFromRotationMatrix(bh.lookAt(xh, ht, Xr)),
                s.quaternion.multiply(yt),
                (s.visible = this.dragging)),
              this.axis === "E" && (s.visible = !1))
            : s.name === "START"
            ? (s.position.copy(this.worldPositionStart),
              (s.visible = this.dragging))
            : s.name === "END"
            ? (s.position.copy(this.worldPosition), (s.visible = this.dragging))
            : s.name === "DELTA"
            ? (s.position.copy(this.worldPositionStart),
              s.quaternion.copy(this.worldQuaternionStart),
              rn
                .set(1e-10, 1e-10, 1e-10)
                .add(this.worldPositionStart)
                .sub(this.worldPosition)
                .multiplyScalar(-1),
              rn.applyQuaternion(this.worldQuaternionStart.clone().invert()),
              s.scale.copy(rn),
              (s.visible = this.dragging))
            : (s.quaternion.copy(r),
              this.dragging
                ? s.position.copy(this.worldPositionStart)
                : s.position.copy(this.worldPosition),
              this.axis && (s.visible = this.axis.search(s.name) !== -1));
        continue;
      }
      s.quaternion.copy(r),
        this.mode === "translate" || this.mode === "scale"
          ? (s.name === "X" &&
              Math.abs(ht.copy(Ha).applyQuaternion(r).dot(this.eye)) > 0.99 &&
              (s.scale.set(1e-10, 1e-10, 1e-10), (s.visible = !1)),
            s.name === "Y" &&
              Math.abs(ht.copy(Xr).applyQuaternion(r).dot(this.eye)) > 0.99 &&
              (s.scale.set(1e-10, 1e-10, 1e-10), (s.visible = !1)),
            s.name === "Z" &&
              Math.abs(ht.copy(Ga).applyQuaternion(r).dot(this.eye)) > 0.99 &&
              (s.scale.set(1e-10, 1e-10, 1e-10), (s.visible = !1)),
            s.name === "XY" &&
              Math.abs(ht.copy(Ga).applyQuaternion(r).dot(this.eye)) < 0.2 &&
              (s.scale.set(1e-10, 1e-10, 1e-10), (s.visible = !1)),
            s.name === "YZ" &&
              Math.abs(ht.copy(Ha).applyQuaternion(r).dot(this.eye)) < 0.2 &&
              (s.scale.set(1e-10, 1e-10, 1e-10), (s.visible = !1)),
            s.name === "XZ" &&
              Math.abs(ht.copy(Xr).applyQuaternion(r).dot(this.eye)) < 0.2 &&
              (s.scale.set(1e-10, 1e-10, 1e-10), (s.visible = !1)))
          : this.mode === "rotate" &&
            (Ks.copy(r),
            ht.copy(this.eye).applyQuaternion(yt.copy(r).invert()),
            s.name.search("E") !== -1 &&
              s.quaternion.setFromRotationMatrix(bh.lookAt(this.eye, xh, Xr)),
            s.name === "X" &&
              (yt.setFromAxisAngle(Ha, Math.atan2(-ht.y, ht.z)),
              yt.multiplyQuaternions(Ks, yt),
              s.quaternion.copy(yt)),
            s.name === "Y" &&
              (yt.setFromAxisAngle(Xr, Math.atan2(ht.x, ht.z)),
              yt.multiplyQuaternions(Ks, yt),
              s.quaternion.copy(yt)),
            s.name === "Z" &&
              (yt.setFromAxisAngle(Ga, Math.atan2(ht.y, ht.x)),
              yt.multiplyQuaternions(Ks, yt),
              s.quaternion.copy(yt))),
        (s.visible = s.visible && (s.name.indexOf("X") === -1 || this.showX)),
        (s.visible = s.visible && (s.name.indexOf("Y") === -1 || this.showY)),
        (s.visible = s.visible && (s.name.indexOf("Z") === -1 || this.showZ)),
        (s.visible =
          s.visible &&
          (s.name.indexOf("E") === -1 ||
            (this.showX && this.showY && this.showZ))),
        (s.material._color = s.material._color || s.material.color.clone()),
        (s.material._opacity = s.material._opacity || s.material.opacity),
        s.material.color.copy(s.material._color),
        (s.material.opacity = s.material._opacity),
        this.enabled &&
          this.axis &&
          (s.name === this.axis ||
            this.axis.split("").some(function (c) {
              return s.name === c;
            })) &&
          (s.material.color.setHex(16776960), (s.material.opacity = 1));
    }
    super.updateMatrixWorld(e);
  }
}
class sE extends Re {
  constructor() {
    super(
      new ga(1e5, 1e5, 2, 2),
      new Vn({
        visible: !1,
        wireframe: !0,
        side: jt,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1,
      })
    ),
      (this.isTransformControlsPlane = !0),
      (this.type = "TransformControlsPlane");
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (
      (this.position.copy(this.worldPosition),
      this.mode === "scale" && (t = "local"),
      Qs.copy(Ha).applyQuaternion(t === "local" ? this.worldQuaternion : _o),
      Pa.copy(Xr).applyQuaternion(t === "local" ? this.worldQuaternion : _o),
      La.copy(Ga).applyQuaternion(t === "local" ? this.worldQuaternion : _o),
      ht.copy(Pa),
      this.mode)
    ) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            ht.copy(this.eye).cross(Qs), Bn.copy(Qs).cross(ht);
            break;
          case "Y":
            ht.copy(this.eye).cross(Pa), Bn.copy(Pa).cross(ht);
            break;
          case "Z":
            ht.copy(this.eye).cross(La), Bn.copy(La).cross(ht);
            break;
          case "XY":
            Bn.copy(La);
            break;
          case "YZ":
            Bn.copy(Qs);
            break;
          case "XZ":
            ht.copy(La), Bn.copy(Pa);
            break;
          case "XYZ":
          case "E":
            Bn.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Bn.set(0, 0, 0);
    }
    Bn.length() === 0
      ? this.quaternion.copy(this.cameraQuaternion)
      : (_h.lookAt(rn.set(0, 0, 0), Bn, ht),
        this.quaternion.setFromRotationMatrix(_h)),
      super.updateMatrixWorld(e);
  }
}
function oE() {
  return new B(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
}
function uE(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
const Qc = { randomPoint: oE, capitalize: uE };
function cE(n, e) {
  console.log(n, e);
  let t = -500,
    r = 900;
  return (
    n < 200 &&
      n > -200 &&
      e < 200 &&
      e > -200 &&
      (console.log("center"), (t = 700)),
    Math.random() * (r - t) + t
  );
}
function wh(n) {
  let e, t;
  if (n >= 200) (e = 1500), (t = 3e3);
  else if (n <= -200) (e = -1500), (t = -3e3);
  else return 0;
  return Math.random() * (t - e) + e;
}
const lE = new mt(1, 1, 1),
  Eh = new Vn({ transparent: !0, opacity: 0 }),
  Sh = new Vn({ transparent: !0, opacity: 0.2, color: 65280 }),
  bn = class bn {
    constructor(e = void 0) {
      (this.mesh = new Re(e || lE, bn.debugState ? Sh : Eh)),
        bn.instances.push(this);
    }
    static toggleDebug() {
      (bn.debugState = !bn.debugState),
        bn.instances.forEach(
          (e) => (e.mesh.material = bn.debugState ? Sh : Eh)
        );
    }
    static removeInstance(e) {
      bn.instances = bn.instances.filter((t) => t.mesh !== e);
    }
    handler(e, t, r) {
      e !== void 0 &&
        e.addEventListener("dragging-changed", (i) => {
          i.value &&
            e.addEventListener("objectChange", () => {
              r.position.copy(t.position);
            });
        });
    }
  };
fn(bn, "debugState", !0), fn(bn, "instances", []);
let Un = bn;
function fE(n) {
  n.domElement.toBlob((t) => {
    const r = URL.createObjectURL(t),
      i = hE(),
      a = document.createElement("a");
    (a.href = r),
      (a.download = "generative-world-" + i + ".png"),
      a.click(),
      URL.revokeObjectURL(r);
  }, "image/png");
}
function hE() {
  const n = new Date(),
    e = n.getFullYear().toString().slice(-2),
    t = (n.getMonth() + 1).toString().padStart(2, "0"),
    r = n.getDate().toString().padStart(2, "0"),
    i = n.getHours().toString().padStart(2, "0"),
    a = n.getMinutes().toString().padStart(2, "0"),
    s = n.getSeconds().toString().padStart(2, "0");
  return `${e}-${t}-${r}-${i}${a}${s}`;
}
function dE() {
  hm(
    "Bienvenue à la Fabrique des Mondes, le seul endroit où tu peux créer des univers à ton image ! Nous sommes ravis de t'accueillir parmi nous et de t'avoir comme nouvel employé. ",
    "Suivant"
  ),
    document
      .querySelector(".popup-content button")
      .addEventListener("click", pE);
}
function hm(n, e) {
  (document.getElementById("popupContent").textContent = n),
    (document.querySelector(".popup-content button").textContent = e),
    (document.getElementById("popup").style.display = "block");
}
function Mh() {
  document.getElementById("popup").style.display = "none";
}
function pE() {
  Mh(),
    hm(
      "Bienvenue dans ton nouveau bureau ! Avec vue panoramique sur tes futures planètes ! Ici, l'imagination est la seule limite, et nous sommes impatients de voir les mondes incroyables que tu vas contribuer à fabriquer. N'hésite pas à explorer, créer et innover. Ton voyage commence maintenant, et nous sommes certains qu'il sera aussi passionnant que les mondes que tu vas concevoir 🌌🚀✨",
      "À toi de jouer !"
    ),
    document
      .querySelector(".popup-content button")
      .addEventListener("click", function () {
        Mh();
      });
}
const ft = {
    BOID_COUNT: 9,
    WORLD_SCALE: 20,
    VISUAL_RANGE: 0.5,
    SEPARATION_MIN_DISTANCE: 0.5,
    SPEED_LIMIT: 0.1,
    COHESION_FACTOR: 0.2,
    SEPARATION_FACTOR: 0.9,
    ALIGNMENT_FACTOR: 0.2,
    WALL_MARGIN: 0.05,
    WALL_TURN_FACTOR: 0.1,
  },
  Ia = {
    cohesion: (n, e) => {
      let t = 0,
        r = new B();
      e.boids
        .filter((i) => i !== n)
        .forEach((i) => {
          n.isNear(i) && (++t, r.add(i.position));
        }),
        t > 0 &&
          (r.divideScalar(t),
          n.movement.add(r.sub(n.position).multiplyScalar(ft.COHESION_FACTOR)));
    },
    separation: (n, e) => {
      let t = new B();
      e.boids
        .filter((r) => r !== n)
        .forEach((r) => {
          n.isNear(r, ft.SEPARATION_MIN_DISTANCE) &&
            t.add(n.position.clone().sub(r.position));
        }),
        n.movement.add(t.multiplyScalar(ft.SEPARATION_FACTOR));
    },
    alignment: (n, e) => {
      let t = 0,
        r = new B();
      e.boids
        .filter((i) => i !== n)
        .forEach((i) => {
          n.isNear(i) && (++t, r.add(i.movement));
        }),
        t > 0 &&
          (r.divideScalar(t),
          n.movement.add(r.multiplyScalar(ft.ALIGNMENT_FACTOR)));
    },
    speedLimiter: (n, e) => {
      let t = n.movement.length();
      t > ft.SPEED_LIMIT && n.movement.multiplyScalar(ft.SPEED_LIMIT / t);
    },
    stayInBounds: (n, e) => {
      n.position.x < -ft.WORLD_SCALE + ft.WALL_MARGIN &&
        (n.movement.x += ft.WALL_TURN_FACTOR),
        n.position.x > ft.WORLD_SCALE - ft.WALL_MARGIN &&
          (n.movement.x -= ft.WALL_TURN_FACTOR),
        n.position.y < -ft.WORLD_SCALE + ft.WALL_MARGIN &&
          (n.movement.y += ft.WALL_TURN_FACTOR),
        n.position.y > ft.WORLD_SCALE - ft.WALL_MARGIN &&
          (n.movement.y -= ft.WALL_TURN_FACTOR),
        n.position.z < -ft.WORLD_SCALE + ft.WALL_MARGIN &&
          (n.movement.z += ft.WALL_TURN_FACTOR),
        n.position.z > ft.WORLD_SCALE - ft.WALL_MARGIN &&
          (n.movement.z -= ft.WALL_TURN_FACTOR);
    },
  };
class mE {
  constructor(e, t) {
    (this.position = e),
      (this.movement = Qc.randomPoint()),
      (this.mesh = t.clone()),
      (this.behaviors = [
        Ia.stayInBounds,
        Ia.alignment,
        Ia.cohesion,
        Ia.separation,
        Ia.speedLimiter,
      ]);
  }
  isNear(e, t = ft.VISUAL_RANGE) {
    return this.position.distanceTo(e.position) < t;
  }
  update(e) {
    this.behaviors.forEach((t) => t(this, e)), this.position.add(this.movement);
  }
  render() {
    this.mesh.lookAt(this.movement),
      this.mesh.rotateOnAxis(new B(0, 1, 0), Math.PI / 2),
      this.mesh.position.copy(this.position);
  }
}
class dm {
  constructor(e, t = void 0) {
    (this.boids = []),
      (this.anchor = new st()),
      (this.mesh = e),
      (this.control = t),
      (this.hitbox = new Un()),
      this.hitbox.handler(this.control, this.hitbox.mesh, this.anchor),
      this.anchor.add(this.hitbox.mesh);
  }
  create() {
    this.boids = [];
    for (let e = 0; e < ft.BOID_COUNT; ++e) {
      let t = new mE(Qc.randomPoint(), this.mesh);
      this.boids.push(t), this.anchor.add(t.mesh);
    }
    console.log("Created " + ft.BOID_COUNT + " boids.");
  }
  update() {
    this.boids.forEach((e) => e.update(this));
  }
  render() {
    this.boids.forEach((e) => e.render());
  }
}
function gE(n, e = !1) {
  const t = n[0].index !== null,
    r = new Set(Object.keys(n[0].attributes)),
    i = new Set(Object.keys(n[0].morphAttributes)),
    a = {},
    s = {},
    o = n[0].morphTargetsRelative,
    c = new wt();
  let u = 0;
  for (let l = 0; l < n.length; ++l) {
    const f = n[l];
    let h = 0;
    if (t !== (f.index !== null))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
            l +
            ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
        ),
        null
      );
    for (const d in f.attributes) {
      if (!r.has(d))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
              l +
              '. All geometries must have compatible attributes; make sure "' +
              d +
              '" attribute exists among all geometries, or in none of them.'
          ),
          null
        );
      a[d] === void 0 && (a[d] = []), a[d].push(f.attributes[d]), h++;
    }
    if (h !== r.size)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
            l +
            ". Make sure all geometries have the same number of attributes."
        ),
        null
      );
    if (o !== f.morphTargetsRelative)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
            l +
            ". .morphTargetsRelative must be consistent throughout all geometries."
        ),
        null
      );
    for (const d in f.morphAttributes) {
      if (!i.has(d))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
              l +
              ".  .morphAttributes must be consistent throughout all geometries."
          ),
          null
        );
      s[d] === void 0 && (s[d] = []), s[d].push(f.morphAttributes[d]);
    }
    if (e) {
      let d;
      if (t) d = f.index.count;
      else if (f.attributes.position !== void 0)
        d = f.attributes.position.count;
      else
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
              l +
              ". The geometry must have either an index or a position attribute"
          ),
          null
        );
      c.addGroup(u, d, l), (u += d);
    }
  }
  if (t) {
    let l = 0;
    const f = [];
    for (let h = 0; h < n.length; ++h) {
      const d = n[h].index;
      for (let g = 0; g < d.count; ++g) f.push(d.getX(g) + l);
      l += n[h].attributes.position.count;
    }
    c.setIndex(f);
  }
  for (const l in a) {
    const f = Ah(a[l]);
    if (!f)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " +
            l +
            " attribute."
        ),
        null
      );
    c.setAttribute(l, f);
  }
  for (const l in s) {
    const f = s[l][0].length;
    if (f === 0) break;
    (c.morphAttributes = c.morphAttributes || {}), (c.morphAttributes[l] = []);
    for (let h = 0; h < f; ++h) {
      const d = [];
      for (let x = 0; x < s[l].length; ++x) d.push(s[l][x][h]);
      const g = Ah(d);
      if (!g)
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " +
              l +
              " morphAttribute."
          ),
          null
        );
      c.morphAttributes[l].push(g);
    }
  }
  return c;
}
function Ah(n) {
  let e,
    t,
    r,
    i = -1,
    a = 0;
  for (let u = 0; u < n.length; ++u) {
    const l = n[u];
    if (l.isInterleavedBufferAttribute)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."
        ),
        null
      );
    if ((e === void 0 && (e = l.array.constructor), e !== l.array.constructor))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
        ),
        null
      );
    if ((t === void 0 && (t = l.itemSize), t !== l.itemSize))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
        ),
        null
      );
    if ((r === void 0 && (r = l.normalized), r !== l.normalized))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
        ),
        null
      );
    if ((i === -1 && (i = l.gpuType), i !== l.gpuType))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."
        ),
        null
      );
    a += l.array.length;
  }
  const s = new e(a);
  let o = 0;
  for (let u = 0; u < n.length; ++u)
    s.set(n[u].array, o), (o += n[u].array.length);
  const c = new gn(s, t, r);
  return i !== void 0 && (c.gpuType = i), c;
}
const Dh = [139, 8388736, 13601266];
function vE() {
  return Dh[Math.floor(Math.random() * Dh.length)];
}
var ps, yc;
class pm {
  constructor(e = void 0) {
    Tl(this, ps);
    (this.anchor = new st()), this.hitbox, (this.control = e);
  }
  create(e) {
    this.anchor.children = [];
    const t = [];
    pu(this, ps, yc).call(this, t, new B(), 1, e);
    let r = gE(
        t.map(
          (a) => (a.updateMatrixWorld(), a.geometry.applyMatrix4(a.matrixWorld))
        ),
        !1
      ),
      i = new Re(r, new Or({ color: vE() }));
    this.anchor.add(i),
      (this.hitbox = new Un()),
      this.hitbox.handler(this.control, this.hitbox.mesh, i),
      this.anchor.add(this.hitbox.mesh),
      (this.centerPointLight = new os(16239182, 5e3)),
      this.anchor.add(this.centerPointLight);
  }
}
(ps = new WeakSet()),
  (yc = function (e, t, r, i, a = 0) {
    if (a == i) {
      const c = new mt(r, r, r);
      let u = new Re(c);
      u.position.copy(t), e.push(u);
      return;
    }
    const s = r / 3,
      o = [-1, 0, 1];
    for (let c = 0; c < 3; c++)
      for (let u = 0; u < 3; u++)
        for (let l = 0; l < 3; l++)
          Math.abs(o[c]) + Math.abs(o[u]) + Math.abs(o[l]) > 1 &&
            pu(this, ps, yc).call(
              this,
              e,
              new B(t.x + o[c] * s, t.y + o[u] * s, t.z + o[l] * s),
              s,
              i,
              a + 1
            );
  });
let Ct = {
  pointsCount: 30,
  populationMax: 500,
  mutationFrequency: 0.15,
  crossFrequency: 0.3,
  generations: 60,
  frameDelay: 500,
  weights: [0.4, 0.3, 0.17, 0.08, 0.05],
  lightColor: 16777215,
  pointColor: 16777215,
  distanceScale: 60,
};
class yE {
  constructor() {
    (this.start = xc()), this.init();
  }
  init() {
    this.points = [];
    for (let e = 0; e < Ct.pointsCount; e++) this.points[e] = xc();
  }
}
class To {
  constructor(e, t) {
    (this.pointIndex = e), (this.env = t), (this.score = this.computeScore());
  }
  length() {
    let e = 0;
    for (let t = 0; t < this.pointIndex.length - 1; t++)
      e += this.env.points[this.pointIndex[t]].distanceTo(
        this.env.points[this.pointIndex[t + 1]]
      );
    return (
      (e += this.env.start.distanceTo(this.env.points[this.pointIndex[0]])),
      (e += this.env.start.distanceTo(
        this.env.points[this.pointIndex[this.pointIndex.length - 1]]
      )),
      e
    );
  }
  isValid() {
    return new Set(this.pointIndex).size === this.pointIndex.length;
  }
  computeScore() {
    return this.isValid() ? this.length() : 999999999;
  }
  isShorterThan(e) {
    return this.length() - e.length();
  }
  isBetterThan(e) {
    return this.score - e.score;
  }
  mutate(e = 1) {
    let t = this.pointIndex.slice();
    for (let r = 0; r < e; ++r) {
      let i = Math.floor(Math.random() * t.length),
        a = Math.floor(Math.random() * t.length);
      [t[i], t[a]] = [t[a], t[i]];
    }
    return new To(t, this.env);
  }
  breed(e, t = 1) {
    let r = [],
      i = Math.floor(Math.random() * this.pointIndex.length);
    r.push(...this.pointIndex.slice(0, i));
    let a = e.pointIndex,
      s = 0;
    for (let o = i; o < this.pointIndex.length; o++) {
      for (; r.includes(a[s]) && s < this.pointIndex.length; ) s++;
      r.push(a[s]);
    }
    return new To(r, this.env);
  }
}
function xE(n) {
  const e = n.slice();
  for (let t = e.length - 1; t > 0; t--) {
    const r = Math.floor(Math.random() * (t + 1));
    [e[t], e[r]] = [e[r], e[t]];
  }
  return e;
}
function bE(n) {
  if (n < 1) throw new Error("initArray: size must be positive");
  return [...Array(n).keys()];
}
function xc() {
  return new B(
    Math.random() - 0.5,
    Math.random() - 0.5,
    Math.random() - 0.5
  ).multiplyScalar(Ct.distanceScale);
}
function Th(n, e = -1) {
  let t = Math.random(),
    r = 0;
  for (let i = 0; i < n; i++) {
    if (r + n[i] > t) {
      let a = Math.ceil(Ct.populationMax / n.length),
        s = i * a + Math.floor((((t - r) * 100) / n[i]) * a);
      return s != e ? s : s + 1 > Ct.populationMax ? s - 1 : s + 1;
    }
    r += n[i];
  }
  return Math.floor(Math.random() * Ct.populationMax);
}
class mm {
  constructor() {
    if (
      ((this.settings = Ct),
      (this.environment = new yE()),
      (this.startPosition = xc()),
      (this.anchor = new st()),
      (this.lights = new st()),
      (this.stopFlag = !1),
      Ct.pointsCount < 1)
    )
      throw new RangeError(
        "Path.generate: Cannot generate 0 points or less. Number given: " +
          Ct.pointsCount
      );
    this.setup();
  }
  setup() {
    this.lights.children = [];
    const e = new di(0.5, 8, 8);
    this.cityMesh = new Jp(
      e,
      new Vn({ color: Ct.pointColor, transparent: !0, opacity: 0.4 }),
      this.environment.points.length
    );
    for (let r = 0; r < this.environment.points.length; r++) {
      let i = new os(Ct.lightColor, 100);
      i.position.copy(this.environment.points[r]),
        this.cityMesh.setMatrixAt(
          r,
          new ut().setPosition(this.environment.points[r])
        ),
        this.lights.add(i);
    }
    this.lights.add(this.cityMesh),
      ((r, i = 16777215) => {
        let a = new os(Ct.lightColor, 100);
        a.add(new Re(e, new Or({ color: i, transparent: !0, opacity: 0.6 }))),
          a.position.copy(r),
          this.lights.add(a);
      })(this.environment.start, 16173391);
  }
  reset() {
    this.environment.init(), this.setup(), this.generate();
  }
  stop() {
    this.stopFlag = !0;
  }
  async generate(e = 100) {
    this.stopFlag && (this.stopFlag = !1);
    let t = [],
      r = bE(Ct.pointsCount);
    for (let a = 0; a < Ct.populationMax; a++)
      t[a] = new To(xE(r), this.environment);
    const i = async (a) => {
      if (this.stopFlag) {
        console.log("Stopping...");
        return;
      }
      if ((t.sort((u, l) => u.isBetterThan(l)), a == 0)) return t[0];
      (t = t.slice(0, Ct.populationMax)), this.render(t[0].pointIndex);
      const s = Ct.crossFrequency * t.length;
      for (let u = 0; u < s; u++) {
        let l = Th(Ct.weights),
          f = Th(Ct.weights, l);
        t.push(t[l].breed(t[f])), t.push(t[f].breed(t[l]));
      }
      const o = Ct.mutationFrequency * t.length,
        c = t.length;
      for (let u = 0; u < o; u++) {
        let l = t[Math.floor(Math.random() * c)].mutate();
        t.push(l);
      }
      setTimeout(() => i(a - 1), Ct.frameDelay);
    };
    return await i(e), t[0];
  }
  render(e) {
    (this.anchor.children = []), this.anchor.add(this.lights);
    const t = [this.environment.start];
    for (let s = 0; s < e.length; s++) t.push(this.environment.points[e[s]]);
    t.push(this.environment.start);
    const r = new wt().setFromPoints(t),
      i = new Gw({ color: 16777215 }),
      a = new _n(r, i);
    this.anchor.add(a);
  }
}
function _E() {
  return [5313208, 16740351, 7222506, 16173391][Math.floor(Math.random() * 4)];
}
class gm {
  constructor(e = void 0) {
    (this.settings = {
      colors: [],
      gridSize: 10,
      vertices: new Float32Array(20 * 20 * 3),
      materialFacesColor: _E(),
      targetValue: 0.5,
      landscapeNb: 1,
      factor: 25,
    }),
      (this.anchor = new st()),
      (this.control = e);
  }
  geneticAlgorithmWithAdaptiveLandscape(e, t, r) {
    let i = this.generatePopulation(e);
    const a = Math.floor(t / this.settings.landscapeNb);
    for (let s = 0; s < t; s++) {
      this.evaluatePopulation(i);
      const o = this.selectParents(i),
        c = [];
      for (; c.length < e; ) {
        const [u, l] = this.crossover(o);
        this.mutate(u, r), this.mutate(l, r), c.push(u, l);
      }
      (i = c),
        s % a === 0 && (this.evaluatePopulation(i), this.displayFitnessMap(i));
    }
    this.evaluatePopulation(i);
  }
  displayFitnessMap(e) {
    const t = this.settings.gridSize,
      r = this.createPoints(e, this.settings.vertices),
      i = new wt(),
      a = [];
    for (let c = 0; c < t; c++) {
      for (let d = 0; d < t; d++) {
        const g = c * t + d,
          [x, m, p] = r.slice(g * 3, g * 3 + 3);
        if (d < t - 1) {
          const S = c * t + (d + 1),
            [v, y, E] = r.slice(S * 3, S * 3 + 3);
          a.push(x, m, p, v, y, E);
        }
        if (c < t - 1) {
          const S = (c + 1) * t + d,
            [v, y, E] = r.slice(S * 3, S * 3 + 3);
          a.push(x, m, p, v, y, E);
        }
      }
      const u = this.createFaces(r),
        l = new wt();
      l.setAttribute("position", new nt(u, 3)), l.computeVertexNormals();
      const f = new Or({ color: this.settings.materialFacesColor });
      f.side = jt;
      const h = new Re(l, f);
      (h.receiveShadow = !0), this.anchor.add(h);
    }
    i.setAttribute("position", new nt(a, 3)),
      i.setAttribute("color", new nt(this.settings.colors, 3));
    const s = new hi({ vertexColors: !0 });
    s.side = jt;
    const o = new Kp(i, s);
    this.anchor.add(o),
      (this.hitbox = new Un()),
      this.hitbox.handler(this.control, this.hitbox.mesh, this.anchor),
      this.anchor.add(this.hitbox.mesh);
  }
  createPoints(e, t) {
    const r = this.settings.gridSize,
      i = 1;
    for (let a = 0, s = -r / 2; a < r; a++, s += i)
      for (let o = 0, c = -r / 2; o < r; o++, c += i) {
        const u = a * r + o;
        if (u < e.length) {
          const l = e[u].fitness;
          let f;
          a == 0 || a == r - 1 || o == 0 || o == r - 1
            ? (f = 0)
            : (f = l * this.settings.factor),
            (t[u * 3] = s),
            (t[u * 3 + 1] += f),
            (t[u * 3 + 2] = c);
        }
      }
    return t;
  }
  createFaces(e) {
    const t = [],
      r = this.settings.gridSize;
    for (let i = 0; i < r - 1; i++)
      for (let a = 0; a < r - 1; a++) {
        const s = i * r + a,
          o = s + 1,
          c = (i + 1) * r + a,
          u = c + 1,
          [l, f, h] = e.slice(s * 3, s * 3 + 3),
          [d, g, x] = e.slice(o * 3, o * 3 + 3),
          [m, p, S] = e.slice(c * 3, c * 3 + 3),
          [v, y, E] = e.slice(u * 3, u * 3 + 3);
        t.push(l, f, h, d, g, x, m, p, S), t.push(m, p, S, d, g, x, v, y, E);
        const M = 0,
          T = 50,
          N = (f - M) / (T - M),
          A = wE("#660FE3", "#F6C94F", N);
        this.settings.colors.push(A),
          this.settings.colors.push(l / 30 + 0.5, f / 30 + 0.5, h / 30 + 0.5);
      }
    return t;
  }
  generatePopulation(e) {
    const t = [];
    for (let r = 0; r < e; r++) {
      const i = { chromosome: Math.random() * 10, fitness: 0 };
      t.push(i);
    }
    return t;
  }
  evaluatePopulation(e) {
    for (const t of e) t.fitness = this.fitnessFunction(t.chromosome);
  }
  selectParents(e) {
    const t = e.reduce((i, a) => i + a.fitness, 0),
      r = [];
    for (let i = 0; i < e.length; i++) {
      const a = Math.random() * t;
      let s = 0;
      for (const o of e)
        if (((s += o.fitness), s >= a)) {
          r.push(o);
          break;
        }
    }
    return r;
  }
  crossover(e) {
    const t = Math.random(),
      r = {
        chromosome: e[0].chromosome * t + e[1].chromosome * (1 - t),
        fitness: this.fitnessFunction(),
      },
      i = {
        chromosome: e[1].chromosome * t + e[0].chromosome * (1 - t),
        fitness: this.fitnessFunction(),
      };
    return [r, i];
  }
  mutate(e, t) {
    Math.random() < t && (e.chromosome = Math.random() * 10);
  }
  fitnessFunction(e) {
    return 1 / (1 + Math.abs(e - 0.5));
  }
}
function wE(n, e, t) {
  const r = parseInt(n.substring(1, 3), 16),
    i = parseInt(n.substring(3, 5), 16),
    a = parseInt(n.substring(5, 7), 16),
    s = parseInt(e.substring(1, 3), 16),
    o = parseInt(e.substring(3, 5), 16),
    c = parseInt(e.substring(5, 7), 16),
    u = Math.round(r + t * (s - r))
      .toString(16)
      .padStart(2, "0"),
    l = Math.round(i + t * (o - i))
      .toString(16)
      .padStart(2, "0"),
    f = Math.round(a + t * (c - a))
      .toString(16)
      .padStart(2, "0");
  return `#${u}${l}${f}`;
}
const EE = [
  new Float32Array([25, 0, 25, 0, 0, 25, 0, 25, 0]),
  new Float32Array([25, 0, 25, 25, 0, 0, 0, 25, 0]),
  new Float32Array([25, 0, 0, 0, 0, 0, 0, 25, 0]),
  new Float32Array([25, 0, 0, 25, 0, 25, 0, 25, 0]),
  new Float32Array([0, 0, 0, 25, 0, 0, 0, 25, 0]),
  new Float32Array([25, 0, 25, 0, 0, 25, 0, 0, 25]),
];
class SE {
  constructor(e) {
    (this.settings = { depth: Math.floor(2 + Math.random() * 2) }),
      (this.color = e),
      (this.anchor = new st());
  }
  generate3dSierpinski() {
    for (let e = 0; e < 6; e++)
      this.generateSierpinski(EE[e], this.settings.depth);
  }
  generateSierpinski(e, t) {
    if (t === 0) this.drawVertices(e);
    else {
      const r = [e[0], e[1], e[2]],
        i = [e[3], e[4], e[5]],
        a = [e[6], e[7], e[8]],
        s = Ku(r, i),
        o = Ku(i, a),
        c = Ku(r, a),
        u = new Float32Array([
          r[0],
          r[1],
          r[2],
          s[0],
          s[1],
          s[2],
          c[0],
          c[1],
          c[2],
        ]),
        l = new Float32Array([
          s[0],
          s[1],
          s[2],
          i[0],
          i[1],
          i[2],
          o[0],
          o[1],
          o[2],
        ]),
        f = new Float32Array([
          c[0],
          c[1],
          c[2],
          o[0],
          o[1],
          o[2],
          a[0],
          a[1],
          a[2],
        ]);
      this.generateSierpinski(u, t - 1),
        this.generateSierpinski(l, t - 1),
        this.generateSierpinski(f, t - 1);
    }
  }
  generate2dSierpinski() {
    const t = new Float32Array([500, 0, 500, -500, 0, -500, -500, 0, 500]),
      r = new Float32Array([-500, 0, -500, 500, 0, 500, 500, 0, -500]);
    this.generateSierpinski(t, this.settings.depth),
      this.generateSierpinski(r, this.settings.depth);
  }
  drawVertices(e) {
    const t = new wt(),
      r = 3;
    t.setAttribute("position", new gn(e, r)), t.computeVertexNormals();
    const i = new Or({ color: this.color });
    i.side = jt;
    const a = new Re(t, i);
    this.anchor.add(a);
  }
}
function Ku(n, e) {
  const t = n[0] + 0.5 * (e[0] - n[0]),
    r = n[1] + 0.5 * (e[1] - n[1]),
    i = n[2] + 0.5 * (e[2] - n[2]);
  return [t, r, i];
}
class vm {
  constructor(e = void 0) {
    (this.settings = { dt: 0.01, positions: [], colors: [] }),
      (this.control = e),
      (this.x = 0.1),
      (this.y = 0),
      (this.z = 0),
      (this.lineGeometry = new wt()),
      (this.anchor = new st()),
      (this.lineMaterial = new hi({ vertexColors: !0 })),
      (this.line = new _n(this.lineGeometry, this.lineMaterial));
  }
  instantDraw(e, t) {
    for (let l = 0; l < t; l++) {
      const { dx: f, dy: h, dz: d } = this.calculateAttractor(e);
      (this.x += f),
        (this.y += h),
        (this.z += d),
        this.settings.positions.push(this.x, this.y, this.z),
        this.settings.colors.push(
          this.x / 30 + 0.5,
          this.y / 30 + 0.5,
          this.z / 30 + 0.5
        );
    }
    this.lineGeometry.setAttribute(
      "position",
      new nt(this.settings.positions, 3)
    ),
      this.lineGeometry.setAttribute("color", new nt(this.settings.colors, 3));
    const r = new _n(this.lineGeometry, this.lineMaterial);
    this.anchor.add(r);
    const i = new im(),
      a = this.lineGeometry.attributes.position.array;
    for (let l = 0; l < a.length; l += 3) i.lineTo(a[l], a[l + 1]);
    const s = { depth: 20, bevelEnabled: !1 },
      o = new Zc(i, s),
      c = new Vn({ transparent: !0, opacity: 0 }),
      u = new Re(o, c);
    this.anchor.add(u),
      (this.hitbox = new Un()),
      this.hitbox.handler(this.control, this.hitbox.mesh, this.anchor),
      this.anchor.add(this.hitbox.mesh);
  }
  calculateAttractor(e) {
    let t, r, i;
    if (e == "lorenz") {
      const o = 2.6666666666666665;
      (t = 10 * (this.y - this.x) * this.settings.dt),
        (r = (this.x * (28 - this.z) - this.y) * this.settings.dt),
        (i = (this.x * this.y - o * this.z) * this.settings.dt);
    } else
      e == "rossler"
        ? ((t = (-this.y - this.z) * 0.015),
          (r = (this.x + 0.2 * this.y) * 0.015),
          (i = (0.2 + this.z * (this.x - 5.7)) * 0.015))
        : e == "aizawa"
        ? ((t = ((this.z - 0.7) * this.x - 3.5 * this.y) * this.settings.dt),
          (r = (3.5 * this.x + (this.z - 0.7) * this.y) * this.settings.dt),
          (i =
            (0.6 +
              0.95 * this.z -
              Math.pow(this.z, 3) / 3 -
              (Math.pow(this.x, 2) + Math.pow(this.y, 2)) *
                (1 + 0.25 * this.z) +
              0.1 * this.z * Math.pow(this.x, 3)) *
            this.settings.dt))
        : e == "arneodo"
        ? ((t = this.y * this.settings.dt),
          (r = this.z * this.settings.dt),
          (i =
            (5.5 * this.x - 3.5 * this.y - this.z + -1 * Math.pow(this.x, 3)) *
            this.settings.dt))
        : e == "sprottB"
        ? ((t = 0.4 * this.y * this.z * 0.015),
          (r = (this.x - 1.2 * this.y) * 0.015),
          (i = (1 - this.x * this.y) * 0.015))
        : e == "sprottLinzF"
        ? ((t = (this.y + this.z) * 0.015),
          (r = (-this.x + 0.5 * this.y) * 0.015),
          (i = (Math.pow(this.x, 2) - this.z) * 0.015))
        : e == "halvorsen" &&
          ((t =
            (-1.4 * this.x - 4 * this.y - 4 * this.z - this.y * this.y) *
            0.005),
          (r =
            (-1.4 * this.y - 4 * this.z - 4 * this.x - this.z * this.z) *
            0.005),
          (i =
            (-1.4 * this.z - 4 * this.x - 4 * this.y - this.x * this.x) *
            0.005));
    return { dx: t, dy: r, dz: i };
  }
}
var Ur =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function gs(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function ME(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(
        t,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[r];
              },
            }
      );
    }),
    t
  );
}
var ym = { exports: {} };
(function (n) {
  (function (e, t) {
    n.exports ? (n.exports = t()) : (e.nearley = t());
  })(Ur, function () {
    function e(u, l, f) {
      return (
        (this.id = ++e.highestId),
        (this.name = u),
        (this.symbols = l),
        (this.postprocess = f),
        this
      );
    }
    (e.highestId = 0),
      (e.prototype.toString = function (u) {
        var l =
          typeof u > "u"
            ? this.symbols.map(c).join(" ")
            : this.symbols.slice(0, u).map(c).join(" ") +
              " ● " +
              this.symbols.slice(u).map(c).join(" ");
        return this.name + " → " + l;
      });
    function t(u, l, f, h) {
      (this.rule = u),
        (this.dot = l),
        (this.reference = f),
        (this.data = []),
        (this.wantedBy = h),
        (this.isComplete = this.dot === u.symbols.length);
    }
    (t.prototype.toString = function () {
      return (
        "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0)
      );
    }),
      (t.prototype.nextState = function (u) {
        var l = new t(this.rule, this.dot + 1, this.reference, this.wantedBy);
        return (
          (l.left = this),
          (l.right = u),
          l.isComplete && ((l.data = l.build()), (l.right = void 0)),
          l
        );
      }),
      (t.prototype.build = function () {
        var u = [],
          l = this;
        do u.push(l.right.data), (l = l.left);
        while (l.left);
        return u.reverse(), u;
      }),
      (t.prototype.finish = function () {
        this.rule.postprocess &&
          (this.data = this.rule.postprocess(
            this.data,
            this.reference,
            s.fail
          ));
      });
    function r(u, l) {
      (this.grammar = u),
        (this.index = l),
        (this.states = []),
        (this.wants = {}),
        (this.scannable = []),
        (this.completed = {});
    }
    (r.prototype.process = function (u) {
      for (
        var l = this.states, f = this.wants, h = this.completed, d = 0;
        d < l.length;
        d++
      ) {
        var g = l[d];
        if (g.isComplete) {
          if ((g.finish(), g.data !== s.fail)) {
            for (var x = g.wantedBy, m = x.length; m--; ) {
              var p = x[m];
              this.complete(p, g);
            }
            if (g.reference === this.index) {
              var S = g.rule.name;
              (this.completed[S] = this.completed[S] || []).push(g);
            }
          }
        } else {
          var S = g.rule.symbols[g.dot];
          if (typeof S != "string") {
            this.scannable.push(g);
            continue;
          }
          if (f[S]) {
            if ((f[S].push(g), h.hasOwnProperty(S)))
              for (var v = h[S], m = 0; m < v.length; m++) {
                var y = v[m];
                this.complete(g, y);
              }
          } else (f[S] = [g]), this.predict(S);
        }
      }
    }),
      (r.prototype.predict = function (u) {
        for (var l = this.grammar.byName[u] || [], f = 0; f < l.length; f++) {
          var h = l[f],
            d = this.wants[u],
            g = new t(h, 0, this.index, d);
          this.states.push(g);
        }
      }),
      (r.prototype.complete = function (u, l) {
        var f = u.nextState(l);
        this.states.push(f);
      });
    function i(u, l) {
      (this.rules = u), (this.start = l || this.rules[0].name);
      var f = (this.byName = {});
      this.rules.forEach(function (h) {
        f.hasOwnProperty(h.name) || (f[h.name] = []), f[h.name].push(h);
      });
    }
    i.fromCompiled = function (h, l) {
      var f = h.Lexer;
      h.ParserStart && ((l = h.ParserStart), (h = h.ParserRules));
      var h = h.map(function (g) {
          return new e(g.name, g.symbols, g.postprocess);
        }),
        d = new i(h, l);
      return (d.lexer = f), d;
    };
    function a() {
      this.reset("");
    }
    (a.prototype.reset = function (u, l) {
      (this.buffer = u),
        (this.index = 0),
        (this.line = l ? l.line : 1),
        (this.lastLineBreak = l ? -l.col : 0);
    }),
      (a.prototype.next = function () {
        if (this.index < this.buffer.length) {
          var u = this.buffer[this.index++];
          return (
            u ===
              `
` && ((this.line += 1), (this.lastLineBreak = this.index)),
            { value: u }
          );
        }
      }),
      (a.prototype.save = function () {
        return { line: this.line, col: this.index - this.lastLineBreak };
      }),
      (a.prototype.formatError = function (u, l) {
        var f = this.buffer;
        if (typeof f == "string") {
          var h = f
              .split(
                `
`
              )
              .slice(Math.max(0, this.line - 5), this.line),
            d = f.indexOf(
              `
`,
              this.index
            );
          d === -1 && (d = f.length);
          var g = this.index - this.lastLineBreak,
            x = String(this.line).length;
          return (
            (l +=
              " at line " +
              this.line +
              " col " +
              g +
              `:

`),
            (l += h.map(function (p, S) {
              return m(this.line - h.length + S + 1, x) + " " + p;
            }, this).join(`
`)),
            (l +=
              `
` +
              m("", x + g) +
              `^
`),
            l
          );
        } else return l + " at index " + (this.index - 1);
        function m(p, S) {
          var v = String(p);
          return Array(S - v.length + 1).join(" ") + v;
        }
      });
    function s(u, l, f) {
      if (u instanceof i)
        var h = u,
          f = l;
      else var h = i.fromCompiled(u, l);
      (this.grammar = h),
        (this.options = { keepHistory: !1, lexer: h.lexer || new a() });
      for (var d in f || {}) this.options[d] = f[d];
      (this.lexer = this.options.lexer), (this.lexerState = void 0);
      var g = new r(h, 0);
      (this.table = [g]),
        (g.wants[h.start] = []),
        g.predict(h.start),
        g.process(),
        (this.current = 0);
    }
    (s.fail = {}),
      (s.prototype.feed = function (u) {
        var l = this.lexer;
        l.reset(u, this.lexerState);
        for (var f; ; ) {
          try {
            if (((f = l.next()), !f)) break;
          } catch (T) {
            var x = new r(this.grammar, this.current + 1);
            this.table.push(x);
            var h = new Error(this.reportLexerError(T));
            throw ((h.offset = this.current), (h.token = T.token), h);
          }
          var d = this.table[this.current];
          this.options.keepHistory || delete this.table[this.current - 1];
          var g = this.current + 1,
            x = new r(this.grammar, g);
          this.table.push(x);
          for (
            var m = f.text !== void 0 ? f.text : f.value,
              p = l.constructor === a ? f.value : f,
              S = d.scannable,
              v = S.length;
            v--;

          ) {
            var y = S[v],
              E = y.rule.symbols[y.dot];
            if (
              E.test ? E.test(p) : E.type ? E.type === f.type : E.literal === m
            ) {
              var M = y.nextState({
                data: p,
                token: f,
                isToken: !0,
                reference: g - 1,
              });
              x.states.push(M);
            }
          }
          if ((x.process(), x.states.length === 0)) {
            var h = new Error(this.reportError(f));
            throw ((h.offset = this.current), (h.token = f), h);
          }
          this.options.keepHistory && (d.lexerState = l.save()), this.current++;
        }
        return (
          d && (this.lexerState = l.save()),
          (this.results = this.finish()),
          this
        );
      }),
      (s.prototype.reportLexerError = function (u) {
        var l,
          f,
          h = u.token;
        return (
          h
            ? ((l = "input " + JSON.stringify(h.text[0]) + " (lexer error)"),
              (f = this.lexer.formatError(h, "Syntax error")))
            : ((l = "input (lexer error)"), (f = u.message)),
          this.reportErrorCommon(f, l)
        );
      }),
      (s.prototype.reportError = function (u) {
        var l =
            (u.type ? u.type + " token: " : "") +
            JSON.stringify(u.value !== void 0 ? u.value : u),
          f = this.lexer.formatError(u, "Syntax error");
        return this.reportErrorCommon(f, l);
      }),
      (s.prototype.reportErrorCommon = function (u, l) {
        var f = [];
        f.push(u);
        var h = this.table.length - 2,
          d = this.table[h],
          g = d.states.filter(function (m) {
            var p = m.rule.symbols[m.dot];
            return p && typeof p != "string";
          });
        if (g.length === 0)
          f.push(
            "Unexpected " +
              l +
              `. I did not expect any more input. Here is the state of my parse table:
`
          ),
            this.displayStateStack(d.states, f);
        else {
          f.push(
            "Unexpected " +
              l +
              `. Instead, I was expecting to see one of the following:
`
          );
          var x = g.map(function (m) {
            return this.buildFirstStateStack(m, []) || [m];
          }, this);
          x.forEach(function (m) {
            var p = m[0],
              S = p.rule.symbols[p.dot],
              v = this.getSymbolDisplay(S);
            f.push("A " + v + " based on:"), this.displayStateStack(m, f);
          }, this);
        }
        return (
          f.push(""),
          f.join(`
`)
        );
      }),
      (s.prototype.displayStateStack = function (u, l) {
        for (var f, h = 0, d = 0; d < u.length; d++) {
          var g = u[d],
            x = g.rule.toString(g.dot);
          x === f
            ? h++
            : (h > 0 && l.push("    ^ " + h + " more lines identical to this"),
              (h = 0),
              l.push("    " + x)),
            (f = x);
        }
      }),
      (s.prototype.getSymbolDisplay = function (u) {
        return o(u);
      }),
      (s.prototype.buildFirstStateStack = function (u, l) {
        if (l.indexOf(u) !== -1) return null;
        if (u.wantedBy.length === 0) return [u];
        var f = u.wantedBy[0],
          h = [u].concat(l),
          d = this.buildFirstStateStack(f, h);
        return d === null ? null : [u].concat(d);
      }),
      (s.prototype.save = function () {
        var u = this.table[this.current];
        return (u.lexerState = this.lexerState), u;
      }),
      (s.prototype.restore = function (u) {
        var l = u.index;
        (this.current = l),
          (this.table[l] = u),
          this.table.splice(l + 1),
          (this.lexerState = u.lexerState),
          (this.results = this.finish());
      }),
      (s.prototype.rewind = function (u) {
        if (!this.options.keepHistory)
          throw new Error("set option `keepHistory` to enable rewinding");
        this.restore(this.table[u]);
      }),
      (s.prototype.finish = function () {
        var u = [],
          l = this.grammar.start,
          f = this.table[this.table.length - 1];
        return (
          f.states.forEach(function (h) {
            h.rule.name === l &&
              h.dot === h.rule.symbols.length &&
              h.reference === 0 &&
              h.data !== s.fail &&
              u.push(h);
          }),
          u.map(function (h) {
            return h.data;
          })
        );
      });
    function o(u) {
      var l = typeof u;
      if (l === "string") return u;
      if (l === "object") {
        if (u.literal) return JSON.stringify(u.literal);
        if (u instanceof RegExp) return "character matching " + u;
        if (u.type) return u.type + " token";
        if (u.test) return "token matching " + String(u.test);
        throw new Error("Unknown symbol type: " + u);
      }
    }
    function c(u) {
      var l = typeof u;
      if (l === "string") return u;
      if (l === "object") {
        if (u.literal) return JSON.stringify(u.literal);
        if (u instanceof RegExp) return u.toString();
        if (u.type) return "%" + u.type;
        if (u.test) return "<" + String(u.test) + ">";
        throw new Error("Unknown symbol type: " + u);
      }
    }
    return { Parser: s, Grammar: i, Rule: e };
  });
})(ym);
var AE = ym.exports;
const Ch = gs(AE);
function ir() {
  return (
    (ir = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    ir.apply(null, arguments)
  );
}
var xm = {
  epsilon: 1e-12,
  matrix: "Matrix",
  number: "number",
  precision: 64,
  predictable: !1,
  randomSeed: null,
};
function Dt(n) {
  return typeof n == "number";
}
function Bt(n) {
  return !n || typeof n != "object" || typeof n.constructor != "function"
    ? !1
    : (n.isBigNumber === !0 &&
        typeof n.constructor.prototype == "object" &&
        n.constructor.prototype.isBigNumber === !0) ||
        (typeof n.constructor.isDecimal == "function" &&
          n.constructor.isDecimal(n) === !0);
}
function ya(n) {
  return (
    (n && typeof n == "object" && Object.getPrototypeOf(n).isComplex === !0) ||
    !1
  );
}
function vs(n) {
  return (
    (n && typeof n == "object" && Object.getPrototypeOf(n).isFraction === !0) ||
    !1
  );
}
function jo(n) {
  return (n && n.constructor.prototype.isUnit === !0) || !1;
}
function Fr(n) {
  return typeof n == "string";
}
var el = Array.isArray;
function tn(n) {
  return (n && n.constructor.prototype.isMatrix === !0) || !1;
}
function si(n) {
  return Array.isArray(n) || tn(n);
}
function Co(n) {
  return (
    (n && n.isDenseMatrix && n.constructor.prototype.isMatrix === !0) || !1
  );
}
function Yi(n) {
  return (
    (n && n.isSparseMatrix && n.constructor.prototype.isMatrix === !0) || !1
  );
}
function bm(n) {
  return (n && n.constructor.prototype.isRange === !0) || !1;
}
function _m(n) {
  return (n && n.constructor.prototype.isIndex === !0) || !1;
}
function wm(n) {
  return typeof n == "boolean";
}
function Em(n) {
  return (n && n.constructor.prototype.isResultSet === !0) || !1;
}
function tl(n) {
  return (n && n.constructor.prototype.isHelp === !0) || !1;
}
function Sm(n) {
  return typeof n == "function";
}
function Mm(n) {
  return n instanceof Date;
}
function Am(n) {
  return n instanceof RegExp;
}
function ys(n) {
  return !!(
    n &&
    typeof n == "object" &&
    n.constructor === Object &&
    !ya(n) &&
    !vs(n)
  );
}
function Dm(n) {
  return n === null;
}
function Tm(n) {
  return n === void 0;
}
function Pr(n) {
  return (
    (n && n.isAccessorNode === !0 && n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function pn(n) {
  return (
    (n && n.isArrayNode === !0 && n.constructor.prototype.isNode === !0) || !1
  );
}
function Cm(n) {
  return (
    (n && n.isAssignmentNode === !0 && n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Nm(n) {
  return (
    (n && n.isBlockNode === !0 && n.constructor.prototype.isNode === !0) || !1
  );
}
function Rm(n) {
  return (
    (n &&
      n.isConditionalNode === !0 &&
      n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Qe(n) {
  return (
    (n && n.isConstantNode === !0 && n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function bc(n) {
  return (
    Qe(n) ||
    (Et(n) && n.args.length === 1 && Qe(n.args[0]) && "-+~".includes(n.op))
  );
}
function xa(n) {
  return (
    (n &&
      n.isFunctionAssignmentNode === !0 &&
      n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function fr(n) {
  return (
    (n && n.isFunctionNode === !0 && n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function pi(n) {
  return (
    (n && n.isIndexNode === !0 && n.constructor.prototype.isNode === !0) || !1
  );
}
function at(n) {
  return (n && n.isNode === !0 && n.constructor.prototype.isNode === !0) || !1;
}
function xs(n) {
  return (
    (n && n.isObjectNode === !0 && n.constructor.prototype.isNode === !0) || !1
  );
}
function Et(n) {
  return (
    (n && n.isOperatorNode === !0 && n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Wn(n) {
  return (
    (n &&
      n.isParenthesisNode === !0 &&
      n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Fm(n) {
  return (
    (n && n.isRangeNode === !0 && n.constructor.prototype.isNode === !0) || !1
  );
}
function Pm(n) {
  return (
    (n && n.isRelationalNode === !0 && n.constructor.prototype.isNode === !0) ||
    !1
  );
}
function Rt(n) {
  return (
    (n && n.isSymbolNode === !0 && n.constructor.prototype.isNode === !0) || !1
  );
}
function nl(n) {
  return (n && n.constructor.prototype.isChain === !0) || !1;
}
function Vt(n) {
  var e = typeof n;
  return e === "object"
    ? n === null
      ? "null"
      : Bt(n)
      ? "BigNumber"
      : n.constructor && n.constructor.name
      ? n.constructor.name
      : "Object"
    : e;
}
function Mr(n) {
  var e = typeof n;
  if (
    e === "number" ||
    e === "string" ||
    e === "boolean" ||
    n === null ||
    n === void 0
  )
    return n;
  if (typeof n.clone == "function") return n.clone();
  if (Array.isArray(n))
    return n.map(function (t) {
      return Mr(t);
    });
  if (n instanceof Date) return new Date(n.valueOf());
  if (Bt(n)) return n;
  if (ys(n)) return Va(n, Mr);
  throw new TypeError(
    "Cannot clone: unknown type of value (value: ".concat(n, ")")
  );
}
function Va(n, e) {
  var t = {};
  for (var r in n) Ve(n, r) && (t[r] = e(n[r]));
  return t;
}
function Lm(n, e) {
  if (Array.isArray(e))
    throw new TypeError("Arrays are not supported by deepExtend");
  for (var t in e)
    if (Ve(e, t) && !(t in Object.prototype) && !(t in Function.prototype))
      if (e[t] && e[t].constructor === Object)
        n[t] === void 0 && (n[t] = {}),
          n[t] && n[t].constructor === Object ? Lm(n[t], e[t]) : (n[t] = e[t]);
      else {
        if (Array.isArray(e[t]))
          throw new TypeError("Arrays are not supported by deepExtend");
        n[t] = e[t];
      }
  return n;
}
function _c(n, e) {
  var t, r, i;
  if (Array.isArray(n)) {
    if (!Array.isArray(e) || n.length !== e.length) return !1;
    for (r = 0, i = n.length; r < i; r++) if (!_c(n[r], e[r])) return !1;
    return !0;
  } else {
    if (typeof n == "function") return n === e;
    if (n instanceof Object) {
      if (Array.isArray(e) || !(e instanceof Object)) return !1;
      for (t in n) if (!(t in e) || !_c(n[t], e[t])) return !1;
      for (t in e) if (!(t in n)) return !1;
      return !0;
    } else return n === e;
  }
}
function DE(n) {
  var e = {};
  return Im(n, e), e;
}
function Im(n, e) {
  for (var t in n)
    if (Ve(n, t)) {
      var r = n[t];
      typeof r == "object" && r !== null ? Im(r, e) : (e[t] = r);
    }
}
function wo(n, e, t) {
  var r = !0,
    i;
  Object.defineProperty(n, e, {
    get: function () {
      return r && ((i = t()), (r = !1)), i;
    },
    set: function (s) {
      (i = s), (r = !1);
    },
    configurable: !0,
    enumerable: !0,
  });
}
function Ve(n, e) {
  return n && Object.hasOwnProperty.call(n, e);
}
function TE(n) {
  return n && typeof n.factory == "function";
}
function CE(n, e) {
  for (var t = {}, r = 0; r < e.length; r++) {
    var i = e[r],
      a = n[i];
    a !== void 0 && (t[i] = a);
  }
  return t;
}
var Nh = ["Matrix", "Array"],
  Rh = ["number", "BigNumber", "Fraction"];
function NE(n, e) {
  function t(r) {
    if (r) {
      var i = Va(n, Mr);
      Fh(r, "matrix", Nh), Fh(r, "number", Rh), Lm(n, r);
      var a = Va(n, Mr),
        s = Va(r, Mr);
      return e("config", a, i, s), a;
    } else return Va(n, Mr);
  }
  return (
    (t.MATRIX_OPTIONS = Nh),
    (t.NUMBER_OPTIONS = Rh),
    Object.keys(xm).forEach((r) => {
      Object.defineProperty(t, r, {
        get: () => n[r],
        enumerable: !0,
        configurable: !0,
      });
    }),
    t
  );
}
function Fh(n, e, t) {
  n[e] !== void 0 &&
    !t.includes(n[e]) &&
    console.warn(
      'Warning: Unknown value "' +
        n[e] +
        '" for configuration option "' +
        e +
        '". Available options: ' +
        t.map((r) => JSON.stringify(r)).join(", ") +
        "."
    );
}
function rt(n) {
  return typeof n == "boolean" ? !0 : isFinite(n) ? n === Math.round(n) : !1;
}
var Ar =
    Math.sign ||
    function (n) {
      return n > 0 ? 1 : n < 0 ? -1 : 0;
    },
  RE =
    Math.log2 ||
    function (e) {
      return Math.log(e) / Math.LN2;
    },
  FE =
    Math.log10 ||
    function (e) {
      return Math.log(e) / Math.LN10;
    },
  PE =
    Math.log1p ||
    function (n) {
      return Math.log(n + 1);
    },
  LE =
    Math.cbrt ||
    function (e) {
      if (e === 0) return e;
      var t = e < 0,
        r;
      return (
        t && (e = -e),
        isFinite(e)
          ? ((r = Math.exp(Math.log(e) / 3)), (r = (e / (r * r) + 2 * r) / 3))
          : (r = e),
        t ? -r : r
      );
    },
  IE =
    Math.expm1 ||
    function (e) {
      return e >= 2e-4 || e <= -2e-4
        ? Math.exp(e) - 1
        : e + (e * e) / 2 + (e * e * e) / 6;
    };
function Qu(n, e, t) {
  var r = { 2: "0b", 8: "0o", 16: "0x" },
    i = r[e],
    a = "";
  if (t) {
    if (t < 1) throw new Error("size must be in greater than 0");
    if (!rt(t)) throw new Error("size must be an integer");
    if (n > 2 ** (t - 1) - 1 || n < -(2 ** (t - 1)))
      throw new Error(
        "Value must be in range [-2^".concat(t - 1, ", 2^").concat(t - 1, "-1]")
      );
    if (!rt(n)) throw new Error("Value must be an integer");
    n < 0 && (n = n + 2 ** t), (a = "i".concat(t));
  }
  var s = "";
  return (
    n < 0 && ((n = -n), (s = "-")),
    "".concat(s).concat(i).concat(n.toString(e)).concat(a)
  );
}
function Ja(n, e) {
  if (typeof e == "function") return e(n);
  if (n === 1 / 0) return "Infinity";
  if (n === -1 / 0) return "-Infinity";
  if (isNaN(n)) return "NaN";
  var { notation: t, precision: r, wordSize: i } = Om(e);
  switch (t) {
    case "fixed":
      return Um(n, r);
    case "exponential":
      return Bm(n, r);
    case "engineering":
      return OE(n, r);
    case "bin":
      return Qu(n, 2, i);
    case "oct":
      return Qu(n, 8, i);
    case "hex":
      return Qu(n, 16, i);
    case "auto":
      return UE(n, r, e).replace(/((\.\d*?)(0+))($|e)/, function () {
        var a = arguments[2],
          s = arguments[4];
        return a !== "." ? a + s : s;
      });
    default:
      throw new Error(
        'Unknown notation "' +
          t +
          '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.'
      );
  }
}
function Om(n) {
  var e = "auto",
    t,
    r;
  if (n !== void 0)
    if (Dt(n)) t = n;
    else if (Bt(n)) t = n.toNumber();
    else if (ys(n))
      n.precision !== void 0 &&
        (t = Ph(n.precision, () => {
          throw new Error('Option "precision" must be a number or BigNumber');
        })),
        n.wordSize !== void 0 &&
          (r = Ph(n.wordSize, () => {
            throw new Error('Option "wordSize" must be a number or BigNumber');
          })),
        n.notation && (e = n.notation);
    else
      throw new Error(
        "Unsupported type of options, number, BigNumber, or object expected"
      );
  return { notation: e, precision: t, wordSize: r };
}
function Xo(n) {
  var e = String(n)
    .toLowerCase()
    .match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!e) throw new SyntaxError("Invalid number " + n);
  var t = e[1],
    r = e[2],
    i = parseFloat(e[4] || "0"),
    a = r.indexOf(".");
  i += a !== -1 ? a - 1 : r.length - 1;
  var s = r
    .replace(".", "")
    .replace(/^0*/, function (o) {
      return (i -= o.length), "";
    })
    .replace(/0*$/, "")
    .split("")
    .map(function (o) {
      return parseInt(o);
    });
  return (
    s.length === 0 && (s.push(0), i++),
    { sign: t, coefficients: s, exponent: i }
  );
}
function OE(n, e) {
  if (isNaN(n) || !isFinite(n)) return String(n);
  var t = Xo(n),
    r = Yo(t, e),
    i = r.exponent,
    a = r.coefficients,
    s = i % 3 === 0 ? i : i < 0 ? i - 3 - (i % 3) : i - (i % 3);
  if (Dt(e)) for (; e > a.length || i - s + 1 > a.length; ) a.push(0);
  else
    for (var o = Math.abs(i - s) - (a.length - 1), c = 0; c < o; c++) a.push(0);
  for (var u = Math.abs(i - s), l = 1; u > 0; ) l++, u--;
  var f = a.slice(l).join(""),
    h = (Dt(e) && f.length) || f.match(/[1-9]/) ? "." + f : "",
    d = a.slice(0, l).join("") + h + "e" + (i >= 0 ? "+" : "") + s.toString();
  return r.sign + d;
}
function Um(n, e) {
  if (isNaN(n) || !isFinite(n)) return String(n);
  var t = Xo(n),
    r = typeof e == "number" ? Yo(t, t.exponent + 1 + e) : t,
    i = r.coefficients,
    a = r.exponent + 1,
    s = a + (e || 0);
  return (
    i.length < s && (i = i.concat(na(s - i.length))),
    a < 0 && ((i = na(-a + 1).concat(i)), (a = 1)),
    a < i.length && i.splice(a, 0, a === 0 ? "0." : "."),
    r.sign + i.join("")
  );
}
function Bm(n, e) {
  if (isNaN(n) || !isFinite(n)) return String(n);
  var t = Xo(n),
    r = e ? Yo(t, e) : t,
    i = r.coefficients,
    a = r.exponent;
  i.length < e && (i = i.concat(na(e - i.length)));
  var s = i.shift();
  return (
    r.sign +
    s +
    (i.length > 0 ? "." + i.join("") : "") +
    "e" +
    (a >= 0 ? "+" : "") +
    a
  );
}
function UE(n, e, t) {
  if (isNaN(n) || !isFinite(n)) return String(n);
  var r = Lh(t == null ? void 0 : t.lowerExp, -3),
    i = Lh(t == null ? void 0 : t.upperExp, 5),
    a = Xo(n),
    s = e ? Yo(a, e) : a;
  if (s.exponent < r || s.exponent >= i) return Bm(n, e);
  var o = s.coefficients,
    c = s.exponent;
  o.length < e && (o = o.concat(na(e - o.length))),
    (o = o.concat(na(c - o.length + 1 + (o.length < e ? e - o.length : 0)))),
    (o = na(-c).concat(o));
  var u = c > 0 ? c : 0;
  return u < o.length - 1 && o.splice(u + 1, 0, "."), s.sign + o.join("");
}
function Yo(n, e) {
  for (
    var t = {
        sign: n.sign,
        coefficients: n.coefficients,
        exponent: n.exponent,
      },
      r = t.coefficients;
    e <= 0;

  )
    r.unshift(0), t.exponent++, e++;
  if (r.length > e) {
    var i = r.splice(e, r.length - e);
    if (i[0] >= 5) {
      var a = e - 1;
      for (r[a]++; r[a] === 10; )
        r.pop(), a === 0 && (r.unshift(0), t.exponent++, a++), a--, r[a]++;
    }
  }
  return t;
}
function na(n) {
  for (var e = [], t = 0; t < n; t++) e.push(0);
  return e;
}
function BE(n) {
  return n
    .toExponential()
    .replace(/e.*$/, "")
    .replace(/^0\.?0*|\./, "").length;
}
var zE = Number.EPSILON || 2220446049250313e-31;
function qn(n, e, t) {
  if (t == null) return n === e;
  if (n === e) return !0;
  if (isNaN(n) || isNaN(e)) return !1;
  if (isFinite(n) && isFinite(e)) {
    var r = Math.abs(n - e);
    return r <= zE ? !0 : r <= Math.max(Math.abs(n), Math.abs(e)) * t;
  }
  return !1;
}
var kE =
    Math.acosh ||
    function (n) {
      return Math.log(Math.sqrt(n * n - 1) + n);
    },
  HE =
    Math.asinh ||
    function (n) {
      return Math.log(Math.sqrt(n * n + 1) + n);
    },
  GE =
    Math.atanh ||
    function (n) {
      return Math.log((1 + n) / (1 - n)) / 2;
    },
  VE =
    Math.cosh ||
    function (n) {
      return (Math.exp(n) + Math.exp(-n)) / 2;
    },
  WE =
    Math.sinh ||
    function (n) {
      return (Math.exp(n) - Math.exp(-n)) / 2;
    },
  qE =
    Math.tanh ||
    function (n) {
      var e = Math.exp(2 * n);
      return (e - 1) / (e + 1);
    };
function Ph(n, e) {
  if (Dt(n)) return n;
  if (Bt(n)) return n.toNumber();
  e();
}
function Lh(n, e) {
  return Dt(n) ? n : Bt(n) ? n.toNumber() : e;
}
var cn = "number",
  pr = "number, number";
function zm(n) {
  return Math.abs(n);
}
zm.signature = cn;
function rl(n, e) {
  return n + e;
}
rl.signature = pr;
function il(n, e) {
  return n - e;
}
il.signature = pr;
function al(n, e) {
  return n * e;
}
al.signature = pr;
function sl(n, e) {
  return n / e;
}
sl.signature = pr;
function km(n) {
  return -n;
}
km.signature = cn;
function Hm(n) {
  return n;
}
Hm.signature = cn;
function Gm(n) {
  return LE(n);
}
Gm.signature = cn;
function Vm(n) {
  return n * n * n;
}
Vm.signature = cn;
function Wm(n) {
  return Math.exp(n);
}
Wm.signature = cn;
function qm(n) {
  return IE(n);
}
qm.signature = cn;
function $m(n, e) {
  if (!rt(n) || !rt(e))
    throw new Error("Parameters in function gcd must be integer numbers");
  for (var t; e !== 0; ) (t = n % e), (n = e), (e = t);
  return n < 0 ? -n : n;
}
$m.signature = pr;
function jm(n, e) {
  if (!rt(n) || !rt(e))
    throw new Error("Parameters in function lcm must be integer numbers");
  if (n === 0 || e === 0) return 0;
  for (var t, r = n * e; e !== 0; ) (t = e), (e = n % t), (n = t);
  return Math.abs(r / n);
}
jm.signature = pr;
function $E(n, e) {
  return e ? Math.log(n) / Math.log(e) : Math.log(n);
}
function Xm(n) {
  return FE(n);
}
Xm.signature = cn;
function Ym(n) {
  return RE(n);
}
Ym.signature = cn;
function Zm(n) {
  return PE(n);
}
Zm.signature = cn;
function Jm(n, e) {
  return e === 0 ? n : n - e * Math.floor(n / e);
}
Jm.signature = pr;
function jE(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2,
    t = e < 0;
  if ((t && (e = -e), e === 0)) throw new Error("Root must be non-zero");
  if (n < 0 && Math.abs(e) % 2 !== 1)
    throw new Error("Root must be odd when a is negative.");
  if (n === 0) return t ? 1 / 0 : 0;
  if (!isFinite(n)) return t ? 0 : n;
  var r = Math.pow(Math.abs(n), 1 / e);
  return (r = n < 0 ? -r : r), t ? 1 / r : r;
}
function Km(n) {
  return Ar(n);
}
Km.signature = cn;
function Qm(n) {
  return Math.sqrt(n);
}
Qm.signature = cn;
function eg(n) {
  return n * n;
}
eg.signature = cn;
function tg(n, e) {
  var t,
    r,
    i,
    a = 0,
    s = 1,
    o = 1,
    c = 0;
  if (!rt(n) || !rt(e))
    throw new Error("Parameters in function xgcd must be integer numbers");
  for (; e; )
    (r = Math.floor(n / e)),
      (i = n - r * e),
      (t = a),
      (a = s - r * a),
      (s = t),
      (t = o),
      (o = c - r * o),
      (c = t),
      (n = e),
      (e = i);
  var u;
  return n < 0 ? (u = [-n, -s, -c]) : (u = [n, n ? s : 0, c]), u;
}
tg.signature = pr;
function ng(n, e) {
  return (n * n < 1 && e === 1 / 0) || (n * n > 1 && e === -1 / 0)
    ? 0
    : Math.pow(n, e);
}
ng.signature = pr;
function XE(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!rt(e) || e < 0 || e > 15)
    throw new Error(
      "Number of decimals in function round must be an integer from 0 to 15 inclusive"
    );
  return parseFloat(Um(n, e));
}
function rg(n) {
  return Math.abs(n);
}
rg.signature = cn;
var YE = "number",
  ba = "number, number";
function ig(n, e) {
  if (!rt(n) || !rt(e)) throw new Error("Integers expected in function bitAnd");
  return n & e;
}
ig.signature = ba;
function ag(n) {
  if (!rt(n)) throw new Error("Integer expected in function bitNot");
  return ~n;
}
ag.signature = YE;
function sg(n, e) {
  if (!rt(n) || !rt(e)) throw new Error("Integers expected in function bitOr");
  return n | e;
}
sg.signature = ba;
function og(n, e) {
  if (!rt(n) || !rt(e)) throw new Error("Integers expected in function bitXor");
  return n ^ e;
}
og.signature = ba;
function ug(n, e) {
  if (!rt(n) || !rt(e))
    throw new Error("Integers expected in function leftShift");
  return n << e;
}
ug.signature = ba;
function cg(n, e) {
  if (!rt(n) || !rt(e))
    throw new Error("Integers expected in function rightArithShift");
  return n >> e;
}
cg.signature = ba;
function lg(n, e) {
  if (!rt(n) || !rt(e))
    throw new Error("Integers expected in function rightLogShift");
  return n >>> e;
}
lg.signature = ba;
function or(n, e) {
  if (e < n) return 1;
  if (e === n) return e;
  var t = (e + n) >> 1;
  return or(n, t) * or(t + 1, e);
}
function fg(n, e) {
  if (!rt(n) || n < 0)
    throw new TypeError(
      "Positive integer value expected in function combinations"
    );
  if (!rt(e) || e < 0)
    throw new TypeError(
      "Positive integer value expected in function combinations"
    );
  if (e > n) throw new TypeError("k must be less than or equal to n");
  for (
    var t = n - e,
      r = 1,
      i = e < t ? t + 1 : e + 1,
      a = 2,
      s = e < t ? e : t,
      o = i;
    o <= n;
    ++o
  )
    for (r *= o; a <= s && r % a === 0; ) (r /= a), ++a;
  return a <= s && (r /= or(a, s)), r;
}
fg.signature = "number, number";
var ZE = Math.PI,
  JE = 2 * Math.PI,
  KE = Math.E,
  QE = 1.618033988749895,
  eS = "number",
  ol = "number, number";
function hg(n) {
  return !n;
}
hg.signature = eS;
function dg(n, e) {
  return !!(n || e);
}
dg.signature = ol;
function pg(n, e) {
  return !!n != !!e;
}
pg.signature = ol;
function mg(n, e) {
  return !!(n && e);
}
mg.signature = ol;
function ul(n) {
  var e;
  if (rt(n))
    return n <= 0
      ? isFinite(n)
        ? 1 / 0
        : NaN
      : n > 171
      ? 1 / 0
      : or(1, n - 1);
  if (n < 0.5) return Math.PI / (Math.sin(Math.PI * n) * ul(1 - n));
  if (n >= 171.35) return 1 / 0;
  if (n > 85) {
    var t = n * n,
      r = t * n,
      i = r * n,
      a = i * n;
    return (
      Math.sqrt((2 * Math.PI) / n) *
      Math.pow(n / Math.E, n) *
      (1 +
        1 / (12 * n) +
        1 / (288 * t) -
        139 / (51840 * r) -
        571 / (2488320 * i) +
        163879 / (209018880 * a) +
        5246819 / (75246796800 * a * n))
    );
  }
  --n, (e = ec[0]);
  for (var s = 1; s < ec.length; ++s) e += ec[s] / (n + s);
  var o = n + tS + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(o, n + 0.5) * Math.exp(-o) * e;
}
ul.signature = "number";
var tS = 4.7421875,
  ec = [
    0.9999999999999971, 57.15623566586292, -59.59796035547549,
    14.136097974741746, -0.4919138160976202, 3399464998481189e-20,
    4652362892704858e-20, -9837447530487956e-20, 0.0001580887032249125,
    -0.00021026444172410488, 0.00021743961811521265, -0.0001643181065367639,
    8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22,
  ],
  nS = 0.9189385332046728,
  rS = 5,
  iS = 7,
  Ih = [
    1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091,
    -1.231739572450155, 0.001208650973866179, -5395239384953e-18,
  ];
function cl(n) {
  if (n < 0) return NaN;
  if (n === 0) return 1 / 0;
  if (!isFinite(n)) return n;
  if (n < 0.5) return Math.log(Math.PI / Math.sin(Math.PI * n)) - cl(1 - n);
  n = n - 1;
  for (var e = n + rS + 0.5, t = Ih[0], r = iS - 1; r >= 1; r--)
    t += Ih[r] / (n + r);
  return nS + (n + 0.5) * Math.log(e) - e + Math.log(t);
}
cl.signature = "number";
var bt = "number",
  aS = "number, number";
function gg(n) {
  return Math.acos(n);
}
gg.signature = bt;
function vg(n) {
  return kE(n);
}
vg.signature = bt;
function yg(n) {
  return Math.atan(1 / n);
}
yg.signature = bt;
function xg(n) {
  return isFinite(n) ? (Math.log((n + 1) / n) + Math.log(n / (n - 1))) / 2 : 0;
}
xg.signature = bt;
function bg(n) {
  return Math.asin(1 / n);
}
bg.signature = bt;
function _g(n) {
  var e = 1 / n;
  return Math.log(e + Math.sqrt(e * e + 1));
}
_g.signature = bt;
function wg(n) {
  return Math.acos(1 / n);
}
wg.signature = bt;
function Eg(n) {
  var e = 1 / n,
    t = Math.sqrt(e * e - 1);
  return Math.log(t + e);
}
Eg.signature = bt;
function Sg(n) {
  return Math.asin(n);
}
Sg.signature = bt;
function Mg(n) {
  return HE(n);
}
Mg.signature = bt;
function Ag(n) {
  return Math.atan(n);
}
Ag.signature = bt;
function Dg(n, e) {
  return Math.atan2(n, e);
}
Dg.signature = aS;
function Tg(n) {
  return GE(n);
}
Tg.signature = bt;
function Cg(n) {
  return Math.cos(n);
}
Cg.signature = bt;
function Ng(n) {
  return VE(n);
}
Ng.signature = bt;
function Rg(n) {
  return 1 / Math.tan(n);
}
Rg.signature = bt;
function Fg(n) {
  var e = Math.exp(2 * n);
  return (e + 1) / (e - 1);
}
Fg.signature = bt;
function Pg(n) {
  return 1 / Math.sin(n);
}
Pg.signature = bt;
function Lg(n) {
  return n === 0
    ? Number.POSITIVE_INFINITY
    : Math.abs(2 / (Math.exp(n) - Math.exp(-n))) * Ar(n);
}
Lg.signature = bt;
function Ig(n) {
  return 1 / Math.cos(n);
}
Ig.signature = bt;
function Og(n) {
  return 2 / (Math.exp(n) + Math.exp(-n));
}
Og.signature = bt;
function Ug(n) {
  return Math.sin(n);
}
Ug.signature = bt;
function Bg(n) {
  return WE(n);
}
Bg.signature = bt;
function zg(n) {
  return Math.tan(n);
}
zg.signature = bt;
function kg(n) {
  return qE(n);
}
kg.signature = bt;
var bs = "number";
function Hg(n) {
  return rt(n);
}
Hg.signature = bs;
function Gg(n) {
  return n < 0;
}
Gg.signature = bs;
function Vg(n) {
  return n > 0;
}
Vg.signature = bs;
function Wg(n) {
  return n === 0;
}
Wg.signature = bs;
function qg(n) {
  return Number.isNaN(n);
}
qg.signature = bs;
function me(n, e, t, r) {
  function i(a) {
    var s = CE(a, e.map($g));
    return sS(n, e, a), t(s);
  }
  return (
    (i.isFactory = !0),
    (i.fn = n),
    (i.dependencies = e.slice().sort()),
    r && (i.meta = r),
    i
  );
}
function Ka(n) {
  return (
    typeof n == "function" &&
    typeof n.fn == "string" &&
    Array.isArray(n.dependencies)
  );
}
function sS(n, e, t) {
  var r = e.filter((a) => !oS(a)).every((a) => t[a] !== void 0);
  if (!r) {
    var i = e.filter((a) => t[a] === void 0);
    throw new Error(
      'Cannot create function "'.concat(n, '", ') +
        "some dependencies are missing: ".concat(
          i.map((a) => '"'.concat(a, '"')).join(", "),
          "."
        )
    );
  }
}
function oS(n) {
  return n && n[0] === "?";
}
function $g(n) {
  return n && n[0] === "?" ? n.slice(1) : n;
}
function ll() {
  throw new Error('No "bignumber" implementation available');
}
function jg() {
  throw new Error('No "fraction" implementation available');
}
function fl() {
  throw new Error('No "matrix" implementation available');
}
function uS() {
  throw new Error('No "index" implementation available');
}
function Xg() {
  throw new Error('No "matrix" implementation available');
}
function Oh() {
  return !0;
}
function xn() {
  return !1;
}
function zi() {}
const Uh = "Argument is not a typed-function.";
function Yg() {
  function n(w) {
    return typeof w == "object" && w !== null && w.constructor === Object;
  }
  const e = [
      {
        name: "number",
        test: function (w) {
          return typeof w == "number";
        },
      },
      {
        name: "string",
        test: function (w) {
          return typeof w == "string";
        },
      },
      {
        name: "boolean",
        test: function (w) {
          return typeof w == "boolean";
        },
      },
      {
        name: "Function",
        test: function (w) {
          return typeof w == "function";
        },
      },
      { name: "Array", test: Array.isArray },
      {
        name: "Date",
        test: function (w) {
          return w instanceof Date;
        },
      },
      {
        name: "RegExp",
        test: function (w) {
          return w instanceof RegExp;
        },
      },
      { name: "Object", test: n },
      {
        name: "null",
        test: function (w) {
          return w === null;
        },
      },
      {
        name: "undefined",
        test: function (w) {
          return w === void 0;
        },
      },
    ],
    t = { name: "any", test: Oh, isAny: !0 };
  let r,
    i,
    a = 0,
    s = { createCount: 0 };
  function o(w) {
    const b = r.get(w);
    if (b) return b;
    let F = 'Unknown type "' + w + '"';
    const V = w.toLowerCase();
    let j;
    for (j of i)
      if (j.toLowerCase() === V) {
        F += '. Did you mean "' + j + '" ?';
        break;
      }
    throw new TypeError(F);
  }
  function c(w) {
    let b =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
    const F = b ? o(b).index : i.length,
      V = [];
    for (let X = 0; X < w.length; ++X) {
      if (
        !w[X] ||
        typeof w[X].name != "string" ||
        typeof w[X].test != "function"
      )
        throw new TypeError(
          "Object with properties {name: string, test: function} expected"
        );
      const oe = w[X].name;
      if (r.has(oe)) throw new TypeError('Duplicate type name "' + oe + '"');
      V.push(oe),
        r.set(oe, {
          name: oe,
          test: w[X].test,
          isAny: w[X].isAny,
          index: F + X,
          conversionsTo: [],
        });
    }
    const j = i.slice(F);
    i = i.slice(0, F).concat(V).concat(j);
    for (let X = F + V.length; X < i.length; ++X) r.get(i[X]).index = X;
  }
  function u() {
    (r = new Map()), (i = []), (a = 0), c([t], !1);
  }
  u(), c(e);
  function l() {
    let w;
    for (w of i) r.get(w).conversionsTo = [];
    a = 0;
  }
  function f(w) {
    const b = i.filter((F) => {
      const V = r.get(F);
      return !V.isAny && V.test(w);
    });
    return b.length ? b : ["any"];
  }
  function h(w) {
    return w && typeof w == "function" && "_typedFunctionData" in w;
  }
  function d(w, b, F) {
    if (!h(w)) throw new TypeError(Uh);
    const V = F && F.exact,
      j = Array.isArray(b) ? b.join(",") : b,
      X = y(j),
      oe = m(X);
    if (!V || oe in w.signatures) {
      const ue = w._typedFunctionData.signatureMap.get(oe);
      if (ue) return ue;
    }
    const ee = X.length;
    let q;
    if (V) {
      q = [];
      let ue;
      for (ue in w.signatures)
        q.push(w._typedFunctionData.signatureMap.get(ue));
    } else q = w._typedFunctionData.signatures;
    for (let ue = 0; ue < ee; ++ue) {
      const ye = X[ue],
        fe = [];
      let Me;
      for (Me of q) {
        const _ = N(Me.params, ue);
        if (!(!_ || (ye.restParam && !_.restParam))) {
          if (!_.hasAny) {
            const U = v(_);
            if (ye.types.some((R) => !U.has(R.name))) continue;
          }
          fe.push(Me);
        }
      }
      if (((q = fe), q.length === 0)) break;
    }
    let P;
    for (P of q) if (P.params.length <= ee) return P;
    throw new TypeError(
      "Signature not found (signature: " +
        (w.name || "unnamed") +
        "(" +
        m(X, ", ") +
        "))"
    );
  }
  function g(w, b, F) {
    return d(w, b, F).implementation;
  }
  function x(w, b) {
    const F = o(b);
    if (F.test(w)) return w;
    const V = F.conversionsTo;
    if (V.length === 0)
      throw new Error("There are no conversions to " + b + " defined.");
    for (let j = 0; j < V.length; j++)
      if (o(V[j].from).test(w)) return V[j].convert(w);
    throw new Error("Cannot convert " + w + " to " + b);
  }
  function m(w) {
    let b =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
    return w.map((F) => F.name).join(b);
  }
  function p(w) {
    const b = w.indexOf("...") === 0,
      V = (b ? (w.length > 3 ? w.slice(3) : "any") : w)
        .split("|")
        .map((ee) => o(ee.trim()));
    let j = !1,
      X = b ? "..." : "";
    return {
      types: V.map(function (ee) {
        return (
          (j = ee.isAny || j),
          (X += ee.name + "|"),
          {
            name: ee.name,
            typeIndex: ee.index,
            test: ee.test,
            isAny: ee.isAny,
            conversion: null,
            conversionIndex: -1,
          }
        );
      }),
      name: X.slice(0, -1),
      hasAny: j,
      hasConversion: !1,
      restParam: b,
    };
  }
  function S(w) {
    const b = w.types.map((oe) => oe.name),
      F = k(b);
    let V = w.hasAny,
      j = w.name;
    const X = F.map(function (oe) {
      const ee = o(oe.from);
      return (
        (V = ee.isAny || V),
        (j += "|" + oe.from),
        {
          name: oe.from,
          typeIndex: ee.index,
          test: ee.test,
          isAny: ee.isAny,
          conversion: oe,
          conversionIndex: oe.index,
        }
      );
    });
    return {
      types: w.types.concat(X),
      name: j,
      hasAny: V,
      hasConversion: X.length > 0,
      restParam: w.restParam,
    };
  }
  function v(w) {
    return (
      w.typeSet ||
        ((w.typeSet = new Set()),
        w.types.forEach((b) => w.typeSet.add(b.name))),
      w.typeSet
    );
  }
  function y(w) {
    const b = [];
    if (typeof w != "string") throw new TypeError("Signatures must be strings");
    const F = w.trim();
    if (F === "") return b;
    const V = F.split(",");
    for (let j = 0; j < V.length; ++j) {
      const X = p(V[j].trim());
      if (X.restParam && j !== V.length - 1)
        throw new SyntaxError(
          'Unexpected rest parameter "' +
            V[j] +
            '": only allowed for the last parameter'
        );
      if (X.types.length === 0) return null;
      b.push(X);
    }
    return b;
  }
  function E(w) {
    const b = Te(w);
    return b ? b.restParam : !1;
  }
  function M(w) {
    if (!w || w.types.length === 0) return Oh;
    if (w.types.length === 1) return o(w.types[0].name).test;
    if (w.types.length === 2) {
      const b = o(w.types[0].name).test,
        F = o(w.types[1].name).test;
      return function (j) {
        return b(j) || F(j);
      };
    } else {
      const b = w.types.map(function (F) {
        return o(F.name).test;
      });
      return function (V) {
        for (let j = 0; j < b.length; j++) if (b[j](V)) return !0;
        return !1;
      };
    }
  }
  function T(w) {
    let b, F, V;
    if (E(w)) {
      b = Pe(w).map(M);
      const j = b.length,
        X = M(Te(w)),
        oe = function (ee) {
          for (let q = j; q < ee.length; q++) if (!X(ee[q])) return !1;
          return !0;
        };
      return function (q) {
        for (let P = 0; P < b.length; P++) if (!b[P](q[P])) return !1;
        return oe(q) && q.length >= j + 1;
      };
    } else
      return w.length === 0
        ? function (X) {
            return X.length === 0;
          }
        : w.length === 1
        ? ((F = M(w[0])),
          function (X) {
            return F(X[0]) && X.length === 1;
          })
        : w.length === 2
        ? ((F = M(w[0])),
          (V = M(w[1])),
          function (X) {
            return F(X[0]) && V(X[1]) && X.length === 2;
          })
        : ((b = w.map(M)),
          function (X) {
            for (let oe = 0; oe < b.length; oe++) if (!b[oe](X[oe])) return !1;
            return X.length === b.length;
          });
  }
  function N(w, b) {
    return b < w.length ? w[b] : E(w) ? Te(w) : null;
  }
  function A(w, b) {
    const F = N(w, b);
    return F ? v(F) : new Set();
  }
  function D(w) {
    return w.conversion === null || w.conversion === void 0;
  }
  function z(w, b) {
    const F = new Set();
    return (
      w.forEach((V) => {
        const j = A(V.params, b);
        let X;
        for (X of j) F.add(X);
      }),
      F.has("any") ? ["any"] : Array.from(F)
    );
  }
  function $(w, b, F) {
    let V, j;
    const X = w || "unnamed";
    let oe = F,
      ee;
    for (ee = 0; ee < b.length; ee++) {
      const ye = [];
      if (
        (oe.forEach((fe) => {
          const Me = N(fe.params, ee),
            _ = M(Me);
          (ee < fe.params.length || E(fe.params)) && _(b[ee]) && ye.push(fe);
        }),
        ye.length === 0)
      ) {
        if (((j = z(oe, ee)), j.length > 0)) {
          const fe = f(b[ee]);
          return (
            (V = new TypeError(
              "Unexpected type of argument in function " +
                X +
                " (expected: " +
                j.join(" or ") +
                ", actual: " +
                fe.join(" | ") +
                ", index: " +
                ee +
                ")"
            )),
            (V.data = {
              category: "wrongType",
              fn: X,
              index: ee,
              actual: fe,
              expected: j,
            }),
            V
          );
        }
      } else oe = ye;
    }
    const q = oe.map(function (ye) {
      return E(ye.params) ? 1 / 0 : ye.params.length;
    });
    if (b.length < Math.min.apply(null, q))
      return (
        (j = z(oe, ee)),
        (V = new TypeError(
          "Too few arguments in function " +
            X +
            " (expected: " +
            j.join(" or ") +
            ", index: " +
            b.length +
            ")"
        )),
        (V.data = {
          category: "tooFewArgs",
          fn: X,
          index: b.length,
          expected: j,
        }),
        V
      );
    const P = Math.max.apply(null, q);
    if (b.length > P)
      return (
        (V = new TypeError(
          "Too many arguments in function " +
            X +
            " (expected: " +
            P +
            ", actual: " +
            b.length +
            ")"
        )),
        (V.data = {
          category: "tooManyArgs",
          fn: X,
          index: b.length,
          expectedLength: P,
        }),
        V
      );
    const ue = [];
    for (let ye = 0; ye < b.length; ++ye) ue.push(f(b[ye]).join("|"));
    return (
      (V = new TypeError(
        'Arguments of type "' +
          ue.join(", ") +
          '" do not match any of the defined signatures of function ' +
          X +
          "."
      )),
      (V.data = { category: "mismatch", actual: ue }),
      V
    );
  }
  function I(w) {
    let b = i.length + 1;
    for (let F = 0; F < w.types.length; F++)
      D(w.types[F]) && (b = Math.min(b, w.types[F].typeIndex));
    return b;
  }
  function G(w) {
    let b = a + 1;
    for (let F = 0; F < w.types.length; F++)
      D(w.types[F]) || (b = Math.min(b, w.types[F].conversionIndex));
    return b;
  }
  function L(w, b) {
    if (w.hasAny) {
      if (!b.hasAny) return 1;
    } else if (b.hasAny) return -1;
    if (w.restParam) {
      if (!b.restParam) return 1;
    } else if (b.restParam) return -1;
    if (w.hasConversion) {
      if (!b.hasConversion) return 1;
    } else if (b.hasConversion) return -1;
    const F = I(w) - I(b);
    if (F < 0) return -1;
    if (F > 0) return 1;
    const V = G(w) - G(b);
    return V < 0 ? -1 : V > 0 ? 1 : 0;
  }
  function C(w, b) {
    const F = w.params,
      V = b.params,
      j = Te(F),
      X = Te(V),
      oe = E(F),
      ee = E(V);
    if (oe && j.hasAny) {
      if (!ee || !X.hasAny) return 1;
    } else if (ee && X.hasAny) return -1;
    let q = 0,
      P = 0,
      ue;
    for (ue of F) ue.hasAny && ++q, ue.hasConversion && ++P;
    let ye = 0,
      fe = 0;
    for (ue of V) ue.hasAny && ++ye, ue.hasConversion && ++fe;
    if (q !== ye) return q - ye;
    if (oe && j.hasConversion) {
      if (!ee || !X.hasConversion) return 1;
    } else if (ee && X.hasConversion) return -1;
    if (P !== fe) return P - fe;
    if (oe) {
      if (!ee) return 1;
    } else if (ee) return -1;
    const Me = (F.length - V.length) * (oe ? -1 : 1);
    if (Me !== 0) return Me;
    const _ = [];
    let U = 0;
    for (let re = 0; re < F.length; ++re) {
      const K = L(F[re], V[re]);
      _.push(K), (U += K);
    }
    if (U !== 0) return U;
    let R;
    for (R of _) if (R !== 0) return R;
    return 0;
  }
  function k(w) {
    if (w.length === 0) return [];
    const b = w.map(o);
    w.length > 1 && b.sort((j, X) => j.index - X.index);
    let F = b[0].conversionsTo;
    if (w.length === 1) return F;
    F = F.concat([]);
    const V = new Set(w);
    for (let j = 1; j < b.length; ++j) {
      let X;
      for (X of b[j].conversionsTo) V.has(X.from) || (F.push(X), V.add(X.from));
    }
    return F;
  }
  function Z(w, b) {
    let F = b;
    if (w.some((j) => j.hasConversion)) {
      const j = E(w),
        X = w.map(ie);
      F = function () {
        const ee = [],
          q = j ? arguments.length - 1 : arguments.length;
        for (let P = 0; P < q; P++) ee[P] = X[P](arguments[P]);
        return j && (ee[q] = arguments[q].map(X[q])), b.apply(this, ee);
      };
    }
    let V = F;
    if (E(w)) {
      const j = w.length - 1;
      V = function () {
        return F.apply(this, ze(arguments, 0, j).concat([ze(arguments, j)]));
      };
    }
    return V;
  }
  function ie(w) {
    let b, F, V, j;
    const X = [],
      oe = [];
    switch (
      (w.types.forEach(function (ee) {
        ee.conversion &&
          (X.push(o(ee.conversion.from).test), oe.push(ee.conversion.convert));
      }),
      oe.length)
    ) {
      case 0:
        return function (q) {
          return q;
        };
      case 1:
        return (
          (b = X[0]),
          (V = oe[0]),
          function (q) {
            return b(q) ? V(q) : q;
          }
        );
      case 2:
        return (
          (b = X[0]),
          (F = X[1]),
          (V = oe[0]),
          (j = oe[1]),
          function (q) {
            return b(q) ? V(q) : F(q) ? j(q) : q;
          }
        );
      default:
        return function (q) {
          for (let P = 0; P < oe.length; P++) if (X[P](q)) return oe[P](q);
          return q;
        };
    }
  }
  function ne(w) {
    function b(F, V, j) {
      if (V < F.length) {
        const X = F[V];
        let oe = [];
        if (X.restParam) {
          const ee = X.types.filter(D);
          ee.length < X.types.length &&
            oe.push({
              types: ee,
              name: "..." + ee.map((q) => q.name).join("|"),
              hasAny: ee.some((q) => q.isAny),
              hasConversion: !1,
              restParam: !0,
            }),
            oe.push(X);
        } else
          oe = X.types.map(function (ee) {
            return {
              types: [ee],
              name: ee.name,
              hasAny: ee.isAny,
              hasConversion: ee.conversion,
              restParam: !1,
            };
          });
        return H(oe, function (ee) {
          return b(F, V + 1, j.concat([ee]));
        });
      } else return [j];
    }
    return b(w, 0, []);
  }
  function Y(w, b) {
    const F = Math.max(w.length, b.length);
    for (let ee = 0; ee < F; ee++) {
      const q = A(w, ee),
        P = A(b, ee);
      let ue = !1,
        ye;
      for (ye of P)
        if (q.has(ye)) {
          ue = !0;
          break;
        }
      if (!ue) return !1;
    }
    const V = w.length,
      j = b.length,
      X = E(w),
      oe = E(b);
    return X ? (oe ? V === j : j >= V) : oe ? V >= j : V === j;
  }
  function W(w) {
    return w.map((b) =>
      Ue(b)
        ? _e(b.referToSelf.callback)
        : ge(b)
        ? he(b.referTo.references, b.referTo.callback)
        : b
    );
  }
  function te(w, b, F) {
    const V = [];
    let j;
    for (j of w) {
      let X = F[j];
      if (typeof X != "number")
        throw new TypeError(
          'No definition for referenced signature "' + j + '"'
        );
      if (((X = b[X]), typeof X != "function")) return !1;
      V.push(X);
    }
    return V;
  }
  function ve(w, b, F) {
    const V = W(w),
      j = new Array(V.length).fill(!1);
    let X = !0;
    for (; X; ) {
      X = !1;
      let oe = !0;
      for (let ee = 0; ee < V.length; ++ee) {
        if (j[ee]) continue;
        const q = V[ee];
        if (Ue(q))
          (V[ee] = q.referToSelf.callback(F)),
            (V[ee].referToSelf = q.referToSelf),
            (j[ee] = !0),
            (oe = !1);
        else if (ge(q)) {
          const P = te(q.referTo.references, V, b);
          P
            ? ((V[ee] = q.referTo.callback.apply(this, P)),
              (V[ee].referTo = q.referTo),
              (j[ee] = !0),
              (oe = !1))
            : (X = !0);
        }
      }
      if (oe && X)
        throw new SyntaxError(
          "Circular reference detected in resolving typed.referTo"
        );
    }
    return V;
  }
  function be(w) {
    const b = /\bthis(\(|\.signatures\b)/;
    Object.keys(w).forEach((F) => {
      const V = w[F];
      if (b.test(V.toString()))
        throw new SyntaxError(
          "Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead."
        );
    });
  }
  function Ae(w, b) {
    if ((s.createCount++, Object.keys(b).length === 0))
      throw new SyntaxError("No signatures provided");
    s.warnAgainstDeprecatedThis && be(b);
    const F = [],
      V = [],
      j = {},
      X = [];
    let oe;
    for (oe in b) {
      if (!Object.prototype.hasOwnProperty.call(b, oe)) continue;
      const Ie = y(oe);
      if (!Ie) continue;
      F.forEach(function (Lt) {
        if (Y(Lt, Ie))
          throw new TypeError(
            'Conflicting signatures "' + m(Lt) + '" and "' + m(Ie) + '".'
          );
      }),
        F.push(Ie);
      const He = V.length;
      V.push(b[oe]);
      const vt = Ie.map(S);
      let pt;
      for (pt of ne(vt)) {
        const Lt = m(pt);
        X.push({ params: pt, name: Lt, fn: He }),
          pt.every((An) => !An.hasConversion) && (j[Lt] = He);
      }
    }
    X.sort(C);
    const ee = ve(V, j, Xe);
    let q;
    for (q in j)
      Object.prototype.hasOwnProperty.call(j, q) && (j[q] = ee[j[q]]);
    const P = [],
      ue = new Map();
    for (q of X)
      ue.has(q.name) || ((q.fn = ee[q.fn]), P.push(q), ue.set(q.name, q));
    const ye = P[0] && P[0].params.length <= 2 && !E(P[0].params),
      fe = P[1] && P[1].params.length <= 2 && !E(P[1].params),
      Me = P[2] && P[2].params.length <= 2 && !E(P[2].params),
      _ = P[3] && P[3].params.length <= 2 && !E(P[3].params),
      U = P[4] && P[4].params.length <= 2 && !E(P[4].params),
      R = P[5] && P[5].params.length <= 2 && !E(P[5].params),
      re = ye && fe && Me && _ && U && R;
    for (let Ie = 0; Ie < P.length; ++Ie) P[Ie].test = T(P[Ie].params);
    const K = ye ? M(P[0].params[0]) : xn,
      le = fe ? M(P[1].params[0]) : xn,
      Se = Me ? M(P[2].params[0]) : xn,
      Ye = _ ? M(P[3].params[0]) : xn,
      it = U ? M(P[4].params[0]) : xn,
      ct = R ? M(P[5].params[0]) : xn,
      Yt = ye ? M(P[0].params[1]) : xn,
      lt = fe ? M(P[1].params[1]) : xn,
      vn = Me ? M(P[2].params[1]) : xn,
      zt = _ ? M(P[3].params[1]) : xn,
      _s = U ? M(P[4].params[1]) : xn,
      ws = R ? M(P[5].params[1]) : xn;
    for (let Ie = 0; Ie < P.length; ++Ie)
      P[Ie].implementation = Z(P[Ie].params, P[Ie].fn);
    const su = ye ? P[0].implementation : zi,
      yi = fe ? P[1].implementation : zi,
      Es = Me ? P[2].implementation : zi,
      xi = _ ? P[3].implementation : zi,
      Ss = U ? P[4].implementation : zi,
      ou = R ? P[5].implementation : zi,
      uu = ye ? P[0].params.length : -1,
      cu = fe ? P[1].params.length : -1,
      O = Me ? P[2].params.length : -1,
      ae = _ ? P[3].params.length : -1,
      de = U ? P[4].params.length : -1,
      se = R ? P[5].params.length : -1,
      pe = re ? 6 : 0,
      Be = P.length,
      Ge = P.map((Ie) => Ie.test),
      qe = P.map((Ie) => Ie.implementation),
      $e = function () {
        for (let He = pe; He < Be; He++)
          if (Ge[He](arguments)) return qe[He].apply(this, arguments);
        return s.onMismatch(w, arguments, P);
      };
    function Xe(Ie, He) {
      return arguments.length === uu && K(Ie) && Yt(He)
        ? su.apply(this, arguments)
        : arguments.length === cu && le(Ie) && lt(He)
        ? yi.apply(this, arguments)
        : arguments.length === O && Se(Ie) && vn(He)
        ? Es.apply(this, arguments)
        : arguments.length === ae && Ye(Ie) && zt(He)
        ? xi.apply(this, arguments)
        : arguments.length === de && it(Ie) && _s(He)
        ? Ss.apply(this, arguments)
        : arguments.length === se && ct(Ie) && ws(He)
        ? ou.apply(this, arguments)
        : $e.apply(this, arguments);
    }
    try {
      Object.defineProperty(Xe, "name", { value: w });
    } catch {}
    return (
      (Xe.signatures = j),
      (Xe._typedFunctionData = { signatures: P, signatureMap: ue }),
      Xe
    );
  }
  function Fe(w, b, F) {
    throw $(w, b, F);
  }
  function Pe(w) {
    return ze(w, 0, w.length - 1);
  }
  function Te(w) {
    return w[w.length - 1];
  }
  function ze(w, b, F) {
    return Array.prototype.slice.call(w, b, F);
  }
  function Ee(w, b) {
    for (let F = 0; F < w.length; F++) if (b(w[F])) return w[F];
  }
  function H(w, b) {
    return Array.prototype.concat.apply([], w.map(b));
  }
  function we() {
    const w = Pe(arguments).map((F) => m(y(F))),
      b = Te(arguments);
    if (typeof b != "function")
      throw new TypeError("Callback function expected as last argument");
    return he(w, b);
  }
  function he(w, b) {
    return { referTo: { references: w, callback: b } };
  }
  function _e(w) {
    if (typeof w != "function")
      throw new TypeError("Callback function expected as first argument");
    return { referToSelf: { callback: w } };
  }
  function ge(w) {
    return (
      w &&
      typeof w.referTo == "object" &&
      Array.isArray(w.referTo.references) &&
      typeof w.referTo.callback == "function"
    );
  }
  function Ue(w) {
    return (
      w &&
      typeof w.referToSelf == "object" &&
      typeof w.referToSelf.callback == "function"
    );
  }
  function J(w, b) {
    if (!w) return b;
    if (b && b !== w) {
      const F = new Error(
        "Function names do not match (expected: " + w + ", actual: " + b + ")"
      );
      throw ((F.data = { actual: b, expected: w }), F);
    }
    return w;
  }
  function Q(w) {
    let b;
    for (const F in w)
      Object.prototype.hasOwnProperty.call(w, F) &&
        (h(w[F]) || typeof w[F].signature == "string") &&
        (b = J(b, w[F].name));
    return b;
  }
  function ce(w, b) {
    let F;
    for (F in b)
      if (Object.prototype.hasOwnProperty.call(b, F)) {
        if (F in w && b[F] !== w[F]) {
          const V = new Error('Signature "' + F + '" is defined twice');
          throw (
            ((V.data = {
              signature: F,
              sourceFunction: b[F],
              destFunction: w[F],
            }),
            V)
          );
        }
        w[F] = b[F];
      }
  }
  const Ce = s;
  (s = function (w) {
    const b = typeof w == "string",
      F = b ? 1 : 0;
    let V = b ? w : "";
    const j = {};
    for (let X = F; X < arguments.length; ++X) {
      const oe = arguments[X];
      let ee = {},
        q;
      if (
        (typeof oe == "function"
          ? ((q = oe.name),
            typeof oe.signature == "string"
              ? (ee[oe.signature] = oe)
              : h(oe) && (ee = oe.signatures))
          : n(oe) && ((ee = oe), b || (q = Q(oe))),
        Object.keys(ee).length === 0)
      ) {
        const P = new TypeError(
          "Argument to 'typed' at index " +
            X +
            " is not a (typed) function, nor an object with signatures as keys and functions as values."
        );
        throw ((P.data = { index: X, argument: oe }), P);
      }
      b || (V = J(V, q)), ce(j, ee);
    }
    return Ae(V || "", j);
  }),
    (s.create = Yg),
    (s.createCount = Ce.createCount),
    (s.onMismatch = Fe),
    (s.throwMismatchError = Fe),
    (s.createError = $),
    (s.clear = u),
    (s.clearConversions = l),
    (s.addTypes = c),
    (s._findType = o),
    (s.referTo = we),
    (s.referToSelf = _e),
    (s.convert = x),
    (s.findSignature = d),
    (s.find = g),
    (s.isTypedFunction = h),
    (s.warnAgainstDeprecatedThis = !0),
    (s.addType = function (w, b) {
      let F = "any";
      b !== !1 && r.has("Object") && (F = "Object"), s.addTypes([w], F);
    });
  function Ne(w) {
    if (
      !w ||
      typeof w.from != "string" ||
      typeof w.to != "string" ||
      typeof w.convert != "function"
    )
      throw new TypeError(
        "Object with properties {from: string, to: string, convert: function} expected"
      );
    if (w.to === w.from)
      throw new SyntaxError(
        'Illegal to define conversion from "' + w.from + '" to itself.'
      );
  }
  return (
    (s.addConversion = function (w) {
      let b =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : { override: !1 };
      Ne(w);
      const F = o(w.to),
        V = F.conversionsTo.find((j) => j.from === w.from);
      if (V)
        if (b && b.override)
          s.removeConversion({ from: V.from, to: w.to, convert: V.convert });
        else
          throw new Error(
            'There is already a conversion from "' +
              w.from +
              '" to "' +
              F.name +
              '"'
          );
      F.conversionsTo.push({ from: w.from, convert: w.convert, index: a++ });
    }),
    (s.addConversions = function (w, b) {
      w.forEach((F) => s.addConversion(F, b));
    }),
    (s.removeConversion = function (w) {
      Ne(w);
      const b = o(w.to),
        F = Ee(b.conversionsTo, (j) => j.from === w.from);
      if (!F)
        throw new Error(
          "Attempt to remove nonexistent conversion from " +
            w.from +
            " to " +
            w.to
        );
      if (F.convert !== w.convert)
        throw new Error(
          "Conversion to remove does not match existing conversion"
        );
      const V = b.conversionsTo.indexOf(F);
      b.conversionsTo.splice(V, 1);
    }),
    (s.resolve = function (w, b) {
      if (!h(w)) throw new TypeError(Uh);
      const F = w._typedFunctionData.signatures;
      for (let V = 0; V < F.length; ++V) if (F[V].test(b)) return F[V];
      return null;
    }),
    s
  );
}
const Kr = Yg();
function on(n, e) {
  if (Jg(n) && Zg(n, e)) return n[e];
  throw typeof n[e] == "function" && hl(n, e)
    ? new Error('Cannot access method "' + e + '" as a property')
    : new Error('No access to property "' + e + '"');
}
function us(n, e, t) {
  if (Jg(n) && Zg(n, e)) return (n[e] = t), t;
  throw new Error('No access to property "' + e + '"');
}
function cS(n, e) {
  return e in n;
}
function Zg(n, e) {
  return !n || typeof n != "object"
    ? !1
    : Ve(fS, e)
    ? !0
    : !(e in Object.prototype || e in Function.prototype);
}
function lS(n, e) {
  if (!hl(n, e)) throw new Error('No access to method "' + e + '"');
  return n[e];
}
function hl(n, e) {
  return n == null ||
    typeof n[e] != "function" ||
    (Ve(n, e) && Object.getPrototypeOf && e in Object.getPrototypeOf(n))
    ? !1
    : Ve(hS, e)
    ? !0
    : !(e in Object.prototype || e in Function.prototype);
}
function Jg(n) {
  return typeof n == "object" && n && n.constructor === Object;
}
var fS = { length: !0, name: !0 },
  hS = { toString: !0, valueOf: !0, toLocaleString: !0 };
class Zo {
  constructor(e) {
    (this.wrappedObject = e), (this[Symbol.iterator] = this.entries);
  }
  keys() {
    return Object.keys(this.wrappedObject).values();
  }
  get(e) {
    return on(this.wrappedObject, e);
  }
  set(e, t) {
    return us(this.wrappedObject, e, t), this;
  }
  has(e) {
    return cS(this.wrappedObject, e);
  }
  entries() {
    return Qg(this.keys(), (e) => [e, this.get(e)]);
  }
  forEach(e) {
    for (var t of this.keys()) e(this.get(t), t, this);
  }
  delete(e) {
    delete this.wrappedObject[e];
  }
  clear() {
    for (var e of this.keys()) this.delete(e);
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
}
class Kg {
  constructor(e, t, r) {
    (this.a = e),
      (this.b = t),
      (this.bKeys = r),
      (this[Symbol.iterator] = this.entries);
  }
  get(e) {
    return this.bKeys.has(e) ? this.b.get(e) : this.a.get(e);
  }
  set(e, t) {
    return this.bKeys.has(e) ? this.b.set(e, t) : this.a.set(e, t), this;
  }
  has(e) {
    return this.b.has(e) || this.a.has(e);
  }
  keys() {
    return new Set([...this.a.keys(), ...this.b.keys()])[Symbol.iterator]();
  }
  entries() {
    return Qg(this.keys(), (e) => [e, this.get(e)]);
  }
  forEach(e) {
    for (var t of this.keys()) e(this.get(t), t, this);
  }
  delete(e) {
    return this.bKeys.has(e) ? this.b.delete(e) : this.a.delete(e);
  }
  clear() {
    this.a.clear(), this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
}
function Qg(n, e) {
  return {
    next: () => {
      var t = n.next();
      return t.done ? t : { value: e(t.value), done: !1 };
    },
  };
}
function cs() {
  return new Map();
}
function ra(n) {
  if (!n) return cs();
  if (e0(n)) return n;
  if (ys(n)) return new Zo(n);
  throw new Error("createMap can create maps from objects or Maps");
}
function dS(n) {
  if (n instanceof Zo) return n.wrappedObject;
  var e = {};
  for (var t of n.keys()) {
    var r = n.get(t);
    us(e, t, r);
  }
  return e;
}
function e0(n) {
  return n
    ? n instanceof Map ||
        n instanceof Zo ||
        (typeof n.set == "function" &&
          typeof n.get == "function" &&
          typeof n.keys == "function" &&
          typeof n.has == "function")
    : !1;
}
var t0 = function () {
    return (t0 = Kr.create), Kr;
  },
  pS = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"],
  mS = me("typed", pS, function (e) {
    var { BigNumber: t, Complex: r, DenseMatrix: i, Fraction: a } = e,
      s = t0();
    return (
      s.clear(),
      s.addTypes([
        { name: "number", test: Dt },
        { name: "Complex", test: ya },
        { name: "BigNumber", test: Bt },
        { name: "Fraction", test: vs },
        { name: "Unit", test: jo },
        {
          name: "identifier",
          test: (o) =>
            Fr &&
            /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(
              o
            ),
        },
        { name: "string", test: Fr },
        { name: "Chain", test: nl },
        { name: "Array", test: el },
        { name: "Matrix", test: tn },
        { name: "DenseMatrix", test: Co },
        { name: "SparseMatrix", test: Yi },
        { name: "Range", test: bm },
        { name: "Index", test: _m },
        { name: "boolean", test: wm },
        { name: "ResultSet", test: Em },
        { name: "Help", test: tl },
        { name: "function", test: Sm },
        { name: "Date", test: Mm },
        { name: "RegExp", test: Am },
        { name: "null", test: Dm },
        { name: "undefined", test: Tm },
        { name: "AccessorNode", test: Pr },
        { name: "ArrayNode", test: pn },
        { name: "AssignmentNode", test: Cm },
        { name: "BlockNode", test: Nm },
        { name: "ConditionalNode", test: Rm },
        { name: "ConstantNode", test: Qe },
        { name: "FunctionNode", test: fr },
        { name: "FunctionAssignmentNode", test: xa },
        { name: "IndexNode", test: pi },
        { name: "Node", test: at },
        { name: "ObjectNode", test: xs },
        { name: "OperatorNode", test: Et },
        { name: "ParenthesisNode", test: Wn },
        { name: "RangeNode", test: Fm },
        { name: "RelationalNode", test: Pm },
        { name: "SymbolNode", test: Rt },
        { name: "Map", test: e0 },
        { name: "Object", test: ys },
      ]),
      s.addConversions([
        {
          from: "number",
          to: "BigNumber",
          convert: function (c) {
            if ((t || tc(c), BE(c) > 15))
              throw new TypeError(
                "Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " +
                  c +
                  "). Use function bignumber(x) to convert to BigNumber."
              );
            return new t(c);
          },
        },
        {
          from: "number",
          to: "Complex",
          convert: function (c) {
            return r || eo(c), new r(c, 0);
          },
        },
        {
          from: "BigNumber",
          to: "Complex",
          convert: function (c) {
            return r || eo(c), new r(c.toNumber(), 0);
          },
        },
        {
          from: "Fraction",
          to: "BigNumber",
          convert: function (c) {
            throw new TypeError(
              "Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction."
            );
          },
        },
        {
          from: "Fraction",
          to: "Complex",
          convert: function (c) {
            return r || eo(c), new r(c.valueOf(), 0);
          },
        },
        {
          from: "number",
          to: "Fraction",
          convert: function (c) {
            a || nc(c);
            var u = new a(c);
            if (u.valueOf() !== c)
              throw new TypeError(
                "Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " +
                  c +
                  "). Use function fraction(x) to convert to Fraction."
              );
            return u;
          },
        },
        {
          from: "string",
          to: "number",
          convert: function (c) {
            var u = Number(c);
            if (isNaN(u))
              throw new Error('Cannot convert "' + c + '" to a number');
            return u;
          },
        },
        {
          from: "string",
          to: "BigNumber",
          convert: function (c) {
            t || tc(c);
            try {
              return new t(c);
            } catch {
              throw new Error('Cannot convert "' + c + '" to BigNumber');
            }
          },
        },
        {
          from: "string",
          to: "Fraction",
          convert: function (c) {
            a || nc(c);
            try {
              return new a(c);
            } catch {
              throw new Error('Cannot convert "' + c + '" to Fraction');
            }
          },
        },
        {
          from: "string",
          to: "Complex",
          convert: function (c) {
            r || eo(c);
            try {
              return new r(c);
            } catch {
              throw new Error('Cannot convert "' + c + '" to Complex');
            }
          },
        },
        {
          from: "boolean",
          to: "number",
          convert: function (c) {
            return +c;
          },
        },
        {
          from: "boolean",
          to: "BigNumber",
          convert: function (c) {
            return t || tc(c), new t(+c);
          },
        },
        {
          from: "boolean",
          to: "Fraction",
          convert: function (c) {
            return a || nc(c), new a(+c);
          },
        },
        {
          from: "boolean",
          to: "string",
          convert: function (c) {
            return String(c);
          },
        },
        {
          from: "Array",
          to: "Matrix",
          convert: function (c) {
            return i || gS(), new i(c);
          },
        },
        {
          from: "Matrix",
          to: "Array",
          convert: function (c) {
            return c.valueOf();
          },
        },
      ]),
      (s.onMismatch = (o, c, u) => {
        var l = s.createError(o, c, u);
        if (
          ["wrongType", "mismatch"].includes(l.data.category) &&
          c.length === 1 &&
          si(c[0]) &&
          u.some((h) => !h.params.includes(","))
        ) {
          var f = new TypeError(
            "Function '".concat(o, "' doesn't apply to matrices. To call it ") +
              "elementwise on a matrix 'M', try 'map(M, ".concat(o, ")'.")
          );
          throw ((f.data = l.data), f);
        }
        throw l;
      }),
      (s.onMismatch = (o, c, u) => {
        var l = s.createError(o, c, u);
        if (
          ["wrongType", "mismatch"].includes(l.data.category) &&
          c.length === 1 &&
          si(c[0]) &&
          u.some((h) => !h.params.includes(","))
        ) {
          var f = new TypeError(
            "Function '".concat(o, "' doesn't apply to matrices. To call it ") +
              "elementwise on a matrix 'M', try 'map(M, ".concat(o, ")'.")
          );
          throw ((f.data = l.data), f);
        }
        throw l;
      }),
      s
    );
  });
function tc(n) {
  throw new Error(
    "Cannot convert value ".concat(
      n,
      " into a BigNumber: no class 'BigNumber' provided"
    )
  );
}
function eo(n) {
  throw new Error(
    "Cannot convert value ".concat(
      n,
      " into a Complex number: no class 'Complex' provided"
    )
  );
}
function gS() {
  throw new Error(
    "Cannot convert array into a Matrix: no class 'DenseMatrix' provided"
  );
}
function nc(n) {
  throw new Error(
    "Cannot convert value ".concat(
      n,
      " into a Fraction, no class 'Fraction' provided."
    )
  );
}
var vS = "ResultSet",
  yS = [],
  xS = me(
    vS,
    yS,
    () => {
      function n(e) {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        this.entries = e || [];
      }
      return (
        (n.prototype.type = "ResultSet"),
        (n.prototype.isResultSet = !0),
        (n.prototype.valueOf = function () {
          return this.entries;
        }),
        (n.prototype.toString = function () {
          return "[" + this.entries.join(", ") + "]";
        }),
        (n.prototype.toJSON = function () {
          return { mathjs: "ResultSet", entries: this.entries };
        }),
        (n.fromJSON = function (e) {
          return new n(e.entries);
        }),
        n
      );
    },
    { isClass: !0 }
  ),
  bS = "Range",
  _S = [],
  wS = me(
    bS,
    _S,
    () => {
      function n(e, t, r) {
        if (!(this instanceof n))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        var i = e != null,
          a = t != null,
          s = r != null;
        if (i) {
          if (Bt(e)) e = e.toNumber();
          else if (typeof e != "number")
            throw new TypeError("Parameter start must be a number");
        }
        if (a) {
          if (Bt(t)) t = t.toNumber();
          else if (typeof t != "number")
            throw new TypeError("Parameter end must be a number");
        }
        if (s) {
          if (Bt(r)) r = r.toNumber();
          else if (typeof r != "number")
            throw new TypeError("Parameter step must be a number");
        }
        (this.start = i ? parseFloat(e) : 0),
          (this.end = a ? parseFloat(t) : 0),
          (this.step = s ? parseFloat(r) : 1);
      }
      return (
        (n.prototype.type = "Range"),
        (n.prototype.isRange = !0),
        (n.parse = function (e) {
          if (typeof e != "string") return null;
          var t = e.split(":"),
            r = t.map(function (a) {
              return parseFloat(a);
            }),
            i = r.some(function (a) {
              return isNaN(a);
            });
          if (i) return null;
          switch (r.length) {
            case 2:
              return new n(r[0], r[1]);
            case 3:
              return new n(r[0], r[2], r[1]);
            default:
              return null;
          }
        }),
        (n.prototype.clone = function () {
          return new n(this.start, this.end, this.step);
        }),
        (n.prototype.size = function () {
          var e = 0,
            t = this.start,
            r = this.step,
            i = this.end,
            a = i - t;
          return (
            Ar(r) === Ar(a) ? (e = Math.ceil(a / r)) : a === 0 && (e = 0),
            isNaN(e) && (e = 0),
            [e]
          );
        }),
        (n.prototype.min = function () {
          var e = this.size()[0];
          if (e > 0)
            return this.step > 0
              ? this.start
              : this.start + (e - 1) * this.step;
        }),
        (n.prototype.max = function () {
          var e = this.size()[0];
          if (e > 0)
            return this.step > 0
              ? this.start + (e - 1) * this.step
              : this.start;
        }),
        (n.prototype.forEach = function (e) {
          var t = this.start,
            r = this.step,
            i = this.end,
            a = 0;
          if (r > 0) for (; t < i; ) e(t, [a], this), (t += r), a++;
          else if (r < 0) for (; t > i; ) e(t, [a], this), (t += r), a++;
        }),
        (n.prototype.map = function (e) {
          var t = [];
          return (
            this.forEach(function (r, i, a) {
              t[i[0]] = e(r, i, a);
            }),
            t
          );
        }),
        (n.prototype.toArray = function () {
          var e = [];
          return (
            this.forEach(function (t, r) {
              e[r[0]] = t;
            }),
            e
          );
        }),
        (n.prototype.valueOf = function () {
          return this.toArray();
        }),
        (n.prototype.format = function (e) {
          var t = Ja(this.start, e);
          return (
            this.step !== 1 && (t += ":" + Ja(this.step, e)),
            (t += ":" + Ja(this.end, e)),
            t
          );
        }),
        (n.prototype.toString = function () {
          return this.format();
        }),
        (n.prototype.toJSON = function () {
          return {
            mathjs: "Range",
            start: this.start,
            end: this.end,
            step: this.step,
          };
        }),
        (n.fromJSON = function (e) {
          return new n(e.start, e.end, e.step);
        }),
        n
      );
    },
    { isClass: !0 }
  );
function rc(n, e, t) {
  var r = n.constructor,
    i = new r(2),
    a = "";
  if (t) {
    if (t < 1) throw new Error("size must be in greater than 0");
    if (!rt(t)) throw new Error("size must be an integer");
    if (n.greaterThan(i.pow(t - 1).sub(1)) || n.lessThan(i.pow(t - 1).mul(-1)))
      throw new Error(
        "Value must be in range [-2^".concat(t - 1, ", 2^").concat(t - 1, "-1]")
      );
    if (!n.isInteger()) throw new Error("Value must be an integer");
    n.lessThan(0) && (n = n.add(i.pow(t))), (a = "i".concat(t));
  }
  switch (e) {
    case 2:
      return "".concat(n.toBinary()).concat(a);
    case 8:
      return "".concat(n.toOctal()).concat(a);
    case 16:
      return "".concat(n.toHexadecimal()).concat(a);
    default:
      throw new Error("Base ".concat(e, " not supported "));
  }
}
function ES(n, e) {
  if (typeof e == "function") return e(n);
  if (!n.isFinite())
    return n.isNaN() ? "NaN" : n.gt(0) ? "Infinity" : "-Infinity";
  var { notation: t, precision: r, wordSize: i } = Om(e);
  switch (t) {
    case "fixed":
      return MS(n, r);
    case "exponential":
      return Bh(n, r);
    case "engineering":
      return SS(n, r);
    case "bin":
      return rc(n, 2, i);
    case "oct":
      return rc(n, 8, i);
    case "hex":
      return rc(n, 16, i);
    case "auto": {
      var a = zh(e == null ? void 0 : e.lowerExp, -3),
        s = zh(e == null ? void 0 : e.upperExp, 5);
      if (n.isZero()) return "0";
      var o,
        c = n.toSignificantDigits(r),
        u = c.e;
      return (
        u >= a && u < s ? (o = c.toFixed()) : (o = Bh(n, r)),
        o.replace(/((\.\d*?)(0+))($|e)/, function () {
          var l = arguments[2],
            f = arguments[4];
          return l !== "." ? l + f : f;
        })
      );
    }
    default:
      throw new Error(
        'Unknown notation "' +
          t +
          '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.'
      );
  }
}
function SS(n, e) {
  var t = n.e,
    r = t % 3 === 0 ? t : t < 0 ? t - 3 - (t % 3) : t - (t % 3),
    i = n.mul(Math.pow(10, -r)),
    a = i.toPrecision(e);
  if (a.includes("e")) {
    var s = n.constructor;
    a = new s(a).toFixed();
  }
  return a + "e" + (t >= 0 ? "+" : "") + r.toString();
}
function Bh(n, e) {
  return e !== void 0 ? n.toExponential(e - 1) : n.toExponential();
}
function MS(n, e) {
  return n.toFixed(e);
}
function zh(n, e) {
  return Dt(n) ? n : Bt(n) ? n.toNumber() : e;
}
function hr(n, e) {
  var t = AS(n, e);
  return e && typeof e == "object" && "truncate" in e && t.length > e.truncate
    ? t.substring(0, e.truncate - 3) + "..."
    : t;
}
function AS(n, e) {
  if (typeof n == "number") return Ja(n, e);
  if (Bt(n)) return ES(n, e);
  if (DS(n))
    return !e || e.fraction !== "decimal"
      ? n.s * n.n + "/" + n.d
      : n.toString();
  if (Array.isArray(n)) return n0(n, e);
  if (Fr(n)) return Zi(n);
  if (typeof n == "function") return n.syntax ? String(n.syntax) : "function";
  if (n && typeof n == "object") {
    if (typeof n.format == "function") return n.format(e);
    if (n && n.toString(e) !== {}.toString()) return n.toString(e);
    var t = Object.keys(n).map((r) => Zi(r) + ": " + hr(n[r], e));
    return "{" + t.join(", ") + "}";
  }
  return String(n);
}
function Zi(n) {
  for (var e = String(n), t = "", r = 0; r < e.length; ) {
    var i = e.charAt(r);
    (t += i in kh ? kh[i] : i), r++;
  }
  return '"' + t + '"';
}
var kh = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
};
function En(n) {
  var e = String(n);
  return (
    (e = e
      .replace(/&/g, "&amp;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")),
    e
  );
}
function n0(n, e) {
  if (Array.isArray(n)) {
    for (var t = "[", r = n.length, i = 0; i < r; i++)
      i !== 0 && (t += ", "), (t += n0(n[i], e));
    return (t += "]"), t;
  } else return hr(n, e);
}
function DS(n) {
  return (
    (n &&
      typeof n == "object" &&
      typeof n.s == "number" &&
      typeof n.n == "number" &&
      typeof n.d == "number") ||
    !1
  );
}
function r0(n, e) {
  if (!Fr(n))
    throw new TypeError(
      "Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " +
        Vt(n) +
        ", index: 0)"
    );
  if (!Fr(e))
    throw new TypeError(
      "Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " +
        Vt(e) +
        ", index: 1)"
    );
  return n === e ? 0 : n > e ? 1 : -1;
}
var TS = "Help",
  CS = ["evaluate"],
  NS = me(
    TS,
    CS,
    (n) => {
      var { evaluate: e } = n;
      function t(r) {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        if (!r) throw new Error('Argument "doc" missing');
        this.doc = r;
      }
      return (
        (t.prototype.type = "Help"),
        (t.prototype.isHelp = !0),
        (t.prototype.toString = function () {
          var r = this.doc || {},
            i = `
`;
          if (
            (r.name &&
              (i +=
                "Name: " +
                r.name +
                `

`),
            r.category &&
              (i +=
                "Category: " +
                r.category +
                `

`),
            r.description &&
              (i +=
                `Description:
    ` +
                r.description +
                `

`),
            r.syntax &&
              (i +=
                `Syntax:
    ` +
                r.syntax.join(`
    `) +
                `

`),
            r.examples)
          ) {
            i += `Examples:
`;
            for (
              var a = !1,
                s = e("config()"),
                o = {
                  config: (f) => (
                    (a = !0), e("config(newConfig)", { newConfig: f })
                  ),
                },
                c = 0;
              c < r.examples.length;
              c++
            ) {
              var u = r.examples[c];
              i +=
                "    " +
                u +
                `
`;
              var l = void 0;
              try {
                l = e(u, o);
              } catch (f) {
                l = f;
              }
              l !== void 0 &&
                !tl(l) &&
                (i +=
                  "        " +
                  hr(l, { precision: 14 }) +
                  `
`);
            }
            (i += `
`),
              a && e("config(originalConfig)", { originalConfig: s });
          }
          return (
            r.mayThrow &&
              r.mayThrow.length &&
              (i +=
                "Throws: " +
                r.mayThrow.join(", ") +
                `

`),
            r.seealso &&
              r.seealso.length &&
              (i +=
                "See also: " +
                r.seealso.join(", ") +
                `
`),
            i
          );
        }),
        (t.prototype.toJSON = function () {
          var r = Mr(this.doc);
          return (r.mathjs = "Help"), r;
        }),
        (t.fromJSON = function (r) {
          var i = {};
          return (
            Object.keys(r)
              .filter((a) => a !== "mathjs")
              .forEach((a) => {
                i[a] = r[a];
              }),
            new t(i)
          );
        }),
        (t.prototype.valueOf = t.prototype.toString),
        t
      );
    },
    { isClass: !0 }
  ),
  RS = "Chain",
  FS = ["?on", "math", "typed"],
  PS = me(
    RS,
    FS,
    (n) => {
      var { on: e, math: t, typed: r } = n;
      function i(u) {
        if (!(this instanceof i))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        nl(u) ? (this.value = u.value) : (this.value = u);
      }
      (i.prototype.type = "Chain"),
        (i.prototype.isChain = !0),
        (i.prototype.done = function () {
          return this.value;
        }),
        (i.prototype.valueOf = function () {
          return this.value;
        }),
        (i.prototype.toString = function () {
          return hr(this.value);
        }),
        (i.prototype.toJSON = function () {
          return { mathjs: "Chain", value: this.value };
        }),
        (i.fromJSON = function (u) {
          return new i(u.value);
        });
      function a(u, l) {
        typeof l == "function" && (i.prototype[u] = o(l));
      }
      function s(u, l) {
        wo(i.prototype, u, function () {
          var h = l();
          if (typeof h == "function") return o(h);
        });
      }
      function o(u) {
        return function () {
          if (arguments.length === 0) return new i(u(this.value));
          for (var l = [this.value], f = 0; f < arguments.length; f++)
            l[f + 1] = arguments[f];
          if (r.isTypedFunction(u)) {
            var h = r.resolve(u, l);
            if (h.params.length === 1)
              throw new Error(
                "chain function " +
                  u.name +
                  " cannot match rest parameter between chain value and additional arguments."
              );
            return new i(h.implementation.apply(u, l));
          }
          return new i(u.apply(u, l));
        };
      }
      i.createProxy = function (u, l) {
        if (typeof u == "string") a(u, l);
        else {
          var f = function (g) {
            Ve(u, g) && c[g] === void 0 && s(g, () => u[g]);
          };
          for (var h in u) f(h);
        }
      };
      var c = {
        expression: !0,
        docs: !0,
        type: !0,
        classes: !0,
        json: !0,
        error: !0,
        isChain: !0,
      };
      return (
        i.createProxy(t),
        e &&
          e("import", function (u, l, f) {
            f || s(u, l);
          }),
        i
      );
    },
    { isClass: !0 }
  ),
  Hh = {
    name: "e",
    category: "Constants",
    syntax: ["e"],
    description:
      "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
    examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
    seealso: ["exp"],
  },
  LS = {
    name: "false",
    category: "Constants",
    syntax: ["false"],
    description: "Boolean value false",
    examples: ["false"],
    seealso: ["true"],
  },
  IS = {
    name: "i",
    category: "Constants",
    syntax: ["i"],
    description:
      "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
    examples: ["i", "i * i", "sqrt(-1)"],
    seealso: [],
  },
  OS = {
    name: "Infinity",
    category: "Constants",
    syntax: ["Infinity"],
    description:
      "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
    examples: ["Infinity", "1 / 0"],
    seealso: [],
  },
  US = {
    name: "LN10",
    category: "Constants",
    syntax: ["LN10"],
    description:
      "Returns the natural logarithm of 10, approximately equal to 2.302",
    examples: ["LN10", "log(10)"],
    seealso: [],
  },
  BS = {
    name: "LN2",
    category: "Constants",
    syntax: ["LN2"],
    description:
      "Returns the natural logarithm of 2, approximately equal to 0.693",
    examples: ["LN2", "log(2)"],
    seealso: [],
  },
  zS = {
    name: "LOG10E",
    category: "Constants",
    syntax: ["LOG10E"],
    description:
      "Returns the base-10 logarithm of E, approximately equal to 0.434",
    examples: ["LOG10E", "log(e, 10)"],
    seealso: [],
  },
  kS = {
    name: "LOG2E",
    category: "Constants",
    syntax: ["LOG2E"],
    description:
      "Returns the base-2 logarithm of E, approximately equal to 1.442",
    examples: ["LOG2E", "log(e, 2)"],
    seealso: [],
  },
  HS = {
    name: "NaN",
    category: "Constants",
    syntax: ["NaN"],
    description: "Not a number",
    examples: ["NaN", "0 / 0"],
    seealso: [],
  },
  GS = {
    name: "null",
    category: "Constants",
    syntax: ["null"],
    description: "Value null",
    examples: ["null"],
    seealso: ["true", "false"],
  },
  VS = {
    name: "phi",
    category: "Constants",
    syntax: ["phi"],
    description:
      "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
    examples: ["phi"],
    seealso: [],
  },
  Gh = {
    name: "pi",
    category: "Constants",
    syntax: ["pi"],
    description:
      "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
    examples: ["pi", "sin(pi/2)"],
    seealso: ["tau"],
  },
  WS = {
    name: "SQRT1_2",
    category: "Constants",
    syntax: ["SQRT1_2"],
    description: "Returns the square root of 1/2, approximately equal to 0.707",
    examples: ["SQRT1_2", "sqrt(1/2)"],
    seealso: [],
  },
  qS = {
    name: "SQRT2",
    category: "Constants",
    syntax: ["SQRT2"],
    description: "Returns the square root of 2, approximately equal to 1.414",
    examples: ["SQRT2", "sqrt(2)"],
    seealso: [],
  },
  $S = {
    name: "tau",
    category: "Constants",
    syntax: ["tau"],
    description:
      "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
    examples: ["tau", "2 * pi"],
    seealso: ["pi"],
  },
  jS = {
    name: "true",
    category: "Constants",
    syntax: ["true"],
    description: "Boolean value true",
    examples: ["true"],
    seealso: ["false"],
  },
  XS = {
    name: "version",
    category: "Constants",
    syntax: ["version"],
    description: "A string with the version number of math.js",
    examples: ["version"],
    seealso: [],
  },
  YS = {
    name: "bignumber",
    category: "Construction",
    syntax: ["bignumber(x)"],
    description: "Create a big number from a number or string.",
    examples: [
      "0.1 + 0.2",
      "bignumber(0.1) + bignumber(0.2)",
      'bignumber("7.2")',
      'bignumber("7.2e500")',
      "bignumber([0.1, 0.2, 0.3])",
    ],
    seealso: [
      "boolean",
      "complex",
      "fraction",
      "index",
      "matrix",
      "string",
      "unit",
    ],
  },
  ZS = {
    name: "boolean",
    category: "Construction",
    syntax: ["x", "boolean(x)"],
    description: "Convert a string or number into a boolean.",
    examples: [
      "boolean(0)",
      "boolean(1)",
      "boolean(3)",
      'boolean("true")',
      'boolean("false")',
      "boolean([1, 0, 1, 1])",
    ],
    seealso: [
      "bignumber",
      "complex",
      "index",
      "matrix",
      "number",
      "string",
      "unit",
    ],
  },
  JS = {
    name: "complex",
    category: "Construction",
    syntax: ["complex()", "complex(re, im)", "complex(string)"],
    description: "Create a complex number.",
    examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
    seealso: [
      "bignumber",
      "boolean",
      "index",
      "matrix",
      "number",
      "string",
      "unit",
    ],
  },
  KS = {
    name: "createUnit",
    category: "Construction",
    syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
    description:
      "Create a user-defined unit and register it with the Unit type.",
    examples: [
      'createUnit("foo")',
      'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})',
      'createUnit("mph", "1 mile/hour")',
    ],
    seealso: ["unit", "splitUnit"],
  },
  QS = {
    name: "fraction",
    category: "Construction",
    syntax: [
      "fraction(num)",
      "fraction(matrix)",
      "fraction(num,den)",
      "fraction({n: num, d: den})",
    ],
    description:
      "Create a fraction from a number or from integer numerator and denominator.",
    examples: [
      "fraction(0.125)",
      "fraction(1, 3) + fraction(2, 5)",
      "fraction({n: 333, d: 53})",
      "fraction([sqrt(9), sqrt(10), sqrt(11)])",
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "matrix",
      "string",
      "unit",
    ],
  },
  eM = {
    name: "index",
    category: "Construction",
    syntax: [
      "[start]",
      "[start:end]",
      "[start:step:end]",
      "[start1, start 2, ...]",
      "[start1:end1, start2:end2, ...]",
      "[start1:step1:end1, start2:step2:end2, ...]",
    ],
    description: "Create an index to get or replace a subset of a matrix",
    examples: [
      "A = [1, 2, 3; 4, 5, 6]",
      "A[1, :]",
      "A[1, 2] = 50",
      "A[1:2, 1:2] = 1",
      "B = [1, 2, 3]",
      "B[B>1 and B<3]",
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "matrix,",
      "number",
      "range",
      "string",
      "unit",
    ],
  },
  tM = {
    name: "matrix",
    category: "Construction",
    syntax: [
      "[]",
      "[a1, b1, ...; a2, b2, ...]",
      "matrix()",
      'matrix("dense")',
      "matrix([...])",
    ],
    description: "Create a matrix.",
    examples: [
      "[]",
      "[1, 2, 3]",
      "[1, 2, 3; 4, 5, 6]",
      "matrix()",
      "matrix([3, 4])",
      'matrix([3, 4; 5, 6], "sparse")',
      'matrix([3, 4; 5, 6], "sparse", "number")',
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "number",
      "string",
      "unit",
      "sparse",
    ],
  },
  nM = {
    name: "number",
    category: "Construction",
    syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
    description:
      "Create a number or convert a string or boolean into a number.",
    examples: [
      "2",
      "2e3",
      "4.05",
      "number(2)",
      'number("7.2")',
      "number(true)",
      "number([true, false, true, true])",
      'number(unit("52cm"), "m")',
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "fraction",
      "index",
      "matrix",
      "string",
      "unit",
    ],
  },
  rM = {
    name: "sparse",
    category: "Construction",
    syntax: [
      "sparse()",
      "sparse([a1, b1, ...; a1, b2, ...])",
      'sparse([a1, b1, ...; a1, b2, ...], "number")',
    ],
    description: "Create a sparse matrix.",
    examples: [
      "sparse()",
      "sparse([3, 4; 5, 6])",
      'sparse([3, 0; 5, 0], "number")',
    ],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "number",
      "string",
      "unit",
      "matrix",
    ],
  },
  iM = {
    name: "splitUnit",
    category: "Construction",
    syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
    description:
      "Split a unit in an array of units whose sum is equal to the original unit.",
    examples: ['splitUnit(1 m, ["feet", "inch"])'],
    seealso: ["unit", "createUnit"],
  },
  aM = {
    name: "string",
    category: "Construction",
    syntax: ['"text"', "string(x)"],
    description: "Create a string or convert a value to a string",
    examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "matrix",
      "number",
      "unit",
    ],
  },
  sM = {
    name: "unit",
    category: "Construction",
    syntax: ["value unit", "unit(value, unit)", "unit(string)"],
    description: "Create a unit.",
    examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
    seealso: [
      "bignumber",
      "boolean",
      "complex",
      "index",
      "matrix",
      "number",
      "string",
    ],
  },
  oM = {
    name: "config",
    category: "Core",
    syntax: ["config()", "config(options)"],
    description: "Get configuration or change configuration.",
    examples: [
      "config()",
      "1/3 + 1/4",
      'config({number: "Fraction"})',
      "1/3 + 1/4",
    ],
    seealso: [],
  },
  uM = {
    name: "import",
    category: "Core",
    syntax: ["import(functions)", "import(functions, options)"],
    description: "Import functions or constants from an object.",
    examples: [
      "import({myFn: f(x)=x^2, myConstant: 32 })",
      "myFn(2)",
      "myConstant",
    ],
    seealso: [],
  },
  cM = {
    name: "typed",
    category: "Core",
    syntax: ["typed(signatures)", "typed(name, signatures)"],
    description: "Create a typed function.",
    examples: [
      'double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })',
      "double(2)",
      'double("hello")',
    ],
    seealso: [],
  },
  lM = {
    name: "derivative",
    category: "Algebra",
    syntax: [
      "derivative(expr, variable)",
      "derivative(expr, variable, {simplify: boolean})",
    ],
    description:
      "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
    examples: [
      'derivative("2x^3", "x")',
      'derivative("2x^3", "x", {simplify: false})',
      'derivative("2x^2 + 3x + 4", "x")',
      'derivative("sin(2x)", "x")',
      'f = parse("x^2 + x")',
      'x = parse("x")',
      "df = derivative(f, x)",
      "df.evaluate({x: 3})",
    ],
    seealso: ["simplify", "parse", "evaluate"],
  },
  fM = {
    name: "leafCount",
    category: "Algebra",
    syntax: ["leafCount(expr)"],
    description:
      "Computes the number of leaves in the parse tree of the given expression",
    examples: [
      'leafCount("e^(i*pi)-1")',
      'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))',
    ],
    seealso: ["simplify"],
  },
  hM = {
    name: "lsolve",
    category: "Algebra",
    syntax: ["x=lsolve(L, b)"],
    description:
      "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"],
  },
  dM = {
    name: "lsolveAll",
    category: "Algebra",
    syntax: ["x=lsolveAll(L, b)"],
    description:
      "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"],
  },
  pM = {
    name: "lup",
    category: "Algebra",
    syntax: ["lup(m)"],
    description:
      "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
    examples: [
      "lup([[2, 1], [1, 4]])",
      "lup(matrix([[2, 1], [1, 4]]))",
      "lup(sparse([[2, 1], [1, 4]]))",
    ],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"],
  },
  mM = {
    name: "lusolve",
    category: "Algebra",
    syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
    description:
      "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
    seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"],
  },
  gM = {
    name: "polynomialRoot",
    category: "Algebra",
    syntax: [
      "x=polynomialRoot(-6, 3)",
      "x=polynomialRoot(4, -4, 1)",
      "x=polynomialRoot(-8, 12, -6, 1)",
    ],
    description:
      "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
    examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
    seealso: ["cbrt", "sqrt"],
  },
  vM = {
    name: "qr",
    category: "Algebra",
    syntax: ["qr(A)"],
    description:
      "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
    examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
    seealso: ["lup", "slu", "matrix"],
  },
  yM = {
    name: "rationalize",
    category: "Algebra",
    syntax: [
      "rationalize(expr)",
      "rationalize(expr, scope)",
      "rationalize(expr, scope, detailed)",
    ],
    description:
      "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
    examples: [
      'rationalize("2x/y - y/(x+1)")',
      'rationalize("2x/y - y/(x+1)", true)',
    ],
    seealso: ["simplify"],
  },
  xM = {
    name: "resolve",
    category: "Algebra",
    syntax: ["resolve(node, scope)"],
    description: "Recursively substitute variables in an expression tree.",
    examples: [
      'resolve(parse("1 + x"), { x: 7 })',
      'resolve(parse("size(text)"), { text: "Hello World" })',
      'resolve(parse("x + y"), { x: parse("3z") })',
      'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })',
    ],
    seealso: ["simplify", "evaluate"],
    mayThrow: ["ReferenceError"],
  },
  bM = {
    name: "simplify",
    category: "Algebra",
    syntax: ["simplify(expr)", "simplify(expr, rules)"],
    description: "Simplify an expression tree.",
    examples: [
      'simplify("3 + 2 / 4")',
      'simplify("2x + x")',
      'f = parse("x * (x + 2 + x)")',
      "simplified = simplify(f)",
      "simplified.evaluate({x: 2})",
    ],
    seealso: [
      "simplifyCore",
      "derivative",
      "evaluate",
      "parse",
      "rationalize",
      "resolve",
    ],
  },
  _M = {
    name: "simplifyConstant",
    category: "Algebra",
    syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
    description: "Replace constant subexpressions of node with their values.",
    examples: [
      'simplifyConstant("(3-3)*x")',
      'simplifyConstant(parse("z-cos(tau/8)"))',
    ],
    seealso: ["simplify", "simplifyCore", "evaluate"],
  },
  wM = {
    name: "simplifyCore",
    category: "Algebra",
    syntax: ["simplifyCore(node)"],
    description:
      "Perform simple one-pass simplifications on an expression tree.",
    examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
    seealso: ["simplify", "simplifyConstant", "evaluate"],
  },
  EM = {
    name: "slu",
    category: "Algebra",
    syntax: ["slu(A, order, threshold)"],
    description:
      "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
    examples: [
      "slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)",
    ],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"],
  },
  SM = {
    name: "symbolicEqual",
    category: "Algebra",
    syntax: [
      "symbolicEqual(expr1, expr2)",
      "symbolicEqual(expr1, expr2, options)",
    ],
    description:
      "Returns true if the difference of the expressions simplifies to 0",
    examples: [
      'symbolicEqual("x*y","y*x")',
      'symbolicEqual("abs(x^2)", "x^2")',
      'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})',
    ],
    seealso: ["simplify", "evaluate"],
  },
  MM = {
    name: "usolve",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description:
      "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: [
      "x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])",
    ],
    seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"],
  },
  AM = {
    name: "usolveAll",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description:
      "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: [
      "x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])",
    ],
    seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"],
  },
  DM = {
    name: "abs",
    category: "Arithmetic",
    syntax: ["abs(x)"],
    description: "Compute the absolute value.",
    examples: ["abs(3.5)", "abs(-4.2)"],
    seealso: ["sign"],
  },
  TM = {
    name: "add",
    category: "Operators",
    syntax: ["x + y", "add(x, y)"],
    description: "Add two values.",
    examples: [
      "a = 2.1 + 3.6",
      "a - 3.6",
      "3 + 2i",
      "3 cm + 2 inch",
      '"2.3" + "4"',
    ],
    seealso: ["subtract"],
  },
  CM = {
    name: "cbrt",
    category: "Arithmetic",
    syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
    description:
      "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
    examples: [
      "cbrt(64)",
      "cube(4)",
      "cbrt(-8)",
      "cbrt(2 + 3i)",
      "cbrt(8i)",
      "cbrt(8i, true)",
      "cbrt(27 m^3)",
    ],
    seealso: ["square", "sqrt", "cube", "multiply"],
  },
  NM = {
    name: "ceil",
    category: "Arithmetic",
    syntax: ["ceil(x)"],
    description:
      "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
    examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
    seealso: ["floor", "fix", "round"],
  },
  RM = {
    name: "cube",
    category: "Arithmetic",
    syntax: ["cube(x)"],
    description: "Compute the cube of a value. The cube of x is x * x * x.",
    examples: ["cube(2)", "2^3", "2 * 2 * 2"],
    seealso: ["multiply", "square", "pow"],
  },
  FM = {
    name: "divide",
    category: "Operators",
    syntax: ["x / y", "divide(x, y)"],
    description: "Divide two values.",
    examples: [
      "a = 2 / 3",
      "a * 3",
      "4.5 / 2",
      "3 + 4 / 2",
      "(3 + 4) / 2",
      "18 km / 4.5",
    ],
    seealso: ["multiply"],
  },
  PM = {
    name: "dotDivide",
    category: "Operators",
    syntax: ["x ./ y", "dotDivide(x, y)"],
    description: "Divide two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
    seealso: ["multiply", "dotMultiply", "divide"],
  },
  LM = {
    name: "dotMultiply",
    category: "Operators",
    syntax: ["x .* y", "dotMultiply(x, y)"],
    description: "Multiply two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
    seealso: ["multiply", "divide", "dotDivide"],
  },
  IM = {
    name: "dotPow",
    category: "Operators",
    syntax: ["x .^ y", "dotPow(x, y)"],
    description: "Calculates the power of x to y element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
    seealso: ["pow"],
  },
  OM = {
    name: "exp",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Calculate the exponent of a value.",
    examples: [
      "exp(1.3)",
      "e ^ 1.3",
      "log(exp(1.3))",
      "x = 2.4",
      "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula",
    ],
    seealso: ["expm", "expm1", "pow", "log"],
  },
  UM = {
    name: "expm",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description:
      "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
    examples: ["expm([[0,2],[0,0]])"],
    seealso: ["exp"],
  },
  BM = {
    name: "expm1",
    category: "Arithmetic",
    syntax: ["expm1(x)"],
    description:
      "Calculate the value of subtracting 1 from the exponential value.",
    examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
    seealso: ["exp", "pow", "log"],
  },
  zM = {
    name: "fix",
    category: "Arithmetic",
    syntax: ["fix(x)"],
    description:
      "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
    examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
    seealso: ["ceil", "floor", "round"],
  },
  kM = {
    name: "floor",
    category: "Arithmetic",
    syntax: ["floor(x)"],
    description:
      "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
    examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
    seealso: ["ceil", "fix", "round"],
  },
  HM = {
    name: "gcd",
    category: "Arithmetic",
    syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
    description: "Compute the greatest common divisor.",
    examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
    seealso: ["lcm", "xgcd"],
  },
  GM = {
    name: "hypot",
    category: "Arithmetic",
    syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
    description: "Calculate the hypotenusa of a list with values. ",
    examples: [
      "hypot(3, 4)",
      "sqrt(3^2 + 4^2)",
      "hypot(-2)",
      "hypot([3, 4, 5])",
    ],
    seealso: ["abs", "norm"],
  },
  VM = {
    name: "invmod",
    category: "Arithmetic",
    syntax: ["invmod(a, b)"],
    description:
      "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",
    examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
    seealso: ["gcd", "xgcd"],
  },
  WM = {
    name: "lcm",
    category: "Arithmetic",
    syntax: ["lcm(x, y)"],
    description: "Compute the least common multiple.",
    examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
    seealso: ["gcd"],
  },
  qM = {
    name: "log",
    category: "Arithmetic",
    syntax: ["log(x)", "log(x, base)"],
    description:
      "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
    examples: [
      "log(3.5)",
      "a = log(2.4)",
      "exp(a)",
      "10 ^ 4",
      "log(10000, 10)",
      "log(10000) / log(10)",
      "b = log(1024, 2)",
      "2 ^ b",
    ],
    seealso: ["exp", "log1p", "log2", "log10"],
  },
  $M = {
    name: "log10",
    category: "Arithmetic",
    syntax: ["log10(x)"],
    description: "Compute the 10-base logarithm of a value.",
    examples: [
      "log10(0.00001)",
      "log10(10000)",
      "10 ^ 4",
      "log(10000) / log(10)",
      "log(10000, 10)",
    ],
    seealso: ["exp", "log"],
  },
  jM = {
    name: "log1p",
    category: "Arithmetic",
    syntax: ["log1p(x)", "log1p(x, base)"],
    description: "Calculate the logarithm of a `value+1`",
    examples: [
      "log1p(2.5)",
      "exp(log1p(1.4))",
      "pow(10, 4)",
      "log1p(9999, 10)",
      "log1p(9999) / log(10)",
    ],
    seealso: ["exp", "log", "log2", "log10"],
  },
  XM = {
    name: "log2",
    category: "Arithmetic",
    syntax: ["log2(x)"],
    description:
      "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
    examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
    seealso: ["exp", "log1p", "log", "log10"],
  },
  YM = {
    name: "mod",
    category: "Operators",
    syntax: ["x % y", "x mod y", "mod(x, y)"],
    description:
      "Calculates the modulus, the remainder of an integer division.",
    examples: [
      "7 % 3",
      "11 % 2",
      "10 mod 4",
      "isOdd(x) = x % 2",
      "isOdd(2)",
      "isOdd(3)",
    ],
    seealso: ["divide"],
  },
  ZM = {
    name: "multiply",
    category: "Operators",
    syntax: ["x * y", "multiply(x, y)"],
    description: "multiply two values.",
    examples: [
      "a = 2.1 * 3.4",
      "a / 3.4",
      "2 * 3 + 4",
      "2 * (3 + 4)",
      "3 * 2.1 km",
    ],
    seealso: ["divide"],
  },
  JM = {
    name: "norm",
    category: "Arithmetic",
    syntax: ["norm(x)", "norm(x, p)"],
    description: "Calculate the norm of a number, vector or matrix.",
    examples: [
      "abs(-3.5)",
      "norm(-3.5)",
      "norm(3 - 4i)",
      "norm([1, 2, -3], Infinity)",
      "norm([1, 2, -3], -Infinity)",
      "norm([3, 4], 2)",
      "norm([[1, 2], [3, 4]], 1)",
      'norm([[1, 2], [3, 4]], "inf")',
      'norm([[1, 2], [3, 4]], "fro")',
    ],
  },
  KM = {
    name: "nthRoot",
    category: "Arithmetic",
    syntax: ["nthRoot(a)", "nthRoot(a, root)"],
    description:
      'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
    examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
    seealso: ["nthRoots", "pow", "sqrt"],
  },
  QM = {
    name: "nthRoots",
    category: "Arithmetic",
    syntax: ["nthRoots(A)", "nthRoots(A, root)"],
    description:
      'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
    examples: ["nthRoots(1)", "nthRoots(1, 3)"],
    seealso: ["sqrt", "pow", "nthRoot"],
  },
  eA = {
    name: "pow",
    category: "Operators",
    syntax: ["x ^ y", "pow(x, y)"],
    description: "Calculates the power of x to y, x^y.",
    examples: [
      "2^3",
      "2*2*2",
      "1 + e ^ (pi * i)",
      "pow([[1, 2], [4, 3]], 2)",
      "pow([[1, 2], [4, 3]], -1)",
    ],
    seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"],
  },
  tA = {
    name: "round",
    category: "Arithmetic",
    syntax: [
      "round(x)",
      "round(x, n)",
      "round(unit, valuelessUnit)",
      "round(unit, n, valuelessUnit)",
    ],
    description:
      "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
    examples: [
      "round(3.2)",
      "round(3.8)",
      "round(-4.2)",
      "round(-4.8)",
      "round(pi, 3)",
      "round(123.45678, 2)",
      "round(3.241cm, 2, cm)",
      "round([3.2, 3.8, -4.7])",
    ],
    seealso: ["ceil", "floor", "fix"],
  },
  nA = {
    name: "sign",
    category: "Arithmetic",
    syntax: ["sign(x)"],
    description:
      "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
    examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
    seealso: ["abs"],
  },
  rA = {
    name: "sqrt",
    category: "Arithmetic",
    syntax: ["sqrt(x)"],
    description:
      "Compute the square root value. If x = y * y, then y is the square root of x.",
    examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
    seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"],
  },
  iA = {
    name: "sqrtm",
    category: "Arithmetic",
    syntax: ["sqrtm(x)"],
    description:
      "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
    examples: ["sqrtm([[33, 24], [48, 57]])"],
    seealso: ["sqrt", "abs", "square", "multiply"],
  },
  aA = {
    name: "sylvester",
    category: "Algebra",
    syntax: ["sylvester(A,B,C)"],
    description: "Solves the real-valued Sylvester equation AX+XB=C for X",
    examples: [
      "sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])",
      "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]",
      "sylvester(A, B, C)",
    ],
    seealso: ["schur", "lyap"],
  },
  sA = {
    name: "schur",
    category: "Algebra",
    syntax: ["schur(A)"],
    description:
      "Performs a real Schur decomposition of the real matrix A = UTU'",
    examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
    seealso: ["lyap", "sylvester"],
  },
  oA = {
    name: "lyap",
    category: "Algebra",
    syntax: ["lyap(A,Q)"],
    description:
      "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
    examples: [
      "lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])",
      "A = [[-2, 0], [1, -4]]",
      "Q = [[3, 1], [1, 3]]",
      "lyap(A,Q)",
    ],
    seealso: ["schur", "sylvester"],
  },
  uA = {
    name: "square",
    category: "Arithmetic",
    syntax: ["square(x)"],
    description: "Compute the square of a value. The square of x is x * x.",
    examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
    seealso: ["multiply", "pow", "sqrt", "cube"],
  },
  cA = {
    name: "subtract",
    category: "Operators",
    syntax: ["x - y", "subtract(x, y)"],
    description: "subtract two values.",
    examples: [
      "a = 5.3 - 2",
      "a + 2",
      "2/3 - 1/6",
      "2 * 3 - 3",
      "2.1 km - 500m",
    ],
    seealso: ["add"],
  },
  lA = {
    name: "unaryMinus",
    category: "Operators",
    syntax: ["-x", "unaryMinus(x)"],
    description:
      "Inverse the sign of a value. Converts booleans and strings to numbers.",
    examples: ["-4.5", "-(-5.6)", '-"22"'],
    seealso: ["add", "subtract", "unaryPlus"],
  },
  fA = {
    name: "unaryPlus",
    category: "Operators",
    syntax: ["+x", "unaryPlus(x)"],
    description: "Converts booleans and strings to numbers.",
    examples: ["+true", '+"2"'],
    seealso: ["add", "subtract", "unaryMinus"],
  },
  hA = {
    name: "xgcd",
    category: "Arithmetic",
    syntax: ["xgcd(a, b)"],
    description:
      "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
    examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
    seealso: ["gcd", "lcm"],
  },
  dA = {
    name: "bitAnd",
    category: "Bitwise",
    syntax: ["x & y", "bitAnd(x, y)"],
    description:
      "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
    examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
    seealso: [
      "bitNot",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  pA = {
    name: "bitNot",
    category: "Bitwise",
    syntax: ["~x", "bitNot(x)"],
    description:
      "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
    examples: ["~1", "~2", "bitNot([2, -3, 4])"],
    seealso: [
      "bitAnd",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  mA = {
    name: "bitOr",
    category: "Bitwise",
    syntax: ["x | y", "bitOr(x, y)"],
    description:
      "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
    examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitXor",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  gA = {
    name: "bitXor",
    category: "Bitwise",
    syntax: ["bitXor(x, y)"],
    description:
      "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
    examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "leftShift",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  vA = {
    name: "leftShift",
    category: "Bitwise",
    syntax: ["x << y", "leftShift(x, y)"],
    description: "Bitwise left logical shift of a value x by y number of bits.",
    examples: ["4 << 1", "8 >> 1"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "bitXor",
      "rightArithShift",
      "rightLogShift",
    ],
  },
  yA = {
    name: "rightArithShift",
    category: "Bitwise",
    syntax: ["x >> y", "rightArithShift(x, y)"],
    description:
      "Bitwise right arithmetic shift of a value x by y number of bits.",
    examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightLogShift",
    ],
  },
  xA = {
    name: "rightLogShift",
    category: "Bitwise",
    syntax: ["x >>> y", "rightLogShift(x, y)"],
    description:
      "Bitwise right logical shift of a value x by y number of bits.",
    examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
    seealso: [
      "bitAnd",
      "bitNot",
      "bitOr",
      "bitXor",
      "leftShift",
      "rightArithShift",
    ],
  },
  bA = {
    name: "bellNumbers",
    category: "Combinatorics",
    syntax: ["bellNumbers(n)"],
    description:
      "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["bellNumbers(3)", "bellNumbers(8)"],
    seealso: ["stirlingS2"],
  },
  _A = {
    name: "catalan",
    category: "Combinatorics",
    syntax: ["catalan(n)"],
    description:
      "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["catalan(3)", "catalan(8)"],
    seealso: ["bellNumbers"],
  },
  wA = {
    name: "composition",
    category: "Combinatorics",
    syntax: ["composition(n, k)"],
    description:
      "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
    examples: ["composition(5, 3)"],
    seealso: ["combinations"],
  },
  EA = {
    name: "stirlingS2",
    category: "Combinatorics",
    syntax: ["stirlingS2(n, k)"],
    description:
      "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
    examples: ["stirlingS2(5, 3)"],
    seealso: ["bellNumbers"],
  },
  SA = {
    name: "arg",
    category: "Complex",
    syntax: ["arg(x)"],
    description:
      "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
    examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
    seealso: ["re", "im", "conj", "abs"],
  },
  MA = {
    name: "conj",
    category: "Complex",
    syntax: ["conj(x)"],
    description:
      "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
    examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
    seealso: ["re", "im", "abs", "arg"],
  },
  AA = {
    name: "im",
    category: "Complex",
    syntax: ["im(x)"],
    description: "Get the imaginary part of a complex number.",
    examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
    seealso: ["re", "conj", "abs", "arg"],
  },
  DA = {
    name: "re",
    category: "Complex",
    syntax: ["re(x)"],
    description: "Get the real part of a complex number.",
    examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
    seealso: ["im", "conj", "abs", "arg"],
  },
  TA = {
    name: "evaluate",
    category: "Expression",
    syntax: [
      "evaluate(expression)",
      "evaluate(expression, scope)",
      "evaluate([expr1, expr2, expr3, ...])",
      "evaluate([expr1, expr2, expr3, ...], scope)",
    ],
    description: "Evaluate an expression or an array with expressions.",
    examples: [
      'evaluate("2 + 3")',
      'evaluate("sqrt(16)")',
      'evaluate("2 inch to cm")',
      'evaluate("sin(x * pi)", { "x": 1/2 })',
      'evaluate(["width=2", "height=4","width*height"])',
    ],
    seealso: [],
  },
  CA = {
    name: "help",
    category: "Expression",
    syntax: ["help(object)", "help(string)"],
    description: "Display documentation on a function or data type.",
    examples: ["help(sqrt)", 'help("complex")'],
    seealso: [],
  },
  NA = {
    name: "distance",
    category: "Geometry",
    syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
    description: "Calculates the Euclidean distance between two points.",
    examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
    seealso: [],
  },
  RA = {
    name: "intersect",
    category: "Geometry",
    syntax: [
      "intersect(expr1, expr2, expr3, expr4)",
      "intersect(expr1, expr2, expr3)",
    ],
    description: "Computes the intersection point of lines and/or planes.",
    examples: [
      "intersect([0, 0], [10, 10], [10, 0], [0, 10])",
      "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])",
    ],
    seealso: [],
  },
  FA = {
    name: "and",
    category: "Logical",
    syntax: ["x and y", "and(x, y)"],
    description:
      "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
    examples: ["true and false", "true and true", "2 and 4"],
    seealso: ["not", "or", "xor"],
  },
  PA = {
    name: "not",
    category: "Logical",
    syntax: ["not x", "not(x)"],
    description: "Logical not. Flips the boolean value of given argument.",
    examples: ["not true", "not false", "not 2", "not 0"],
    seealso: ["and", "or", "xor"],
  },
  LA = {
    name: "or",
    category: "Logical",
    syntax: ["x or y", "or(x, y)"],
    description:
      "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
    examples: ["true or false", "false or false", "0 or 4"],
    seealso: ["not", "and", "xor"],
  },
  IA = {
    name: "xor",
    category: "Logical",
    syntax: ["x xor y", "xor(x, y)"],
    description:
      "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
    examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
    seealso: ["not", "and", "or"],
  },
  OA = {
    name: "column",
    category: "Matrix",
    syntax: ["column(x, index)"],
    description: "Return a column from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
    seealso: ["row", "matrixFromColumns"],
  },
  UA = {
    name: "concat",
    category: "Matrix",
    syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
    description:
      "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
    examples: [
      "A = [1, 2; 5, 6]",
      "B = [3, 4; 7, 8]",
      "concat(A, B)",
      "concat(A, B, 1)",
      "concat(A, B, 2)",
    ],
    seealso: [
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  BA = {
    name: "count",
    category: "Matrix",
    syntax: ["count(x)"],
    description: "Count the number of elements of a matrix, array or string.",
    examples: [
      "a = [1, 2; 3, 4; 5, 6]",
      "count(a)",
      "size(a)",
      'count("hello world")',
    ],
    seealso: ["size"],
  },
  zA = {
    name: "cross",
    category: "Matrix",
    syntax: ["cross(A, B)"],
    description:
      "Calculate the cross product for two vectors in three dimensional space.",
    examples: [
      "cross([1, 1, 0],  [0, 1, 1])",
      "cross([3, -3, 1], [4, 9, 2])",
      "cross([2, 3, 4],  [5, 6, 7])",
    ],
    seealso: ["multiply", "dot"],
  },
  kA = {
    name: "ctranspose",
    category: "Matrix",
    syntax: ["x'", "ctranspose(x)"],
    description: "Complex Conjugate and Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "zeros",
    ],
  },
  HA = {
    name: "det",
    category: "Matrix",
    syntax: ["det(x)"],
    description: "Calculate the determinant of a matrix",
    examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
    seealso: [
      "concat",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  GA = {
    name: "diag",
    category: "Matrix",
    syntax: ["diag(x)", "diag(x, k)"],
    description:
      "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
    examples: [
      "diag(1:3)",
      "diag(1:3, 1)",
      "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]",
      "diag(a)",
    ],
    seealso: [
      "concat",
      "det",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  VA = {
    name: "diff",
    category: "Matrix",
    syntax: ["diff(arr)", "diff(arr, dim)"],
    description: [
      "Create a new matrix or array with the difference of the passed matrix or array.",
      "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference",
      "If no dimension parameter is passed it is assumed as dimension 0",
      "Dimension is zero-based in javascript and one-based in the parser",
      "Arrays must be 'rectangular' meaning arrays like [1, 2]",
      "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays",
    ],
    examples: [
      "A = [1, 2, 4, 7, 0]",
      "diff(A)",
      "diff(A, 1)",
      "B = [[1, 2], [3, 4]]",
      "diff(B)",
      "diff(B, 1)",
      "diff(B, 2)",
      "diff(B, bignumber(2))",
      "diff([[1, 2], matrix([3, 4])], 2)",
    ],
    seealso: ["subtract", "partitionSelect"],
  },
  WA = {
    name: "dot",
    category: "Matrix",
    syntax: ["dot(A, B)", "A * B"],
    description:
      "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
    examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
    seealso: ["multiply", "cross"],
  },
  qA = {
    name: "eigs",
    category: "Matrix",
    syntax: ["eigs(x)"],
    description:
      "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
    examples: [
      "eigs([[5, 2.3], [2.3, 1]])",
      "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })",
    ],
    seealso: ["inv"],
  },
  $A = {
    name: "filter",
    category: "Matrix",
    syntax: ["filter(x, test)"],
    description: "Filter items in a matrix.",
    examples: [
      "isPositive(x) = x > 0",
      "filter([6, -2, -1, 4, 3], isPositive)",
      "filter([6, -2, 0, 1, 0], x != 0)",
    ],
    seealso: ["sort", "map", "forEach"],
  },
  jA = {
    name: "flatten",
    category: "Matrix",
    syntax: ["flatten(x)"],
    description:
      "Flatten a multi dimensional matrix into a single dimensional matrix.",
    examples: [
      "a = [1, 2, 3; 4, 5, 6]",
      "size(a)",
      "b = flatten(a)",
      "size(b)",
    ],
    seealso: ["concat", "resize", "size", "squeeze"],
  },
  XA = {
    name: "forEach",
    category: "Matrix",
    syntax: ["forEach(x, callback)"],
    description:
      "Iterates over all elements of a matrix/array, and executes the given callback function.",
    examples: [
      "numberOfPets = {}",
      "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;",
      'forEach(["Dog","Cat","Cat"], addPet)',
      "numberOfPets",
    ],
    seealso: ["map", "sort", "filter"],
  },
  YA = {
    name: "getMatrixDataType",
    category: "Matrix",
    syntax: ["getMatrixDataType(x)"],
    description:
      'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
    examples: [
      "getMatrixDataType([1, 2, 3])",
      "getMatrixDataType([[5 cm], [2 inch]])",
      'getMatrixDataType([1, "text"])',
      "getMatrixDataType([1, bignumber(4)])",
    ],
    seealso: ["matrix", "sparse", "typeOf"],
  },
  ZA = {
    name: "identity",
    category: "Matrix",
    syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
    description:
      "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
    examples: [
      "identity(3)",
      "identity(3, 5)",
      "a = [1, 2, 3; 4, 5, 6]",
      "identity(size(a))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  JA = {
    name: "inv",
    category: "Matrix",
    syntax: ["inv(x)"],
    description: "Calculate the inverse of a matrix",
    examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  KA = {
    name: "pinv",
    category: "Matrix",
    syntax: ["pinv(x)"],
    description: "Calculate the Moore–Penrose inverse of a matrix",
    examples: [
      "pinv([1, 2; 3, 4])",
      "pinv([[1, 0], [0, 1], [0, 1]])",
      "pinv(4)",
    ],
    seealso: ["inv"],
  },
  QA = {
    name: "kron",
    category: "Matrix",
    syntax: ["kron(x, y)"],
    description: "Calculates the kronecker product of 2 matrices or vectors.",
    examples: [
      "kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])",
      "kron([1,1], [2,3,4])",
    ],
    seealso: ["multiply", "dot", "cross"],
  },
  e2 = {
    name: "map",
    category: "Matrix",
    syntax: ["map(x, callback)"],
    description:
      "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
    examples: ["map([1, 2, 3], square)"],
    seealso: ["filter", "forEach"],
  },
  t2 = {
    name: "matrixFromColumns",
    category: "Matrix",
    syntax: [
      "matrixFromColumns(...arr)",
      "matrixFromColumns(row1, row2)",
      "matrixFromColumns(row1, row2, row3)",
    ],
    description: "Create a dense matrix from vectors as individual columns.",
    examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"],
  },
  n2 = {
    name: "matrixFromFunction",
    category: "Matrix",
    syntax: [
      "matrixFromFunction(size, fn)",
      "matrixFromFunction(size, fn, format)",
      "matrixFromFunction(size, fn, format, datatype)",
      "matrixFromFunction(size, format, fn)",
      "matrixFromFunction(size, format, datatype, fn)",
    ],
    description:
      "Create a matrix by evaluating a generating function at each index.",
    examples: [
      "f(I) = I[1] - I[2]",
      "matrixFromFunction([3,3], f)",
      "g(I) = I[1] - I[2] == 1 ? 4 : 0",
      'matrixFromFunction([100, 100], "sparse", g)',
      "matrixFromFunction([5], random)",
    ],
    seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"],
  },
  r2 = {
    name: "matrixFromRows",
    category: "Matrix",
    syntax: [
      "matrixFromRows(...arr)",
      "matrixFromRows(row1, row2)",
      "matrixFromRows(row1, row2, row3)",
    ],
    description: "Create a dense matrix from vectors as individual rows.",
    examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"],
  },
  i2 = {
    name: "ones",
    category: "Matrix",
    syntax: [
      "ones(m)",
      "ones(m, n)",
      "ones(m, n, p, ...)",
      "ones([m])",
      "ones([m, n])",
      "ones([m, n, p, ...])",
    ],
    description: "Create a matrix containing ones.",
    examples: [
      "ones(3)",
      "ones(3, 5)",
      "ones([2,3]) * 4.5",
      "a = [1, 2, 3; 4, 5, 6]",
      "ones(size(a))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  a2 = {
    name: "partitionSelect",
    category: "Matrix",
    syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
    description:
      "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
    examples: [
      "partitionSelect([5, 10, 1], 2)",
      'partitionSelect(["C", "B", "A", "D"], 1, compareText)',
      "arr = [5, 2, 1]",
      "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]",
      "arr",
      "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]",
      "arr",
    ],
    seealso: ["sort"],
  },
  s2 = {
    name: "range",
    category: "Type",
    syntax: [
      "start:end",
      "start:step:end",
      "range(start, end)",
      "range(start, end, step)",
      "range(string)",
    ],
    description:
      "Create a range. Lower bound of the range is included, upper bound is excluded.",
    examples: [
      "1:5",
      "3:-1:-3",
      "range(3, 7)",
      "range(0, 12, 2)",
      'range("4:10")',
      "range(1m, 1m, 3m)",
      "a = [1, 2, 3, 4; 5, 6, 7, 8]",
      "a[1:2, 1:2]",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  o2 = {
    name: "reshape",
    category: "Matrix",
    syntax: ["reshape(x, sizes)"],
    description:
      "Reshape a multi dimensional array to fit the specified dimensions.",
    examples: [
      "reshape([1, 2, 3, 4, 5, 6], [2, 3])",
      "reshape([[1, 2], [3, 4]], [1, 4])",
      "reshape([[1, 2], [3, 4]], [4])",
      "reshape([1, 2, 3, 4], [-1, 2])",
    ],
    seealso: ["size", "squeeze", "resize"],
  },
  u2 = {
    name: "resize",
    category: "Matrix",
    syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
    description: "Resize a matrix.",
    examples: [
      "resize([1,2,3,4,5], [3])",
      "resize([1,2,3], [5])",
      "resize([1,2,3], [5], -1)",
      "resize(2, [2, 3])",
      'resize("hello", [8], "!")',
    ],
    seealso: ["size", "subset", "squeeze", "reshape"],
  },
  c2 = {
    name: "rotate",
    category: "Matrix",
    syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
    description:
      "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: [
      "rotate([1, 0], pi / 2)",
      'rotate(matrix([1, 0]), unit("35deg"))',
      'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])',
      'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))',
    ],
    seealso: ["matrix", "rotationMatrix"],
  },
  l2 = {
    name: "rotationMatrix",
    category: "Matrix",
    syntax: [
      "rotationMatrix(theta)",
      "rotationMatrix(theta, v)",
      "rotationMatrix(theta, v, format)",
    ],
    description:
      "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: [
      "rotationMatrix(pi / 2)",
      'rotationMatrix(unit("45deg"), [0, 0, 1])',
      'rotationMatrix(1, matrix([0, 0, 1]), "sparse")',
    ],
    seealso: ["cos", "sin"],
  },
  f2 = {
    name: "row",
    category: "Matrix",
    syntax: ["row(x, index)"],
    description: "Return a row from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
    seealso: ["column", "matrixFromRows"],
  },
  h2 = {
    name: "size",
    category: "Matrix",
    syntax: ["size(x)"],
    description: "Calculate the size of a matrix.",
    examples: [
      "size(2.3)",
      'size("hello world")',
      "a = [1, 2; 3, 4; 5, 6]",
      "size(a)",
      "size(1:6)",
    ],
    seealso: [
      "concat",
      "count",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "squeeze",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  d2 = {
    name: "sort",
    category: "Matrix",
    syntax: ["sort(x)", "sort(x, compare)"],
    description:
      'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
    examples: [
      "sort([5, 10, 1])",
      'sort(["C", "B", "A", "D"], "natural")',
      "sortByLength(a, b) = size(a)[1] - size(b)[1]",
      'sort(["Langdon", "Tom", "Sara"], sortByLength)',
      'sort(["10", "1", "2"], "natural")',
    ],
    seealso: ["map", "filter", "forEach"],
  },
  p2 = {
    name: "squeeze",
    category: "Matrix",
    syntax: ["squeeze(x)"],
    description: "Remove inner and outer singleton dimensions from a matrix.",
    examples: [
      "a = zeros(3,2,1)",
      "size(squeeze(a))",
      "b = zeros(1,1,3)",
      "size(squeeze(b))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "subset",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  m2 = {
    name: "subset",
    category: "Matrix",
    syntax: [
      "value(index)",
      "value(index) = replacement",
      "subset(value, [index])",
      "subset(value, [index], replacement)",
    ],
    description:
      "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
    examples: [
      "d = [1, 2; 3, 4]",
      "e = []",
      "e[1, 1:2] = [5, 6]",
      "e[2, :] = [7, 8]",
      "f = d * e",
      "f[2, 1]",
      "f[:, 1]",
      "f[[1,2], [1,3]] = [9, 10; 11, 12]",
      "f",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "trace",
      "transpose",
      "zeros",
    ],
  },
  g2 = {
    name: "trace",
    category: "Matrix",
    syntax: ["trace(A)"],
    description:
      "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
    examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "transpose",
      "zeros",
    ],
  },
  v2 = {
    name: "transpose",
    category: "Matrix",
    syntax: ["x'", "transpose(x)"],
    description: "Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "zeros",
    ],
  },
  y2 = {
    name: "zeros",
    category: "Matrix",
    syntax: [
      "zeros(m)",
      "zeros(m, n)",
      "zeros(m, n, p, ...)",
      "zeros([m])",
      "zeros([m, n])",
      "zeros([m, n, p, ...])",
    ],
    description: "Create a matrix containing zeros.",
    examples: [
      "zeros(3)",
      "zeros(3, 5)",
      "a = [1, 2, 3; 4, 5, 6]",
      "zeros(size(a))",
    ],
    seealso: [
      "concat",
      "det",
      "diag",
      "identity",
      "inv",
      "ones",
      "range",
      "size",
      "squeeze",
      "subset",
      "trace",
      "transpose",
    ],
  },
  x2 = {
    name: "fft",
    category: "Matrix",
    syntax: ["fft(x)"],
    description: "Calculate N-dimensional fourier transform",
    examples: ["fft([[1, 0], [1, 0]])"],
    seealso: ["ifft"],
  },
  b2 = {
    name: "ifft",
    category: "Matrix",
    syntax: ["ifft(x)"],
    description: "Calculate N-dimensional inverse fourier transform",
    examples: ["ifft([[2, 2], [0, 0]])"],
    seealso: ["fft"],
  },
  _2 = {
    name: "combinations",
    category: "Probability",
    syntax: ["combinations(n, k)"],
    description:
      "Compute the number of combinations of n items taken k at a time",
    examples: ["combinations(7, 5)"],
    seealso: ["combinationsWithRep", "permutations", "factorial"],
  },
  w2 = {
    name: "combinationsWithRep",
    category: "Probability",
    syntax: ["combinationsWithRep(n, k)"],
    description:
      "Compute the number of combinations of n items taken k at a time with replacements.",
    examples: ["combinationsWithRep(7, 5)"],
    seealso: ["combinations", "permutations", "factorial"],
  },
  E2 = {
    name: "factorial",
    category: "Probability",
    syntax: ["n!", "factorial(n)"],
    description: "Compute the factorial of a value",
    examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
    seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"],
  },
  S2 = {
    name: "gamma",
    category: "Probability",
    syntax: ["gamma(n)"],
    description:
      "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
    examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
    seealso: ["factorial"],
  },
  M2 = {
    name: "lgamma",
    category: "Probability",
    syntax: ["lgamma(n)"],
    description:
      "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
    examples: [
      "lgamma(4)",
      "lgamma(1/2)",
      "lgamma(i)",
      "lgamma(complex(1.1, 2))",
    ],
    seealso: ["gamma"],
  },
  A2 = {
    name: "kldivergence",
    category: "Probability",
    syntax: ["kldivergence(x, y)"],
    description:
      "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
    examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
    seealso: [],
  },
  D2 = {
    name: "multinomial",
    category: "Probability",
    syntax: ["multinomial(A)"],
    description:
      "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
    examples: ["multinomial([1, 2, 1])"],
    seealso: ["combinations", "factorial"],
  },
  T2 = {
    name: "permutations",
    category: "Probability",
    syntax: ["permutations(n)", "permutations(n, k)"],
    description:
      "Compute the number of permutations of n items taken k at a time",
    examples: ["permutations(5)", "permutations(5, 3)"],
    seealso: ["combinations", "combinationsWithRep", "factorial"],
  },
  C2 = {
    name: "pickRandom",
    category: "Probability",
    syntax: [
      "pickRandom(array)",
      "pickRandom(array, number)",
      "pickRandom(array, weights)",
      "pickRandom(array, number, weights)",
      "pickRandom(array, weights, number)",
    ],
    description: "Pick a random entry from a given array.",
    examples: [
      "pickRandom(0:10)",
      "pickRandom([1, 3, 1, 6])",
      "pickRandom([1, 3, 1, 6], 2)",
      "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])",
      "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])",
      "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)",
    ],
    seealso: ["random", "randomInt"],
  },
  N2 = {
    name: "random",
    category: "Probability",
    syntax: [
      "random()",
      "random(max)",
      "random(min, max)",
      "random(size)",
      "random(size, max)",
      "random(size, min, max)",
    ],
    description: "Return a random number.",
    examples: ["random()", "random(10, 20)", "random([2, 3])"],
    seealso: ["pickRandom", "randomInt"],
  },
  R2 = {
    name: "randomInt",
    category: "Probability",
    syntax: [
      "randomInt(max)",
      "randomInt(min, max)",
      "randomInt(size)",
      "randomInt(size, max)",
      "randomInt(size, min, max)",
    ],
    description: "Return a random integer number",
    examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
    seealso: ["pickRandom", "random"],
  },
  F2 = {
    name: "compare",
    category: "Relational",
    syntax: ["compare(x, y)"],
    description:
      "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: [
      "compare(2, 3)",
      "compare(3, 2)",
      "compare(2, 2)",
      "compare(5cm, 40mm)",
      "compare(2, [1, 2, 3])",
    ],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "smallerEq",
      "largerEq",
      "compareNatural",
      "compareText",
    ],
  },
  P2 = {
    name: "compareNatural",
    category: "Relational",
    syntax: ["compareNatural(x, y)"],
    description:
      "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: [
      "compareNatural(2, 3)",
      "compareNatural(3, 2)",
      "compareNatural(2, 2)",
      "compareNatural(5cm, 40mm)",
      'compareNatural("2", "10")',
      "compareNatural(2 + 3i, 2 + 4i)",
      "compareNatural([1, 2, 4], [1, 2, 3])",
      "compareNatural([1, 5], [1, 2, 3])",
      "compareNatural([1, 2], [1, 2])",
      "compareNatural({a: 2}, {a: 4})",
    ],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "smallerEq",
      "largerEq",
      "compare",
      "compareText",
    ],
  },
  L2 = {
    name: "compareText",
    category: "Relational",
    syntax: ["compareText(x, y)"],
    description:
      "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: [
      'compareText("B", "A")',
      'compareText("A", "B")',
      'compareText("A", "A")',
      'compareText("2", "10")',
      'compare("2", "10")',
      "compare(2, 10)",
      'compareNatural("2", "10")',
      'compareText("B", ["A", "B", "C"])',
    ],
    seealso: ["compare", "compareNatural"],
  },
  I2 = {
    name: "deepEqual",
    category: "Relational",
    syntax: ["deepEqual(x, y)"],
    description:
      "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
    examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "larger",
      "smallerEq",
      "largerEq",
      "compare",
    ],
  },
  O2 = {
    name: "equal",
    category: "Relational",
    syntax: ["x == y", "equal(x, y)"],
    description:
      "Check equality of two values. Returns true if the values are equal, and false if not.",
    examples: [
      "2+2 == 3",
      "2+2 == 4",
      "a = 3.2",
      "b = 6-2.8",
      "a == b",
      "50cm == 0.5m",
    ],
    seealso: [
      "unequal",
      "smaller",
      "larger",
      "smallerEq",
      "largerEq",
      "compare",
      "deepEqual",
      "equalText",
    ],
  },
  U2 = {
    name: "equalText",
    category: "Relational",
    syntax: ["equalText(x, y)"],
    description:
      "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
    examples: [
      'equalText("Hello", "Hello")',
      'equalText("a", "A")',
      'equal("2e3", "2000")',
      'equalText("2e3", "2000")',
      'equalText("B", ["A", "B", "C"])',
    ],
    seealso: ["compare", "compareNatural", "compareText", "equal"],
  },
  B2 = {
    name: "larger",
    category: "Relational",
    syntax: ["x > y", "larger(x, y)"],
    description:
      "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
    examples: [
      "2 > 3",
      "5 > 2*2",
      "a = 3.3",
      "b = 6-2.8",
      "(a > b)",
      "(b < a)",
      "5 cm > 2 inch",
    ],
    seealso: [
      "equal",
      "unequal",
      "smaller",
      "smallerEq",
      "largerEq",
      "compare",
    ],
  },
  z2 = {
    name: "largerEq",
    category: "Relational",
    syntax: ["x >= y", "largerEq(x, y)"],
    description:
      "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
    examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
    seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"],
  },
  k2 = {
    name: "smaller",
    category: "Relational",
    syntax: ["x < y", "smaller(x, y)"],
    description:
      "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
    examples: [
      "2 < 3",
      "5 < 2*2",
      "a = 3.3",
      "b = 6-2.8",
      "(a < b)",
      "5 cm < 2 inch",
    ],
    seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"],
  },
  H2 = {
    name: "smallerEq",
    category: "Relational",
    syntax: ["x <= y", "smallerEq(x, y)"],
    description:
      "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
    seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"],
  },
  G2 = {
    name: "unequal",
    category: "Relational",
    syntax: ["x != y", "unequal(x, y)"],
    description:
      "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
    examples: [
      "2+2 != 3",
      "2+2 != 4",
      "a = 3.2",
      "b = 6-2.8",
      "a != b",
      "50cm != 0.5m",
      "5 cm != 2 inch",
    ],
    seealso: [
      "equal",
      "smaller",
      "larger",
      "smallerEq",
      "largerEq",
      "compare",
      "deepEqual",
    ],
  },
  V2 = {
    name: "setCartesian",
    category: "Set",
    syntax: ["setCartesian(set1, set2)"],
    description:
      "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
    examples: ["setCartesian([1, 2], [3, 4])"],
    seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"],
  },
  W2 = {
    name: "setDifference",
    category: "Set",
    syntax: ["setDifference(set1, set2)"],
    description:
      "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setDifference([1, 2, 3, 4], [3, 4, 5, 6])",
      "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setUnion", "setIntersect", "setSymDifference"],
  },
  q2 = {
    name: "setDistinct",
    category: "Set",
    syntax: ["setDistinct(set)"],
    description:
      "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
    seealso: ["setMultiplicity"],
  },
  $2 = {
    name: "setIntersect",
    category: "Set",
    syntax: ["setIntersect(set1, set2)"],
    description:
      "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setIntersect([1, 2, 3, 4], [3, 4, 5, 6])",
      "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setUnion", "setDifference"],
  },
  j2 = {
    name: "setIsSubset",
    category: "Set",
    syntax: ["setIsSubset(set1, set2)"],
    description:
      "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setIsSubset([1, 2], [3, 4, 5, 6])",
      "setIsSubset([3, 4], [3, 4, 5, 6])",
    ],
    seealso: ["setUnion", "setIntersect", "setDifference"],
  },
  X2 = {
    name: "setMultiplicity",
    category: "Set",
    syntax: ["setMultiplicity(element, set)"],
    description:
      "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: [
      "setMultiplicity(1, [1, 2, 2, 4])",
      "setMultiplicity(2, [1, 2, 2, 4])",
    ],
    seealso: ["setDistinct", "setSize"],
  },
  Y2 = {
    name: "setPowerset",
    category: "Set",
    syntax: ["setPowerset(set)"],
    description:
      "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setPowerset([1, 2, 3])"],
    seealso: ["setCartesian"],
  },
  Z2 = {
    name: "setSize",
    category: "Set",
    syntax: ["setSize(set)", "setSize(set, unique)"],
    description:
      'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
    seealso: ["setUnion", "setIntersect", "setDifference"],
  },
  J2 = {
    name: "setSymDifference",
    category: "Set",
    syntax: ["setSymDifference(set1, set2)"],
    description:
      "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])",
      "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setUnion", "setIntersect", "setDifference"],
  },
  K2 = {
    name: "setUnion",
    category: "Set",
    syntax: ["setUnion(set1, set2)"],
    description:
      "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: [
      "setUnion([1, 2, 3, 4], [3, 4, 5, 6])",
      "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])",
    ],
    seealso: ["setIntersect", "setDifference"],
  },
  Q2 = {
    name: "zpk2tf",
    category: "Signal",
    syntax: ["zpk2tf(z, p, k)"],
    description: "Compute the transfer function of a zero-pole-gain model.",
    examples: [
      "zpk2tf([1, 2], [-1, -2], 1)",
      "zpk2tf([1, 2], [-1, -2])",
      "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])",
    ],
    seealso: [],
  },
  eD = {
    name: "freqz",
    category: "Signal",
    syntax: ["freqz(b, a)", "freqz(b, a, w)"],
    description:
      "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
    examples: [
      "freqz([1, 2], [1, 2, 3])",
      "freqz([1, 2], [1, 2, 3], [0, 1])",
      "freqz([1, 2], [1, 2, 3], 512)",
    ],
    seealso: [],
  },
  tD = {
    name: "erf",
    category: "Special",
    syntax: ["erf(x)"],
    description:
      "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
    examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
    seealso: [],
  },
  nD = {
    name: "zeta",
    category: "Special",
    syntax: ["zeta(s)"],
    description:
      "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
    examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
    seealso: [],
  },
  rD = {
    name: "mad",
    category: "Statistics",
    syntax: ["mad(a, b, c, ...)", "mad(A)"],
    description:
      "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
    examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
    seealso: ["mean", "median", "std", "abs"],
  },
  iD = {
    name: "max",
    category: "Statistics",
    syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
    description: "Compute the maximum value of a list of values.",
    examples: [
      "max(2, 3, 4, 1)",
      "max([2, 3, 4, 1])",
      "max([2, 5; 4, 3])",
      "max([2, 5; 4, 3], 1)",
      "max([2, 5; 4, 3], 2)",
      "max(2.7, 7.1, -4.5, 2.0, 4.1)",
      "min(2.7, 7.1, -4.5, 2.0, 4.1)",
    ],
    seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"],
  },
  aD = {
    name: "mean",
    category: "Statistics",
    syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
    description: "Compute the arithmetic mean of a list of values.",
    examples: [
      "mean(2, 3, 4, 1)",
      "mean([2, 3, 4, 1])",
      "mean([2, 5; 4, 3])",
      "mean([2, 5; 4, 3], 1)",
      "mean([2, 5; 4, 3], 2)",
      "mean([1.0, 2.7, 3.2, 4.0])",
    ],
    seealso: ["max", "median", "min", "prod", "std", "sum", "variance"],
  },
  sD = {
    name: "median",
    category: "Statistics",
    syntax: ["median(a, b, c, ...)", "median(A)"],
    description:
      "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
    examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
    seealso: [
      "max",
      "mean",
      "min",
      "prod",
      "std",
      "sum",
      "variance",
      "quantileSeq",
    ],
  },
  oD = {
    name: "min",
    category: "Statistics",
    syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
    description: "Compute the minimum value of a list of values.",
    examples: [
      "min(2, 3, 4, 1)",
      "min([2, 3, 4, 1])",
      "min([2, 5; 4, 3])",
      "min([2, 5; 4, 3], 1)",
      "min([2, 5; 4, 3], 2)",
      "min(2.7, 7.1, -4.5, 2.0, 4.1)",
      "max(2.7, 7.1, -4.5, 2.0, 4.1)",
    ],
    seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"],
  },
  uD = {
    name: "mode",
    category: "Statistics",
    syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
    description:
      "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
    examples: [
      "mode(2, 1, 4, 3, 1)",
      "mode([1, 2.7, 3.2, 4, 2.7])",
      "mode(1, 4, 6, 1, 6)",
    ],
    seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"],
  },
  cD = {
    name: "prod",
    category: "Statistics",
    syntax: ["prod(a, b, c, ...)", "prod(A)"],
    description: "Compute the product of all values.",
    examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
    seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"],
  },
  lD = {
    name: "quantileSeq",
    category: "Statistics",
    syntax: [
      "quantileSeq(A, prob[, sorted])",
      "quantileSeq(A, [prob1, prob2, ...][, sorted])",
      "quantileSeq(A, N[, sorted])",
    ],
    description: `Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. 

In case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.`,
    examples: [
      "quantileSeq([3, -1, 5, 7], 0.5)",
      "quantileSeq([3, -1, 5, 7], [1/3, 2/3])",
      "quantileSeq([3, -1, 5, 7], 2)",
      "quantileSeq([-1, 3, 5, 7], 0.5, true)",
    ],
    seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"],
  },
  fD = {
    name: "std",
    category: "Statistics",
    syntax: [
      "std(a, b, c, ...)",
      "std(A)",
      "std(A, dimension)",
      "std(A, normalization)",
      "std(A, dimension, normalization)",
    ],
    description:
      'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: [
      "std(2, 4, 6)",
      "std([2, 4, 6, 8])",
      'std([2, 4, 6, 8], "uncorrected")',
      'std([2, 4, 6, 8], "biased")',
      "std([1, 2, 3; 4, 5, 6])",
    ],
    seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"],
  },
  hD = {
    name: "cumsum",
    category: "Statistics",
    syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
    description: "Compute the cumulative sum of all values.",
    examples: [
      "cumsum(2, 3, 4, 1)",
      "cumsum([2, 3, 4, 1])",
      "cumsum([1, 2; 3, 4])",
      "cumsum([1, 2; 3, 4], 1)",
      "cumsum([1, 2; 3, 4], 2)",
    ],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"],
  },
  dD = {
    name: "sum",
    category: "Statistics",
    syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
    description: "Compute the sum of all values.",
    examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"],
  },
  pD = {
    name: "variance",
    category: "Statistics",
    syntax: [
      "variance(a, b, c, ...)",
      "variance(A)",
      "variance(A, dimension)",
      "variance(A, normalization)",
      "variance(A, dimension, normalization)",
    ],
    description:
      'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: [
      "variance(2, 4, 6)",
      "variance([2, 4, 6, 8])",
      'variance([2, 4, 6, 8], "uncorrected")',
      'variance([2, 4, 6, 8], "biased")',
      "variance([1, 2, 3; 4, 5, 6])",
    ],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"],
  },
  mD = {
    name: "corr",
    category: "Statistics",
    syntax: ["corr(A,B)"],
    description:
      "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
    examples: [
      "corr([2, 4, 6, 8],[1, 2, 3, 6])",
      "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))",
    ],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"],
  },
  gD = {
    name: "acos",
    category: "Trigonometry",
    syntax: ["acos(x)"],
    description: "Compute the inverse cosine of a value in radians.",
    examples: ["acos(0.5)", "acos(cos(2.3))"],
    seealso: ["cos", "atan", "asin"],
  },
  vD = {
    name: "acosh",
    category: "Trigonometry",
    syntax: ["acosh(x)"],
    description:
      "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
    examples: ["acosh(1.5)"],
    seealso: ["cosh", "asinh", "atanh"],
  },
  yD = {
    name: "acot",
    category: "Trigonometry",
    syntax: ["acot(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
    seealso: ["cot", "atan"],
  },
  xD = {
    name: "acoth",
    category: "Trigonometry",
    syntax: ["acoth(x)"],
    description:
      "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
    examples: ["acoth(2)", "acoth(0.5)"],
    seealso: ["acsch", "asech"],
  },
  bD = {
    name: "acsc",
    category: "Trigonometry",
    syntax: ["acsc(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
    seealso: ["csc", "asin", "asec"],
  },
  _D = {
    name: "acsch",
    category: "Trigonometry",
    syntax: ["acsch(x)"],
    description:
      "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
    examples: ["acsch(0.5)"],
    seealso: ["asech", "acoth"],
  },
  wD = {
    name: "asec",
    category: "Trigonometry",
    syntax: ["asec(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
    seealso: ["acos", "acot", "acsc"],
  },
  ED = {
    name: "asech",
    category: "Trigonometry",
    syntax: ["asech(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asech(0.5)"],
    seealso: ["acsch", "acoth"],
  },
  SD = {
    name: "asin",
    category: "Trigonometry",
    syntax: ["asin(x)"],
    description: "Compute the inverse sine of a value in radians.",
    examples: ["asin(0.5)", "asin(sin(0.5))"],
    seealso: ["sin", "acos", "atan"],
  },
  MD = {
    name: "asinh",
    category: "Trigonometry",
    syntax: ["asinh(x)"],
    description:
      "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
    examples: ["asinh(0.5)"],
    seealso: ["acosh", "atanh"],
  },
  AD = {
    name: "atan",
    category: "Trigonometry",
    syntax: ["atan(x)"],
    description: "Compute the inverse tangent of a value in radians.",
    examples: ["atan(0.5)", "atan(tan(0.5))"],
    seealso: ["tan", "acos", "asin"],
  },
  DD = {
    name: "atan2",
    category: "Trigonometry",
    syntax: ["atan2(y, x)"],
    description:
      "Computes the principal value of the arc tangent of y/x in radians.",
    examples: [
      "atan2(2, 2) / pi",
      "angle = 60 deg in rad",
      "x = cos(angle)",
      "y = sin(angle)",
      "atan2(y, x)",
    ],
    seealso: ["sin", "cos", "tan"],
  },
  TD = {
    name: "atanh",
    category: "Trigonometry",
    syntax: ["atanh(x)"],
    description:
      "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
    examples: ["atanh(0.5)"],
    seealso: ["acosh", "asinh"],
  },
  CD = {
    name: "cos",
    category: "Trigonometry",
    syntax: ["cos(x)"],
    description: "Compute the cosine of x in radians.",
    examples: [
      "cos(2)",
      "cos(pi / 4) ^ 2",
      "cos(180 deg)",
      "cos(60 deg)",
      "sin(0.2)^2 + cos(0.2)^2",
    ],
    seealso: ["acos", "sin", "tan"],
  },
  ND = {
    name: "cosh",
    category: "Trigonometry",
    syntax: ["cosh(x)"],
    description: "Compute the hyperbolic cosine of x in radians.",
    examples: ["cosh(0.5)"],
    seealso: ["sinh", "tanh", "coth"],
  },
  RD = {
    name: "cot",
    category: "Trigonometry",
    syntax: ["cot(x)"],
    description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
    examples: ["cot(2)", "1 / tan(2)"],
    seealso: ["sec", "csc", "tan"],
  },
  FD = {
    name: "coth",
    category: "Trigonometry",
    syntax: ["coth(x)"],
    description: "Compute the hyperbolic cotangent of x in radians.",
    examples: ["coth(2)", "1 / tanh(2)"],
    seealso: ["sech", "csch", "tanh"],
  },
  PD = {
    name: "csc",
    category: "Trigonometry",
    syntax: ["csc(x)"],
    description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
    examples: ["csc(2)", "1 / sin(2)"],
    seealso: ["sec", "cot", "sin"],
  },
  LD = {
    name: "csch",
    category: "Trigonometry",
    syntax: ["csch(x)"],
    description:
      "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
    examples: ["csch(2)", "1 / sinh(2)"],
    seealso: ["sech", "coth", "sinh"],
  },
  ID = {
    name: "sec",
    category: "Trigonometry",
    syntax: ["sec(x)"],
    description: "Compute the secant of x in radians. Defined as 1/cos(x)",
    examples: ["sec(2)", "1 / cos(2)"],
    seealso: ["cot", "csc", "cos"],
  },
  OD = {
    name: "sech",
    category: "Trigonometry",
    syntax: ["sech(x)"],
    description:
      "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
    examples: ["sech(2)", "1 / cosh(2)"],
    seealso: ["coth", "csch", "cosh"],
  },
  UD = {
    name: "sin",
    category: "Trigonometry",
    syntax: ["sin(x)"],
    description: "Compute the sine of x in radians.",
    examples: [
      "sin(2)",
      "sin(pi / 4) ^ 2",
      "sin(90 deg)",
      "sin(30 deg)",
      "sin(0.2)^2 + cos(0.2)^2",
    ],
    seealso: ["asin", "cos", "tan"],
  },
  BD = {
    name: "sinh",
    category: "Trigonometry",
    syntax: ["sinh(x)"],
    description: "Compute the hyperbolic sine of x in radians.",
    examples: ["sinh(0.5)"],
    seealso: ["cosh", "tanh"],
  },
  zD = {
    name: "tan",
    category: "Trigonometry",
    syntax: ["tan(x)"],
    description: "Compute the tangent of x in radians.",
    examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
    seealso: ["atan", "sin", "cos"],
  },
  kD = {
    name: "tanh",
    category: "Trigonometry",
    syntax: ["tanh(x)"],
    description: "Compute the hyperbolic tangent of x in radians.",
    examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
    seealso: ["sinh", "cosh"],
  },
  HD = {
    name: "to",
    category: "Units",
    syntax: ["x to unit", "to(x, unit)"],
    description: "Change the unit of a value.",
    examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
    seealso: [],
  },
  GD = {
    name: "bin",
    category: "Utils",
    syntax: ["bin(value)"],
    description: "Format a number as binary",
    examples: ["bin(2)"],
    seealso: ["oct", "hex"],
  },
  VD = {
    name: "clone",
    category: "Utils",
    syntax: ["clone(x)"],
    description:
      "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
    examples: [
      "clone(3.5)",
      "clone(2 - 4i)",
      "clone(45 deg)",
      "clone([1, 2; 3, 4])",
      'clone("hello world")',
    ],
    seealso: [],
  },
  WD = {
    name: "format",
    category: "Utils",
    syntax: ["format(value)", "format(value, precision)"],
    description: "Format a value of any type as string.",
    examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
    seealso: ["print"],
  },
  qD = {
    name: "hasNumericValue",
    category: "Utils",
    syntax: ["hasNumericValue(x)"],
    description:
      "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
    examples: [
      "hasNumericValue(2)",
      'hasNumericValue("2")',
      'isNumeric("2")',
      "hasNumericValue(0)",
      "hasNumericValue(bignumber(500))",
      "hasNumericValue(fraction(0.125))",
      "hasNumericValue(2 + 3i)",
      'hasNumericValue([2.3, "foo", false])',
    ],
    seealso: [
      "isInteger",
      "isZero",
      "isNegative",
      "isPositive",
      "isNaN",
      "isNumeric",
    ],
  },
  $D = {
    name: "hex",
    category: "Utils",
    syntax: ["hex(value)"],
    description: "Format a number as hexadecimal",
    examples: ["hex(240)"],
    seealso: ["bin", "oct"],
  },
  jD = {
    name: "isInteger",
    category: "Utils",
    syntax: ["isInteger(x)"],
    description: "Test whether a value is an integer number.",
    examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"],
  },
  XD = {
    name: "isNaN",
    category: "Utils",
    syntax: ["isNaN(x)"],
    description: "Test whether a value is NaN (not a number)",
    examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"],
  },
  YD = {
    name: "isNegative",
    category: "Utils",
    syntax: ["isNegative(x)"],
    description: "Test whether a value is negative: smaller than zero.",
    examples: [
      "isNegative(2)",
      "isNegative(0)",
      "isNegative(-4)",
      "isNegative([3, 0.5, -2])",
    ],
    seealso: ["isInteger", "isNumeric", "isPositive", "isZero"],
  },
  ZD = {
    name: "isNumeric",
    category: "Utils",
    syntax: ["isNumeric(x)"],
    description:
      "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
    examples: [
      "isNumeric(2)",
      'isNumeric("2")',
      'hasNumericValue("2")',
      "isNumeric(0)",
      "isNumeric(bignumber(500))",
      "isNumeric(fraction(0.125))",
      "isNumeric(2 + 3i)",
      'isNumeric([2.3, "foo", false])',
    ],
    seealso: [
      "isInteger",
      "isZero",
      "isNegative",
      "isPositive",
      "isNaN",
      "hasNumericValue",
    ],
  },
  JD = {
    name: "isPositive",
    category: "Utils",
    syntax: ["isPositive(x)"],
    description: "Test whether a value is positive: larger than zero.",
    examples: [
      "isPositive(2)",
      "isPositive(0)",
      "isPositive(-4)",
      "isPositive([3, 0.5, -2])",
    ],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"],
  },
  KD = {
    name: "isPrime",
    category: "Utils",
    syntax: ["isPrime(x)"],
    description:
      "Test whether a value is prime: has no divisors other than itself and one.",
    examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"],
  },
  QD = {
    name: "isZero",
    category: "Utils",
    syntax: ["isZero(x)"],
    description: "Test whether a value is zero.",
    examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"],
  },
  eT = {
    name: "numeric",
    category: "Utils",
    syntax: ["numeric(x)"],
    description:
      "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
    examples: [
      'numeric("4")',
      'numeric("4", "number")',
      'numeric("4", "BigNumber")',
      'numeric("4", "Fraction")',
      'numeric(4, "Fraction")',
      'numeric(fraction(2, 5), "number")',
    ],
    seealso: ["number", "fraction", "bignumber", "string", "format"],
  },
  tT = {
    name: "oct",
    category: "Utils",
    syntax: ["oct(value)"],
    description: "Format a number as octal",
    examples: ["oct(56)"],
    seealso: ["bin", "hex"],
  },
  nT = {
    name: "print",
    category: "Utils",
    syntax: ["print(template, values)", "print(template, values, precision)"],
    description: "Interpolate values into a string template.",
    examples: [
      'print("Lucy is $age years old", {age: 5})',
      'print("The value of pi is $pi", {pi: pi}, 3)',
      'print("Hello, $user.name!", {user: {name: "John"}})',
      'print("Values: $1, $2, $3", [6, 9, 4])',
    ],
    seealso: ["format"],
  },
  rT = {
    name: "typeOf",
    category: "Utils",
    syntax: ["typeOf(x)"],
    description: "Get the type of a variable.",
    examples: [
      "typeOf(3.5)",
      "typeOf(2 - 4i)",
      "typeOf(45 deg)",
      'typeOf("hello world")',
    ],
    seealso: ["getMatrixDataType"],
  },
  iT = {
    name: "solveODE",
    category: "Numeric",
    syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
    description: "Numerical Integration of Ordinary Differential Equations.",
    examples: [
      "f(t,y) = y",
      "tspan = [0, 4]",
      "solveODE(f, tspan, 1)",
      "solveODE(f, tspan, [1, 2])",
      'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })',
    ],
    seealso: ["derivative", "simplifyCore"],
  },
  aT = {
    bignumber: YS,
    boolean: ZS,
    complex: JS,
    createUnit: KS,
    fraction: QS,
    index: eM,
    matrix: tM,
    number: nM,
    sparse: rM,
    splitUnit: iM,
    string: aM,
    unit: sM,
    e: Hh,
    E: Hh,
    false: LS,
    i: IS,
    Infinity: OS,
    LN2: BS,
    LN10: US,
    LOG2E: kS,
    LOG10E: zS,
    NaN: HS,
    null: GS,
    pi: Gh,
    PI: Gh,
    phi: VS,
    SQRT1_2: WS,
    SQRT2: qS,
    tau: $S,
    true: jS,
    version: XS,
    speedOfLight: {
      description: "Speed of light in vacuum",
      examples: ["speedOfLight"],
    },
    gravitationConstant: {
      description: "Newtonian constant of gravitation",
      examples: ["gravitationConstant"],
    },
    planckConstant: {
      description: "Planck constant",
      examples: ["planckConstant"],
    },
    reducedPlanckConstant: {
      description: "Reduced Planck constant",
      examples: ["reducedPlanckConstant"],
    },
    magneticConstant: {
      description: "Magnetic constant (vacuum permeability)",
      examples: ["magneticConstant"],
    },
    electricConstant: {
      description: "Electric constant (vacuum permeability)",
      examples: ["electricConstant"],
    },
    vacuumImpedance: {
      description: "Characteristic impedance of vacuum",
      examples: ["vacuumImpedance"],
    },
    coulomb: { description: "Coulomb's constant", examples: ["coulomb"] },
    elementaryCharge: {
      description: "Elementary charge",
      examples: ["elementaryCharge"],
    },
    bohrMagneton: { description: "Borh magneton", examples: ["bohrMagneton"] },
    conductanceQuantum: {
      description: "Conductance quantum",
      examples: ["conductanceQuantum"],
    },
    inverseConductanceQuantum: {
      description: "Inverse conductance quantum",
      examples: ["inverseConductanceQuantum"],
    },
    magneticFluxQuantum: {
      description: "Magnetic flux quantum",
      examples: ["magneticFluxQuantum"],
    },
    nuclearMagneton: {
      description: "Nuclear magneton",
      examples: ["nuclearMagneton"],
    },
    klitzing: { description: "Von Klitzing constant", examples: ["klitzing"] },
    bohrRadius: { description: "Borh radius", examples: ["bohrRadius"] },
    classicalElectronRadius: {
      description: "Classical electron radius",
      examples: ["classicalElectronRadius"],
    },
    electronMass: { description: "Electron mass", examples: ["electronMass"] },
    fermiCoupling: {
      description: "Fermi coupling constant",
      examples: ["fermiCoupling"],
    },
    fineStructure: {
      description: "Fine-structure constant",
      examples: ["fineStructure"],
    },
    hartreeEnergy: {
      description: "Hartree energy",
      examples: ["hartreeEnergy"],
    },
    protonMass: { description: "Proton mass", examples: ["protonMass"] },
    deuteronMass: { description: "Deuteron Mass", examples: ["deuteronMass"] },
    neutronMass: { description: "Neutron mass", examples: ["neutronMass"] },
    quantumOfCirculation: {
      description: "Quantum of circulation",
      examples: ["quantumOfCirculation"],
    },
    rydberg: { description: "Rydberg constant", examples: ["rydberg"] },
    thomsonCrossSection: {
      description: "Thomson cross section",
      examples: ["thomsonCrossSection"],
    },
    weakMixingAngle: {
      description: "Weak mixing angle",
      examples: ["weakMixingAngle"],
    },
    efimovFactor: { description: "Efimov factor", examples: ["efimovFactor"] },
    atomicMass: {
      description: "Atomic mass constant",
      examples: ["atomicMass"],
    },
    avogadro: { description: "Avogadro's number", examples: ["avogadro"] },
    boltzmann: { description: "Boltzmann constant", examples: ["boltzmann"] },
    faraday: { description: "Faraday constant", examples: ["faraday"] },
    firstRadiation: {
      description: "First radiation constant",
      examples: ["firstRadiation"],
    },
    loschmidt: {
      description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
      examples: ["loschmidt"],
    },
    gasConstant: { description: "Gas constant", examples: ["gasConstant"] },
    molarPlanckConstant: {
      description: "Molar Planck constant",
      examples: ["molarPlanckConstant"],
    },
    molarVolume: {
      description:
        "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
      examples: ["molarVolume"],
    },
    sackurTetrode: {
      description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
      examples: ["sackurTetrode"],
    },
    secondRadiation: {
      description: "Second radiation constant",
      examples: ["secondRadiation"],
    },
    stefanBoltzmann: {
      description: "Stefan-Boltzmann constant",
      examples: ["stefanBoltzmann"],
    },
    wienDisplacement: {
      description: "Wien displacement law constant",
      examples: ["wienDisplacement"],
    },
    molarMass: { description: "Molar mass constant", examples: ["molarMass"] },
    molarMassC12: {
      description: "Molar mass constant of carbon-12",
      examples: ["molarMassC12"],
    },
    gravity: {
      description:
        "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
      examples: ["gravity"],
    },
    planckLength: { description: "Planck length", examples: ["planckLength"] },
    planckMass: { description: "Planck mass", examples: ["planckMass"] },
    planckTime: { description: "Planck time", examples: ["planckTime"] },
    planckCharge: { description: "Planck charge", examples: ["planckCharge"] },
    planckTemperature: {
      description: "Planck temperature",
      examples: ["planckTemperature"],
    },
    derivative: lM,
    lsolve: hM,
    lsolveAll: dM,
    lup: pM,
    lusolve: mM,
    leafCount: fM,
    polynomialRoot: gM,
    resolve: xM,
    simplify: bM,
    simplifyConstant: _M,
    simplifyCore: wM,
    symbolicEqual: SM,
    rationalize: yM,
    slu: EM,
    usolve: MM,
    usolveAll: AM,
    qr: vM,
    abs: DM,
    add: TM,
    cbrt: CM,
    ceil: NM,
    cube: RM,
    divide: FM,
    dotDivide: PM,
    dotMultiply: LM,
    dotPow: IM,
    exp: OM,
    expm: UM,
    expm1: BM,
    fix: zM,
    floor: kM,
    gcd: HM,
    hypot: GM,
    lcm: WM,
    log: qM,
    log2: XM,
    log1p: jM,
    log10: $M,
    mod: YM,
    multiply: ZM,
    norm: JM,
    nthRoot: KM,
    nthRoots: QM,
    pow: eA,
    round: tA,
    sign: nA,
    sqrt: rA,
    sqrtm: iA,
    square: uA,
    subtract: cA,
    unaryMinus: lA,
    unaryPlus: fA,
    xgcd: hA,
    invmod: VM,
    bitAnd: dA,
    bitNot: pA,
    bitOr: mA,
    bitXor: gA,
    leftShift: vA,
    rightArithShift: yA,
    rightLogShift: xA,
    bellNumbers: bA,
    catalan: _A,
    composition: wA,
    stirlingS2: EA,
    config: oM,
    import: uM,
    typed: cM,
    arg: SA,
    conj: MA,
    re: DA,
    im: AA,
    evaluate: TA,
    help: CA,
    distance: NA,
    intersect: RA,
    and: FA,
    not: PA,
    or: LA,
    xor: IA,
    concat: UA,
    count: BA,
    cross: zA,
    column: OA,
    ctranspose: kA,
    det: HA,
    diag: GA,
    diff: VA,
    dot: WA,
    getMatrixDataType: YA,
    identity: ZA,
    filter: $A,
    flatten: jA,
    forEach: XA,
    inv: JA,
    pinv: KA,
    eigs: qA,
    kron: QA,
    matrixFromFunction: n2,
    matrixFromRows: r2,
    matrixFromColumns: t2,
    map: e2,
    ones: i2,
    partitionSelect: a2,
    range: s2,
    resize: u2,
    reshape: o2,
    rotate: c2,
    rotationMatrix: l2,
    row: f2,
    size: h2,
    sort: d2,
    squeeze: p2,
    subset: m2,
    trace: g2,
    transpose: v2,
    zeros: y2,
    fft: x2,
    ifft: b2,
    sylvester: aA,
    schur: sA,
    lyap: oA,
    solveODE: iT,
    combinations: _2,
    combinationsWithRep: w2,
    factorial: E2,
    gamma: S2,
    kldivergence: A2,
    lgamma: M2,
    multinomial: D2,
    permutations: T2,
    pickRandom: C2,
    random: N2,
    randomInt: R2,
    compare: F2,
    compareNatural: P2,
    compareText: L2,
    deepEqual: I2,
    equal: O2,
    equalText: U2,
    larger: B2,
    largerEq: z2,
    smaller: k2,
    smallerEq: H2,
    unequal: G2,
    setCartesian: V2,
    setDifference: W2,
    setDistinct: q2,
    setIntersect: $2,
    setIsSubset: j2,
    setMultiplicity: X2,
    setPowerset: Y2,
    setSize: Z2,
    setSymDifference: J2,
    setUnion: K2,
    zpk2tf: Q2,
    freqz: eD,
    erf: tD,
    zeta: nD,
    cumsum: hD,
    mad: rD,
    max: iD,
    mean: aD,
    median: sD,
    min: oD,
    mode: uD,
    prod: cD,
    quantileSeq: lD,
    std: fD,
    sum: dD,
    variance: pD,
    corr: mD,
    acos: gD,
    acosh: vD,
    acot: yD,
    acoth: xD,
    acsc: bD,
    acsch: _D,
    asec: wD,
    asech: ED,
    asin: SD,
    asinh: MD,
    atan: AD,
    atanh: TD,
    atan2: DD,
    cos: CD,
    cosh: ND,
    cot: RD,
    coth: FD,
    csc: PD,
    csch: LD,
    sec: ID,
    sech: OD,
    sin: UD,
    sinh: BD,
    tan: zD,
    tanh: kD,
    to: HD,
    clone: VD,
    format: WD,
    bin: GD,
    oct: tT,
    hex: $D,
    isNaN: XD,
    isInteger: jD,
    isNegative: YD,
    isNumeric: ZD,
    hasNumericValue: qD,
    isPositive: JD,
    isPrime: KD,
    isZero: QD,
    print: nT,
    typeOf: rT,
    numeric: eT,
  },
  Vh = "help",
  sT = ["typed", "mathWithTransform", "Help"],
  oT = me(Vh, sT, (n) => {
    var { typed: e, mathWithTransform: t, Help: r } = n;
    return e(Vh, {
      any: function (a) {
        var s,
          o = a;
        if (typeof a != "string") {
          for (s in t)
            if (Ve(t, s) && a === t[s]) {
              o = s;
              break;
            }
        }
        var c = on(aT, o);
        if (!c) {
          var u = typeof o == "function" ? o.name : o;
          throw new Error('No documentation found on "' + u + '"');
        }
        return new r(c);
      },
    });
  }),
  Wh = "chain",
  uT = ["typed", "Chain"],
  cT = me(Wh, uT, (n) => {
    var { typed: e, Chain: t } = n;
    return e(Wh, {
      "": function () {
        return new t();
      },
      any: function (i) {
        return new t(i);
      },
    });
  }),
  lT = "resolve",
  fT = [
    "typed",
    "parse",
    "ConstantNode",
    "FunctionNode",
    "OperatorNode",
    "ParenthesisNode",
  ],
  hT = me(lT, fT, (n) => {
    var {
      typed: e,
      parse: t,
      ConstantNode: r,
      FunctionNode: i,
      OperatorNode: a,
      ParenthesisNode: s,
    } = n;
    function o(c, u) {
      var l =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : new Set();
      if (!u) return c;
      if (Rt(c)) {
        if (l.has(c.name)) {
          var f = Array.from(l).join(", ");
          throw new ReferenceError(
            "recursive loop of variable definitions among {".concat(f, "}")
          );
        }
        var h = u.get(c.name);
        if (at(h)) {
          var d = new Set(l);
          return d.add(c.name), o(h, u, d);
        } else
          return typeof h == "number"
            ? t(String(h))
            : h !== void 0
            ? new r(h)
            : c;
      } else if (Et(c)) {
        var g = c.args.map(function (m) {
          return o(m, u, l);
        });
        return new a(c.op, c.fn, g, c.implicit);
      } else {
        if (Wn(c)) return new s(o(c.content, u, l));
        if (fr(c)) {
          var x = c.args.map(function (m) {
            return o(m, u, l);
          });
          return new i(c.name, x);
        }
      }
      return c.map((m) => o(m, u, l));
    }
    return e("resolve", {
      Node: o,
      "Node, Map | null | undefined": o,
      "Node, Object": (c, u) => o(c, ra(u)),
      "Array | Matrix": e.referToSelf((c) => (u) => u.map((l) => c(l))),
      "Array | Matrix, null | undefined": e.referToSelf(
        (c) => (u) => u.map((l) => c(l))
      ),
      "Array, Object": e.referTo("Array,Map", (c) => (u, l) => c(u, ra(l))),
      "Matrix, Object": e.referTo("Matrix,Map", (c) => (u, l) => c(u, ra(l))),
      "Array | Matrix, Map": e.referToSelf(
        (c) => (u, l) => u.map((f) => c(f, l))
      ),
    });
  });
function qh(n) {
  return Qe(n) || (Et(n) && n.isUnary() && Qe(n.args[0]));
}
function No(n) {
  return !!(
    Qe(n) ||
    ((fr(n) || Et(n)) && n.args.every(No)) ||
    (Wn(n) && No(n.content))
  );
}
function ls(n) {
  "@babel/helpers - typeof";
  return (
    (ls =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    ls(n)
  );
}
function dT(n, e) {
  if (ls(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (ls(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function pT(n) {
  var e = dT(n, "string");
  return ls(e) == "symbol" ? e : e + "";
}
function Wt(n, e, t) {
  return (
    (e = pT(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function $h(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable;
      })),
      t.push.apply(t, r);
  }
  return t;
}
function ic(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? $h(Object(t), !0).forEach(function (r) {
          Wt(n, r, t[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : $h(Object(t)).forEach(function (r) {
          Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
        });
  }
  return n;
}
var mT = "simplifyUtil",
  gT = ["FunctionNode", "OperatorNode", "SymbolNode"],
  dl = me(mT, gT, (n) => {
    var { FunctionNode: e, OperatorNode: t, SymbolNode: r } = n,
      i = !0,
      a = !1,
      s = "defaultF",
      o = {
        add: { trivial: i, total: i, commutative: i, associative: i },
        unaryPlus: { trivial: i, total: i, commutative: i, associative: i },
        subtract: { trivial: a, total: i, commutative: a, associative: a },
        multiply: { trivial: i, total: i, commutative: i, associative: i },
        divide: { trivial: a, total: i, commutative: a, associative: a },
        paren: { trivial: i, total: i, commutative: i, associative: a },
        defaultF: { trivial: a, total: i, commutative: a, associative: a },
      },
      c = { divide: { total: a }, log: { total: a } },
      u = { subtract: { total: a }, abs: { trivial: i }, log: { total: i } };
    function l(v, y) {
      var E =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : o,
        M = s;
      if (
        (typeof v == "string"
          ? (M = v)
          : Et(v)
          ? (M = v.fn.toString())
          : fr(v)
          ? (M = v.name)
          : Wn(v) && (M = "paren"),
        Ve(E, M))
      ) {
        var T = E[M];
        if (Ve(T, y)) return T[y];
        if (Ve(o, M)) return o[M][y];
      }
      if (Ve(E, s)) {
        var N = E[s];
        return Ve(N, y) ? N[y] : o[s][y];
      }
      if (Ve(o, M)) {
        var A = o[M];
        if (Ve(A, y)) return A[y];
      }
      return o[s][y];
    }
    function f(v) {
      var y =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : o;
      return l(v, "commutative", y);
    }
    function h(v) {
      var y =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : o;
      return l(v, "associative", y);
    }
    function d(v, y) {
      var E = ic({}, v);
      for (var M in y)
        Ve(v, M) ? (E[M] = ic(ic({}, y[M]), v[M])) : (E[M] = y[M]);
      return E;
    }
    function g(v, y) {
      if (!v.args || v.args.length === 0) return v;
      v.args = x(v, y);
      for (var E = 0; E < v.args.length; E++) g(v.args[E], y);
    }
    function x(v, y) {
      var E,
        M = [],
        T = function N(A) {
          for (var D = 0; D < A.args.length; D++) {
            var z = A.args[D];
            Et(z) && E === z.op ? N(z) : M.push(z);
          }
        };
      return h(v, y) ? ((E = v.op), T(v), M) : v.args;
    }
    function m(v, y) {
      if (!(!v.args || v.args.length === 0)) {
        for (var E = S(v), M = v.args.length, T = 0; T < M; T++)
          m(v.args[T], y);
        if (M > 2 && h(v, y)) {
          for (var N = v.args.pop(); v.args.length > 0; )
            N = E([v.args.pop(), N]);
          v.args = N.args;
        }
      }
    }
    function p(v, y) {
      if (!(!v.args || v.args.length === 0)) {
        for (var E = S(v), M = v.args.length, T = 0; T < M; T++)
          p(v.args[T], y);
        if (M > 2 && h(v, y)) {
          for (var N = v.args.shift(); v.args.length > 0; )
            N = E([N, v.args.shift()]);
          v.args = N.args;
        }
      }
    }
    function S(v) {
      return Et(v)
        ? function (y) {
            try {
              return new t(v.op, v.fn, y, v.implicit);
            } catch (E) {
              return console.error(E), [];
            }
          }
        : function (y) {
            return new e(new r(v.name), y);
          };
    }
    return {
      createMakeNodeFunction: S,
      hasProperty: l,
      isCommutative: f,
      isAssociative: h,
      mergeContext: d,
      flatten: g,
      allChildren: x,
      unflattenr: m,
      unflattenl: p,
      defaultContext: o,
      realContext: c,
      positiveContext: u,
    };
  }),
  vT = "simplify",
  yT = [
    "config",
    "typed",
    "parse",
    "add",
    "subtract",
    "multiply",
    "divide",
    "pow",
    "isZero",
    "equal",
    "resolve",
    "simplifyConstant",
    "simplifyCore",
    "?fraction",
    "?bignumber",
    "mathWithTransform",
    "matrix",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "ParenthesisNode",
    "SymbolNode",
  ],
  xT = me(vT, yT, (n) => {
    var {
        config: e,
        typed: t,
        parse: r,
        add: i,
        subtract: a,
        multiply: s,
        divide: o,
        pow: c,
        isZero: u,
        equal: l,
        resolve: f,
        simplifyConstant: h,
        simplifyCore: d,
        fraction: g,
        bignumber: x,
        mathWithTransform: m,
        matrix: p,
        AccessorNode: S,
        ArrayNode: v,
        ConstantNode: y,
        FunctionNode: E,
        IndexNode: M,
        ObjectNode: T,
        OperatorNode: N,
        ParenthesisNode: A,
        SymbolNode: D,
      } = n,
      {
        hasProperty: z,
        isCommutative: $,
        isAssociative: I,
        mergeContext: G,
        flatten: L,
        unflattenr: C,
        unflattenl: k,
        createMakeNodeFunction: Z,
        defaultContext: ie,
        realContext: ne,
        positiveContext: Y,
      } = dl({ FunctionNode: E, OperatorNode: N, SymbolNode: D });
    t.addConversion({ from: "Object", to: "Map", convert: ra });
    var W = t("simplify", {
      Node: Te,
      "Node, Map": (J, Q) => Te(J, !1, Q),
      "Node, Map, Object": (J, Q, ce) => Te(J, !1, Q, ce),
      "Node, Array": Te,
      "Node, Array, Map": Te,
      "Node, Array, Map, Object": Te,
    });
    t.removeConversion({ from: "Object", to: "Map", convert: ra }),
      (W.defaultContext = ie),
      (W.realContext = ne),
      (W.positiveContext = Y);
    function te(J) {
      return J.transform(function (Q, ce, Ce) {
        return Wn(Q) ? te(Q.content) : Q;
      });
    }
    var ve = {
      true: !0,
      false: !0,
      e: !0,
      i: !0,
      Infinity: !0,
      LN2: !0,
      LN10: !0,
      LOG2E: !0,
      LOG10E: !0,
      NaN: !0,
      phi: !0,
      pi: !0,
      SQRT1_2: !0,
      SQRT2: !0,
      tau: !0,
    };
    W.rules = [
      d,
      { l: "log(e)", r: "1" },
      { s: "n-n1 -> n+-n1", assuming: { subtract: { total: !0 } } },
      { s: "n-n -> 0", assuming: { subtract: { total: !1 } } },
      {
        s: "-(cl*v) -> v * (-cl)",
        assuming: { multiply: { commutative: !0 }, subtract: { total: !0 } },
      },
      {
        s: "-(cl*v) -> (-cl) * v",
        assuming: { multiply: { commutative: !1 }, subtract: { total: !0 } },
      },
      {
        s: "-(v*cl) -> v * (-cl)",
        assuming: { multiply: { commutative: !1 }, subtract: { total: !0 } },
      },
      { l: "-(n1/n2)", r: "-n1/n2" },
      { l: "-v", r: "v * (-1)" },
      { l: "(n1 + n2)*(-1)", r: "n1*(-1) + n2*(-1)", repeat: !0 },
      { l: "n/n1^n2", r: "n*n1^-n2" },
      { l: "n/n1", r: "n*n1^-1" },
      {
        s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
        assuming: { multiply: { commutative: !0 } },
      },
      {
        s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
        assuming: { divide: { total: !0 } },
      },
      { l: " vd   * ( vd   * n1 + n2)", r: "vd^2       * n1 +  vd   * n2" },
      {
        s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
        assuming: { divide: { total: !0 } },
      },
      {
        s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
        assuming: { divide: { total: !0 } },
      },
      {
        s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
        assuming: { divide: { total: !0 } },
      },
      { l: "n*n", r: "n^2" },
      { s: "n * n^n1 -> n^(n1+1)", assuming: { divide: { total: !0 } } },
      { s: "n^n1 * n^n2 -> n^(n1+n2)", assuming: { divide: { total: !0 } } },
      h,
      { s: "n+n -> 2*n", assuming: { add: { total: !0 } } },
      { l: "n+-n", r: "0" },
      { l: "vd*n + vd", r: "vd*(n+1)" },
      { l: "n3*n1 + n3*n2", r: "n3*(n1+n2)" },
      { l: "n3^(-n4)*n1 +   n3  * n2", r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)" },
      { l: "n3^(-n4)*n1 + n3^n5 * n2", r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)" },
      {
        s: "n*vd + vd -> (n+1)*vd",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "vd + n*vd -> (1+n)*vd",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "n^n1 * n -> n^(n1+1)",
        assuming: { divide: { total: !0 }, multiply: { commutative: !1 } },
      },
      {
        s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
        assuming: { multiply: { commutative: !1 } },
      },
      { l: "n*cd + cd", r: "(n+1)*cd" },
      {
        s: "cd*n + cd -> cd*(n+1)",
        assuming: { multiply: { commutative: !1 } },
      },
      {
        s: "cd + cd*n -> cd*(1+n)",
        assuming: { multiply: { commutative: !1 } },
      },
      h,
      { s: "(-n)*n1 -> -(n*n1)", assuming: { subtract: { total: !0 } } },
      {
        s: "n1*(-n) -> -(n1*n)",
        assuming: { subtract: { total: !0 }, multiply: { commutative: !1 } },
      },
      {
        s: "ce+ve -> ve+ce",
        assuming: { add: { commutative: !0 } },
        imposeContext: { add: { commutative: !1 } },
      },
      {
        s: "vd*cd -> cd*vd",
        assuming: { multiply: { commutative: !0 } },
        imposeContext: { multiply: { commutative: !1 } },
      },
      { l: "n+-n1", r: "n-n1" },
      { l: "n+-(n1)", r: "n-(n1)" },
      { s: "n*(n1^-1) -> n/n1", assuming: { multiply: { commutative: !0 } } },
      { s: "n*n1^-n2 -> n/n1^n2", assuming: { multiply: { commutative: !0 } } },
      { s: "n^-1 -> 1/n", assuming: { multiply: { commutative: !0 } } },
      { l: "n^1", r: "n" },
      {
        s: "n*(n1/n2) -> (n*n1)/n2",
        assuming: { multiply: { associative: !0 } },
      },
      {
        s: "n-(n1+n2) -> n-n1-n2",
        assuming: { addition: { associative: !0, commutative: !0 } },
      },
      { l: "1*n", r: "n", imposeContext: { multiply: { commutative: !0 } } },
      {
        s: "n1/(n2/n3) -> (n1*n3)/n2",
        assuming: { multiply: { associative: !0 } },
      },
      { l: "n1/(-n2)", r: "-n1/n2" },
    ];
    function be(J, Q) {
      var ce = {};
      if (J.s) {
        var Ce = J.s.split("->");
        if (Ce.length === 2) (ce.l = Ce[0]), (ce.r = Ce[1]);
        else throw SyntaxError("Could not parse rule: " + J.s);
      } else (ce.l = J.l), (ce.r = J.r);
      (ce.l = te(r(ce.l))), (ce.r = te(r(ce.r)));
      for (var Ne of ["imposeContext", "repeat", "assuming"])
        Ne in J && (ce[Ne] = J[Ne]);
      if ((J.evaluate && (ce.evaluate = r(J.evaluate)), I(ce.l, Q))) {
        var w = !$(ce.l, Q),
          b;
        w && (b = Pe());
        var F = Z(ce.l),
          V = Pe();
        (ce.expanded = {}),
          (ce.expanded.l = F([ce.l, V])),
          L(ce.expanded.l, Q),
          C(ce.expanded.l, Q),
          (ce.expanded.r = F([ce.r, V])),
          w &&
            ((ce.expandedNC1 = {}),
            (ce.expandedNC1.l = F([b, ce.l])),
            (ce.expandedNC1.r = F([b, ce.r])),
            (ce.expandedNC2 = {}),
            (ce.expandedNC2.l = F([b, ce.expanded.l])),
            (ce.expandedNC2.r = F([b, ce.expanded.r])));
      }
      return ce;
    }
    function Ae(J, Q) {
      for (var ce = [], Ce = 0; Ce < J.length; Ce++) {
        var Ne = J[Ce],
          w = void 0,
          b = typeof Ne;
        switch (b) {
          case "string":
            Ne = { s: Ne };
          case "object":
            w = be(Ne, Q);
            break;
          case "function":
            w = Ne;
            break;
          default:
            throw TypeError("Unsupported type of rule: " + b);
        }
        ce.push(w);
      }
      return ce;
    }
    var Fe = 0;
    function Pe() {
      return new D("_p" + Fe++);
    }
    function Te(J, Q) {
      var ce =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : cs(),
        Ce =
          arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
        Ne = Ce.consoleDebug;
      Q = Ae(Q || W.rules, Ce.context);
      var w = f(J, ce);
      w = te(w);
      for (var b = {}, F = w.toString({ parenthesis: "all" }); !b[F]; ) {
        (b[F] = !0), (Fe = 0);
        var V = F;
        Ne && console.log("Working on: ", F);
        for (var j = 0; j < Q.length; j++) {
          var X = "";
          if (
            (typeof Q[j] == "function"
              ? ((w = Q[j](w, Ce)), Ne && (X = Q[j].name))
              : (L(w, Ce.context),
                (w = Ee(w, Q[j], Ce.context)),
                Ne &&
                  (X = ""
                    .concat(Q[j].l.toString(), " -> ")
                    .concat(Q[j].r.toString()))),
            Ne)
          ) {
            var oe = w.toString({ parenthesis: "all" });
            oe !== V && (console.log("Applying", X, "produced", oe), (V = oe));
          }
          k(w, Ce.context);
        }
        F = w.toString({ parenthesis: "all" });
      }
      return w;
    }
    function ze(J, Q, ce) {
      var Ce = J;
      if (J)
        for (var Ne = 0; Ne < J.length; ++Ne) {
          var w = Ee(J[Ne], Q, ce);
          w !== J[Ne] && (Ce === J && (Ce = J.slice()), (Ce[Ne] = w));
        }
      return Ce;
    }
    function Ee(J, Q, ce) {
      if (Q.assuming) {
        for (var Ce in Q.assuming)
          for (var Ne in Q.assuming[Ce])
            if (z(Ce, Ne, ce) !== Q.assuming[Ce][Ne]) return J;
      }
      var w = G(Q.imposeContext, ce),
        b = J;
      if (b instanceof N || b instanceof E) {
        var F = ze(b.args, Q, ce);
        F !== b.args && ((b = b.clone()), (b.args = F));
      } else if (b instanceof A) {
        if (b.content) {
          var V = Ee(b.content, Q, ce);
          V !== b.content && (b = new A(V));
        }
      } else if (b instanceof v) {
        var j = ze(b.items, Q, ce);
        j !== b.items && (b = new v(j));
      } else if (b instanceof S) {
        var X = b.object;
        b.object && (X = Ee(b.object, Q, ce));
        var oe = b.index;
        b.index && (oe = Ee(b.index, Q, ce)),
          (X !== b.object || oe !== b.index) && (b = new S(X, oe));
      } else if (b instanceof M) {
        var ee = ze(b.dimensions, Q, ce);
        ee !== b.dimensions && (b = new M(ee));
      } else if (b instanceof T) {
        var q = !1,
          P = {};
        for (var ue in b.properties)
          (P[ue] = Ee(b.properties[ue], Q, ce)),
            P[ue] !== b.properties[ue] && (q = !0);
        q && (b = new T(P));
      }
      var ye = Q.r,
        fe = ge(Q.l, b, w)[0];
      if (
        (!fe &&
          Q.expanded &&
          ((ye = Q.expanded.r), (fe = ge(Q.expanded.l, b, w)[0])),
        !fe &&
          Q.expandedNC1 &&
          ((ye = Q.expandedNC1.r),
          (fe = ge(Q.expandedNC1.l, b, w)[0]),
          fe || ((ye = Q.expandedNC2.r), (fe = ge(Q.expandedNC2.l, b, w)[0]))),
        fe)
      ) {
        var Me = b.implicit;
        (b = ye.clone()),
          Me && "implicit" in ye && (b.implicit = !0),
          (b = b.transform(function (_) {
            return _.isSymbolNode && Ve(fe.placeholders, _.name)
              ? fe.placeholders[_.name].clone()
              : _;
          }));
      }
      return Q.repeat && b !== J && (b = Ee(b, Q, ce)), b;
    }
    function H(J, Q) {
      var ce = [],
        Ce,
        Ne,
        w = Z(J);
      if ($(J, Q))
        for (var b = 0; b < J.args.length; b++)
          (Ne = J.args.slice(0)),
            Ne.splice(b, 1),
            (Ce = Ne.length === 1 ? Ne[0] : w(Ne)),
            ce.push(w([J.args[b], Ce]));
      else
        for (var F = 1; F < J.args.length; F++) {
          var V = J.args[0];
          F > 1 && (V = w(J.args.slice(0, F))),
            (Ne = J.args.slice(F)),
            (Ce = Ne.length === 1 ? Ne[0] : w(Ne)),
            ce.push(w([V, Ce]));
        }
      return ce;
    }
    function we(J, Q) {
      var ce = { placeholders: {} };
      if (!J.placeholders && !Q.placeholders) return ce;
      if (J.placeholders) {
        if (!Q.placeholders) return J;
      } else return Q;
      for (var Ce in J.placeholders)
        if (
          Ve(J.placeholders, Ce) &&
          ((ce.placeholders[Ce] = J.placeholders[Ce]),
          Ve(Q.placeholders, Ce) && !Ue(J.placeholders[Ce], Q.placeholders[Ce]))
        )
          return null;
      for (var Ne in Q.placeholders)
        Ve(Q.placeholders, Ne) && (ce.placeholders[Ne] = Q.placeholders[Ne]);
      return ce;
    }
    function he(J, Q) {
      var ce = [];
      if (J.length === 0 || Q.length === 0) return ce;
      for (var Ce, Ne = 0; Ne < J.length; Ne++)
        for (var w = 0; w < Q.length; w++)
          (Ce = we(J[Ne], Q[w])), Ce && ce.push(Ce);
      return ce;
    }
    function _e(J) {
      if (J.length === 0) return J;
      for (
        var Q = J.reduce(he), ce = [], Ce = {}, Ne = 0;
        Ne < Q.length;
        Ne++
      ) {
        var w = JSON.stringify(Q[Ne]);
        Ce[w] || ((Ce[w] = !0), ce.push(Q[Ne]));
      }
      return ce;
    }
    function ge(J, Q, ce, Ce) {
      var Ne = [{ placeholders: {} }];
      if (
        (J instanceof N && Q instanceof N) ||
        (J instanceof E && Q instanceof E)
      ) {
        if (J instanceof N) {
          if (J.op !== Q.op || J.fn !== Q.fn) return [];
        } else if (J instanceof E && J.name !== Q.name) return [];
        if (
          (Q.args.length === 1 && J.args.length === 1) ||
          (!I(Q, ce) && Q.args.length === J.args.length) ||
          Ce
        ) {
          for (var w = [], b = 0; b < J.args.length; b++) {
            var F = ge(J.args[b], Q.args[b], ce);
            if (F.length === 0) break;
            w.push(F);
          }
          if (w.length !== J.args.length) {
            if (!$(Q, ce) || J.args.length === 1) return [];
            if (J.args.length > 2)
              throw new Error(
                "permuting >2 commutative non-associative rule arguments not yet implemented"
              );
            var V = ge(J.args[0], Q.args[1], ce);
            if (V.length === 0) return [];
            var j = ge(J.args[1], Q.args[0], ce);
            if (j.length === 0) return [];
            w = [V, j];
          }
          Ne = _e(w);
        } else if (Q.args.length >= 2 && J.args.length === 2) {
          for (var X = H(Q, ce), oe = [], ee = 0; ee < X.length; ee++) {
            var q = ge(J, X[ee], ce, !0);
            oe = oe.concat(q);
          }
          return oe;
        } else {
          if (J.args.length > 2)
            throw Error(
              "Unexpected non-binary associative function: " + J.toString()
            );
          return [];
        }
      } else if (J instanceof D) {
        if (J.name.length === 0)
          throw new Error("Symbol in rule has 0 length...!?");
        if (ve[J.name]) {
          if (J.name !== Q.name) return [];
        } else
          switch (
            J.name[1] >= "a" && J.name[1] <= "z"
              ? J.name.substring(0, 2)
              : J.name[0]
          ) {
            case "n":
            case "_p":
              Ne[0].placeholders[J.name] = Q;
              break;
            case "c":
            case "cl":
              if (Qe(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            case "v":
              if (!Qe(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            case "vl":
              if (Rt(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            case "cd":
              if (qh(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            case "vd":
              if (!qh(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            case "ce":
              if (No(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            case "ve":
              if (!No(Q)) Ne[0].placeholders[J.name] = Q;
              else return [];
              break;
            default:
              throw new Error("Invalid symbol in rule: " + J.name);
          }
      } else if (J instanceof y) {
        if (!l(J.value, Q.value)) return [];
      } else return [];
      return Ne;
    }
    function Ue(J, Q) {
      if (J instanceof y && Q instanceof y) {
        if (!l(J.value, Q.value)) return !1;
      } else if (J instanceof D && Q instanceof D) {
        if (J.name !== Q.name) return !1;
      } else if (
        (J instanceof N && Q instanceof N) ||
        (J instanceof E && Q instanceof E)
      ) {
        if (J instanceof N) {
          if (J.op !== Q.op || J.fn !== Q.fn) return !1;
        } else if (J instanceof E && J.name !== Q.name) return !1;
        if (J.args.length !== Q.args.length) return !1;
        for (var ce = 0; ce < J.args.length; ce++)
          if (!Ue(J.args[ce], Q.args[ce])) return !1;
      } else return !1;
      return !0;
    }
    return W;
  }),
  bT = "simplifyConstant",
  _T = [
    "typed",
    "config",
    "mathWithTransform",
    "matrix",
    "?fraction",
    "?bignumber",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "SymbolNode",
  ],
  wT = me(bT, _T, (n) => {
    var {
        typed: e,
        config: t,
        mathWithTransform: r,
        matrix: i,
        fraction: a,
        bignumber: s,
        AccessorNode: o,
        ArrayNode: c,
        ConstantNode: u,
        FunctionNode: l,
        IndexNode: f,
        ObjectNode: h,
        OperatorNode: d,
        SymbolNode: g,
      } = n,
      {
        isCommutative: x,
        isAssociative: m,
        allChildren: p,
        createMakeNodeFunction: S,
      } = dl({ FunctionNode: l, OperatorNode: d, SymbolNode: g }),
      v = e("simplifyConstant", {
        Node: (L) => T(G(L, {})),
        "Node, Object": function (C, k) {
          return T(G(C, k));
        },
      });
    function y(L) {
      return vs(L)
        ? L.valueOf()
        : L instanceof Array
        ? L.map(y)
        : tn(L)
        ? i(y(L.valueOf()))
        : L;
    }
    function E(L, C, k) {
      try {
        return r[L].apply(null, C);
      } catch {
        return (C = C.map(y)), A(r[L].apply(null, C), k);
      }
    }
    var M = e({
      Fraction: z,
      number: function (C) {
        return C < 0 ? D(new u(-C)) : new u(C);
      },
      BigNumber: function (C) {
        return C < 0 ? D(new u(-C)) : new u(C);
      },
      Complex: function (C) {
        throw new Error("Cannot convert Complex number to Node");
      },
      string: function (C) {
        return new u(C);
      },
      Matrix: function (C) {
        return new c(C.valueOf().map((k) => M(k)));
      },
    });
    function T(L) {
      return at(L) ? L : M(L);
    }
    function N(L, C) {
      var k = C && C.exactFractions !== !1;
      if (k && isFinite(L) && a) {
        var Z = a(L),
          ie =
            C && typeof C.fractionsLimit == "number" ? C.fractionsLimit : 1 / 0;
        if (Z.valueOf() === L && Z.n < ie && Z.d < ie) return Z;
      }
      return L;
    }
    var A = e({
      "string, Object": function (C, k) {
        if (t.number === "BigNumber") return s === void 0 && ll(), s(C);
        if (t.number === "Fraction") return a === void 0 && jg(), a(C);
        var Z = parseFloat(C);
        return N(Z, k);
      },
      "Fraction, Object": function (C, k) {
        return C;
      },
      "BigNumber, Object": function (C, k) {
        return C;
      },
      "number, Object": function (C, k) {
        return N(C, k);
      },
      "Complex, Object": function (C, k) {
        return C.im !== 0 ? C : N(C.re, k);
      },
      "Matrix, Object": function (C, k) {
        return i(N(C.valueOf()));
      },
      "Array, Object": function (C, k) {
        return C.map(N);
      },
    });
    function D(L) {
      return new d("-", "unaryMinus", [L]);
    }
    function z(L) {
      var C,
        k = L.s * L.n;
      return (
        k < 0 ? (C = new d("-", "unaryMinus", [new u(-k)])) : (C = new u(k)),
        L.d === 1 ? C : new d("/", "divide", [C, new u(L.d)])
      );
    }
    function $(L, C, k) {
      if (!pi(C)) return new o(T(L), T(C));
      if (pn(L) || tn(L)) {
        for (var Z = Array.from(C.dimensions); Z.length > 0; )
          if (Qe(Z[0]) && typeof Z[0].value != "string") {
            var ie = A(Z.shift().value, k);
            pn(L)
              ? (L = L.items[ie - 1])
              : ((L = L.valueOf()[ie - 1]), L instanceof Array && (L = i(L)));
          } else if (
            Z.length > 1 &&
            Qe(Z[1]) &&
            typeof Z[1].value != "string"
          ) {
            var ne = A(Z[1].value, k),
              Y = [],
              W = pn(L) ? L.items : L.valueOf();
            for (var te of W)
              if (pn(te)) Y.push(te.items[ne - 1]);
              else if (tn(L)) Y.push(te[ne - 1]);
              else break;
            if (Y.length === W.length)
              pn(L) ? (L = new c(Y)) : (L = i(Y)), Z.splice(1, 1);
            else break;
          } else break;
        return Z.length === C.dimensions.length
          ? new o(T(L), C)
          : Z.length > 0
          ? ((C = new f(Z)), new o(T(L), C))
          : L;
      }
      if (xs(L) && C.dimensions.length === 1 && Qe(C.dimensions[0])) {
        var ve = C.dimensions[0].value;
        return ve in L.properties ? L.properties[ve] : new u();
      }
      return new o(T(L), C);
    }
    function I(L, C, k, Z) {
      var ie = C.shift(),
        ne = C.reduce(
          (Y, W) => {
            if (!at(W)) {
              var te = Y.pop();
              if (at(te)) return [te, W];
              try {
                return Y.push(E(L, [te, W], Z)), Y;
              } catch {
                Y.push(te);
              }
            }
            Y.push(T(Y.pop()));
            var ve = Y.length === 1 ? Y[0] : k(Y);
            return [k([ve, T(W)])];
          },
          [ie]
        );
      return ne.length === 1 ? ne[0] : k([ne[0], M(ne[1])]);
    }
    function G(L, C) {
      switch (L.type) {
        case "SymbolNode":
          return L;
        case "ConstantNode":
          switch (typeof L.value) {
            case "number":
              return A(L.value, C);
            case "string":
              return L.value;
            default:
              if (!isNaN(L.value)) return A(L.value, C);
          }
          return L;
        case "FunctionNode":
          if (r[L.name] && r[L.name].rawArgs) return L;
          {
            var k = ["add", "multiply"];
            if (!k.includes(L.name)) {
              var Z = L.args.map((Ee) => G(Ee, C));
              if (!Z.some(at))
                try {
                  return E(L.name, Z, C);
                } catch {}
              if (L.name === "size" && Z.length === 1 && pn(Z[0])) {
                for (var ie = [], ne = Z[0]; pn(ne); )
                  ie.push(ne.items.length), (ne = ne.items[0]);
                return i(ie);
              }
              return new l(L.name, Z.map(T));
            }
          }
        case "OperatorNode": {
          var Y = L.fn.toString(),
            W,
            te,
            ve = S(L);
          if (Et(L) && L.isUnary())
            (W = [G(L.args[0], C)]),
              at(W[0]) ? (te = ve(W)) : (te = E(Y, W, C));
          else if (m(L, C.context))
            if (
              ((W = p(L, C.context)),
              (W = W.map((Ee) => G(Ee, C))),
              x(Y, C.context))
            ) {
              for (var be = [], Ae = [], Fe = 0; Fe < W.length; Fe++)
                at(W[Fe]) ? Ae.push(W[Fe]) : be.push(W[Fe]);
              be.length > 1
                ? ((te = I(Y, be, ve, C)),
                  Ae.unshift(te),
                  (te = I(Y, Ae, ve, C)))
                : (te = I(Y, W, ve, C));
            } else te = I(Y, W, ve, C);
          else (W = L.args.map((Ee) => G(Ee, C))), (te = I(Y, W, ve, C));
          return te;
        }
        case "ParenthesisNode":
          return G(L.content, C);
        case "AccessorNode":
          return $(G(L.object, C), G(L.index, C), C);
        case "ArrayNode": {
          var Pe = L.items.map((Ee) => G(Ee, C));
          return Pe.some(at) ? new c(Pe.map(T)) : i(Pe);
        }
        case "IndexNode":
          return new f(L.dimensions.map((Ee) => v(Ee, C)));
        case "ObjectNode": {
          var Te = {};
          for (var ze in L.properties) Te[ze] = v(L.properties[ze], C);
          return new h(Te);
        }
        case "AssignmentNode":
        case "BlockNode":
        case "FunctionAssignmentNode":
        case "RangeNode":
        case "ConditionalNode":
        default:
          throw new Error(
            "Unimplemented node type in simplifyConstant: ".concat(L.type)
          );
      }
    }
    return v;
  }),
  Fn = [
    { AssignmentNode: {}, FunctionAssignmentNode: {} },
    {
      ConditionalNode: {
        latexLeftParens: !1,
        latexRightParens: !1,
        latexParens: !1,
      },
    },
    {
      "OperatorNode:or": {
        op: "or",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:xor": {
        op: "xor",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:and": {
        op: "and",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:bitOr": {
        op: "|",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:bitXor": {
        op: "^|",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:bitAnd": {
        op: "&",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:equal": {
        op: "==",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:unequal": {
        op: "!=",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:smaller": {
        op: "<",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:larger": {
        op: ">",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:smallerEq": {
        op: "<=",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:largerEq": {
        op: ">=",
        associativity: "left",
        associativeWith: [],
      },
      RelationalNode: { associativity: "left", associativeWith: [] },
    },
    {
      "OperatorNode:leftShift": {
        op: "<<",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:rightArithShift": {
        op: ">>",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:rightLogShift": {
        op: ">>>",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:to": {
        op: "to",
        associativity: "left",
        associativeWith: [],
      },
    },
    { RangeNode: {} },
    {
      "OperatorNode:add": {
        op: "+",
        associativity: "left",
        associativeWith: ["OperatorNode:add", "OperatorNode:subtract"],
      },
      "OperatorNode:subtract": {
        op: "-",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:multiply": {
        op: "*",
        associativity: "left",
        associativeWith: [
          "OperatorNode:multiply",
          "OperatorNode:divide",
          "Operator:dotMultiply",
          "Operator:dotDivide",
        ],
      },
      "OperatorNode:divide": {
        op: "/",
        associativity: "left",
        associativeWith: [],
        latexLeftParens: !1,
        latexRightParens: !1,
        latexParens: !1,
      },
      "OperatorNode:dotMultiply": {
        op: ".*",
        associativity: "left",
        associativeWith: [
          "OperatorNode:multiply",
          "OperatorNode:divide",
          "OperatorNode:dotMultiply",
          "OperatorNode:doDivide",
        ],
      },
      "OperatorNode:dotDivide": {
        op: "./",
        associativity: "left",
        associativeWith: [],
      },
      "OperatorNode:mod": {
        op: "mod",
        associativity: "left",
        associativeWith: [],
      },
    },
    {
      "OperatorNode:multiply": {
        associativity: "left",
        associativeWith: [
          "OperatorNode:multiply",
          "OperatorNode:divide",
          "Operator:dotMultiply",
          "Operator:dotDivide",
        ],
      },
    },
    {
      "OperatorNode:unaryPlus": { op: "+", associativity: "right" },
      "OperatorNode:unaryMinus": { op: "-", associativity: "right" },
      "OperatorNode:bitNot": { op: "~", associativity: "right" },
      "OperatorNode:not": { op: "not", associativity: "right" },
    },
    {
      "OperatorNode:pow": {
        op: "^",
        associativity: "right",
        associativeWith: [],
        latexRightParens: !1,
      },
      "OperatorNode:dotPow": {
        op: ".^",
        associativity: "right",
        associativeWith: [],
      },
    },
    { "OperatorNode:factorial": { op: "!", associativity: "left" } },
    { "OperatorNode:ctranspose": { op: "'", associativity: "left" } },
  ];
function to(n, e) {
  if (!e || e !== "auto") return n;
  for (var t = n; Wn(t); ) t = t.content;
  return t;
}
function ot(n, e, t, r) {
  var i = n;
  e !== "keep" && (i = n.getContent());
  for (var a = i.getIdentifier(), s = null, o = 0; o < Fn.length; o++)
    if (a in Fn[o]) {
      s = o;
      break;
    }
  if (a === "OperatorNode:multiply" && i.implicit && t !== "show") {
    var c = to(i.args[0], e);
    !(
      Qe(c) &&
      r &&
      r.getIdentifier() === "OperatorNode:divide" &&
      bc(to(r.args[0], e))
    ) &&
      !(
        c.getIdentifier() === "OperatorNode:divide" &&
        bc(to(c.args[0], e)) &&
        Qe(to(c.args[1]))
      ) &&
      (s += 1);
  }
  return s;
}
function Oa(n, e) {
  var t = n;
  e !== "keep" && (t = n.getContent());
  var r = t.getIdentifier(),
    i = ot(t, e);
  if (i === null) return null;
  var a = Fn[i][r];
  if (Ve(a, "associativity")) {
    if (a.associativity === "left") return "left";
    if (a.associativity === "right") return "right";
    throw Error(
      "'" + r + "' has the invalid associativity '" + a.associativity + "'."
    );
  }
  return null;
}
function ac(n, e, t) {
  var r = t !== "keep" ? n.getContent() : n,
    i = t !== "keep" ? n.getContent() : e,
    a = r.getIdentifier(),
    s = i.getIdentifier(),
    o = ot(r, t);
  if (o === null) return null;
  var c = Fn[o][a];
  if (Ve(c, "associativeWith") && c.associativeWith instanceof Array) {
    for (var u = 0; u < c.associativeWith.length; u++)
      if (c.associativeWith[u] === s) return !0;
    return !1;
  }
  return null;
}
function ET(n) {
  var e = "OperatorNode:" + n;
  for (var t of Fn) if (e in t) return t[e].op;
  return null;
}
var jh = "simplifyCore",
  ST = [
    "typed",
    "parse",
    "equal",
    "isZero",
    "add",
    "subtract",
    "multiply",
    "divide",
    "pow",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "ParenthesisNode",
    "SymbolNode",
  ],
  MT = me(jh, ST, (n) => {
    var {
        typed: e,
        parse: t,
        equal: r,
        isZero: i,
        add: a,
        subtract: s,
        multiply: o,
        divide: c,
        pow: u,
        AccessorNode: l,
        ArrayNode: f,
        ConstantNode: h,
        FunctionNode: d,
        IndexNode: g,
        ObjectNode: x,
        OperatorNode: m,
        ParenthesisNode: p,
        SymbolNode: S,
      } = n,
      v = new h(0),
      y = new h(1),
      E = new h(!0),
      M = new h(!1);
    function T(z) {
      return Et(z) && ["and", "not", "or"].includes(z.op);
    }
    var { hasProperty: N, isCommutative: A } = dl({
      FunctionNode: d,
      OperatorNode: m,
      SymbolNode: S,
    });
    function D(z) {
      var $ =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        I = $ ? $.context : void 0;
      if (N(z, "trivial", I)) {
        if (fr(z) && z.args.length === 1) return D(z.args[0], $);
        var G = !1,
          L = 0;
        if (
          (z.forEach((Ae) => {
            ++L, L === 1 && (G = D(Ae, $));
          }),
          L === 1)
        )
          return G;
      }
      var C = z;
      if (fr(C)) {
        var k = ET(C.name);
        if (k) {
          if (C.args.length > 2 && N(C, "associative", I))
            for (; C.args.length > 2; ) {
              var Z = C.args.pop(),
                ie = C.args.pop();
              C.args.push(new m(k, C.name, [Z, ie]));
            }
          C = new m(k, C.name, C.args);
        } else
          return new d(
            D(C.fn),
            C.args.map((Ae) => D(Ae, $))
          );
      }
      if (Et(C) && C.isUnary()) {
        var ne = D(C.args[0], $);
        if (
          (C.op === "~" && Et(ne) && ne.isUnary() && ne.op === "~") ||
          (C.op === "not" &&
            Et(ne) &&
            ne.isUnary() &&
            ne.op === "not" &&
            T(ne.args[0]))
        )
          return ne.args[0];
        var Y = !0;
        if (
          C.op === "-" &&
          Et(ne) &&
          (ne.isBinary() &&
            ne.fn === "subtract" &&
            ((C = new m("-", "subtract", [ne.args[1], ne.args[0]])), (Y = !1)),
          ne.isUnary() && ne.op === "-")
        )
          return ne.args[0];
        if (Y) return new m(C.op, C.fn, [ne]);
      }
      if (Et(C) && C.isBinary()) {
        var W = D(C.args[0], $),
          te = D(C.args[1], $);
        if (C.op === "+") {
          if (Qe(W) && i(W.value)) return te;
          if (Qe(te) && i(te.value)) return W;
          Et(te) &&
            te.isUnary() &&
            te.op === "-" &&
            ((te = te.args[0]), (C = new m("-", "subtract", [W, te])));
        }
        if (C.op === "-")
          return Et(te) && te.isUnary() && te.op === "-"
            ? D(new m("+", "add", [W, te.args[0]]), $)
            : Qe(W) && i(W.value)
            ? D(new m("-", "unaryMinus", [te]))
            : Qe(te) && i(te.value)
            ? W
            : new m(C.op, C.fn, [W, te]);
        if (C.op === "*") {
          if (Qe(W)) {
            if (i(W.value)) return v;
            if (r(W.value, 1)) return te;
          }
          if (Qe(te)) {
            if (i(te.value)) return v;
            if (r(te.value, 1)) return W;
            if (A(C, I)) return new m(C.op, C.fn, [te, W], C.implicit);
          }
          return new m(C.op, C.fn, [W, te], C.implicit);
        }
        if (C.op === "/")
          return Qe(W) && i(W.value)
            ? v
            : Qe(te) && r(te.value, 1)
            ? W
            : new m(C.op, C.fn, [W, te]);
        if (C.op === "^" && Qe(te)) {
          if (i(te.value)) return y;
          if (r(te.value, 1)) return W;
        }
        if (C.op === "and") {
          if (Qe(W))
            if (W.value) {
              if (T(te)) return te;
              if (Qe(te)) return te.value ? E : M;
            } else return M;
          if (Qe(te))
            if (te.value) {
              if (T(W)) return W;
            } else return M;
        }
        if (C.op === "or") {
          if (Qe(W)) {
            if (W.value) return E;
            if (T(te)) return te;
          }
          if (Qe(te)) {
            if (te.value) return E;
            if (T(W)) return W;
          }
        }
        return new m(C.op, C.fn, [W, te]);
      }
      if (Et(C))
        return new m(
          C.op,
          C.fn,
          C.args.map((Ae) => D(Ae, $))
        );
      if (pn(C)) return new f(C.items.map((Ae) => D(Ae, $)));
      if (Pr(C)) return new l(D(C.object, $), D(C.index, $));
      if (pi(C)) return new g(C.dimensions.map((Ae) => D(Ae, $)));
      if (xs(C)) {
        var ve = {};
        for (var be in C.properties) ve[be] = D(C.properties[be], $);
        return new x(ve);
      }
      return C;
    }
    return e(jh, { Node: D, "Node,Object": D });
  }),
  Xh = "derivative",
  AT = [
    "typed",
    "config",
    "parse",
    "simplify",
    "equal",
    "isZero",
    "numeric",
    "ConstantNode",
    "FunctionNode",
    "OperatorNode",
    "ParenthesisNode",
    "SymbolNode",
  ],
  DT = me(Xh, AT, (n) => {
    var {
      typed: e,
      config: t,
      parse: r,
      simplify: i,
      equal: a,
      isZero: s,
      numeric: o,
      ConstantNode: c,
      FunctionNode: u,
      OperatorNode: l,
      ParenthesisNode: f,
      SymbolNode: h,
    } = n;
    function d(v, y) {
      var E =
          arguments.length > 2 && arguments[2] !== void 0
            ? arguments[2]
            : { simplify: !0 },
        M = {};
      m(M, v, y.name);
      var T = p(v, M);
      return E.simplify ? i(T) : T;
    }
    e.addConversion({ from: "identifier", to: "SymbolNode", convert: r });
    var g = e(Xh, { "Node, SymbolNode": d, "Node, SymbolNode, Object": d });
    e.removeConversion({ from: "identifier", to: "SymbolNode", convert: r }),
      (g._simplify = !0),
      (g.toTex = function (v) {
        return x.apply(null, v.args);
      });
    var x = e("_derivTex", {
        "Node, SymbolNode": function (y, E) {
          return Qe(y) && Vt(y.value) === "string"
            ? x(r(y.value).toString(), E.toString(), 1)
            : x(y.toTex(), E.toString(), 1);
        },
        "Node, ConstantNode": function (y, E) {
          if (Vt(E.value) === "string") return x(y, r(E.value));
          throw new Error(
            "The second parameter to 'derivative' is a non-string constant"
          );
        },
        "Node, SymbolNode, ConstantNode": function (y, E, M) {
          return x(y.toString(), E.name, M.value);
        },
        "string, string, number": function (y, E, M) {
          var T;
          return (
            M === 1
              ? (T = "{d\\over d" + E + "}")
              : (T = "{d^{" + M + "}\\over d" + E + "^{" + M + "}}"),
            T + "\\left[".concat(y, "\\right]")
          );
        },
      }),
      m = e("constTag", {
        "Object, ConstantNode, string": function (y, E) {
          return (y[E] = !0), !0;
        },
        "Object, SymbolNode, string": function (y, E, M) {
          return E.name !== M ? ((y[E] = !0), !0) : !1;
        },
        "Object, ParenthesisNode, string": function (y, E, M) {
          return m(y, E.content, M);
        },
        "Object, FunctionAssignmentNode, string": function (y, E, M) {
          return E.params.includes(M) ? m(y, E.expr, M) : ((y[E] = !0), !0);
        },
        "Object, FunctionNode | OperatorNode, string": function (y, E, M) {
          if (E.args.length > 0) {
            for (var T = m(y, E.args[0], M), N = 1; N < E.args.length; ++N)
              T = m(y, E.args[N], M) && T;
            if (T) return (y[E] = !0), !0;
          }
          return !1;
        },
      }),
      p = e("_derivative", {
        "ConstantNode, Object": function (y) {
          return S(0);
        },
        "SymbolNode, Object": function (y, E) {
          return E[y] !== void 0 ? S(0) : S(1);
        },
        "ParenthesisNode, Object": function (y, E) {
          return new f(p(y.content, E));
        },
        "FunctionAssignmentNode, Object": function (y, E) {
          return E[y] !== void 0 ? S(0) : p(y.expr, E);
        },
        "FunctionNode, Object": function (y, E) {
          if (E[y] !== void 0) return S(0);
          var M = y.args[0],
            T,
            N = !1,
            A = !1,
            D;
          switch (y.name) {
            case "cbrt":
              (N = !0),
                (D = new l("*", "multiply", [
                  S(3),
                  new l("^", "pow", [M, new l("/", "divide", [S(2), S(3)])]),
                ]));
              break;
            case "sqrt":
            case "nthRoot":
              if (y.args.length === 1)
                (N = !0),
                  (D = new l("*", "multiply", [S(2), new u("sqrt", [M])]));
              else if (y.args.length === 2)
                return (
                  (T = new l("/", "divide", [S(1), y.args[1]])),
                  (E[T] = E[y.args[1]]),
                  p(new l("^", "pow", [M, T]), E)
                );
              break;
            case "log10":
              T = S(10);
            case "log":
              if (!T && y.args.length === 1) (D = M.clone()), (N = !0);
              else if (
                (y.args.length === 1 && T) ||
                (y.args.length === 2 && E[y.args[1]] !== void 0)
              )
                (D = new l("*", "multiply", [
                  M.clone(),
                  new u("log", [T || y.args[1]]),
                ])),
                  (N = !0);
              else if (y.args.length === 2)
                return p(
                  new l("/", "divide", [
                    new u("log", [M]),
                    new u("log", [y.args[1]]),
                  ]),
                  E
                );
              break;
            case "pow":
              if (y.args.length === 2)
                return (
                  (E[T] = E[y.args[1]]), p(new l("^", "pow", [M, y.args[1]]), E)
                );
              break;
            case "exp":
              D = new u("exp", [M.clone()]);
              break;
            case "sin":
              D = new u("cos", [M.clone()]);
              break;
            case "cos":
              D = new l("-", "unaryMinus", [new u("sin", [M.clone()])]);
              break;
            case "tan":
              D = new l("^", "pow", [new u("sec", [M.clone()]), S(2)]);
              break;
            case "sec":
              D = new l("*", "multiply", [y, new u("tan", [M.clone()])]);
              break;
            case "csc":
              (A = !0),
                (D = new l("*", "multiply", [y, new u("cot", [M.clone()])]));
              break;
            case "cot":
              (A = !0),
                (D = new l("^", "pow", [new u("csc", [M.clone()]), S(2)]));
              break;
            case "asin":
              (N = !0),
                (D = new u("sqrt", [
                  new l("-", "subtract", [
                    S(1),
                    new l("^", "pow", [M.clone(), S(2)]),
                  ]),
                ]));
              break;
            case "acos":
              (N = !0),
                (A = !0),
                (D = new u("sqrt", [
                  new l("-", "subtract", [
                    S(1),
                    new l("^", "pow", [M.clone(), S(2)]),
                  ]),
                ]));
              break;
            case "atan":
              (N = !0),
                (D = new l("+", "add", [
                  new l("^", "pow", [M.clone(), S(2)]),
                  S(1),
                ]));
              break;
            case "asec":
              (N = !0),
                (D = new l("*", "multiply", [
                  new u("abs", [M.clone()]),
                  new u("sqrt", [
                    new l("-", "subtract", [
                      new l("^", "pow", [M.clone(), S(2)]),
                      S(1),
                    ]),
                  ]),
                ]));
              break;
            case "acsc":
              (N = !0),
                (A = !0),
                (D = new l("*", "multiply", [
                  new u("abs", [M.clone()]),
                  new u("sqrt", [
                    new l("-", "subtract", [
                      new l("^", "pow", [M.clone(), S(2)]),
                      S(1),
                    ]),
                  ]),
                ]));
              break;
            case "acot":
              (N = !0),
                (A = !0),
                (D = new l("+", "add", [
                  new l("^", "pow", [M.clone(), S(2)]),
                  S(1),
                ]));
              break;
            case "sinh":
              D = new u("cosh", [M.clone()]);
              break;
            case "cosh":
              D = new u("sinh", [M.clone()]);
              break;
            case "tanh":
              D = new l("^", "pow", [new u("sech", [M.clone()]), S(2)]);
              break;
            case "sech":
              (A = !0),
                (D = new l("*", "multiply", [y, new u("tanh", [M.clone()])]));
              break;
            case "csch":
              (A = !0),
                (D = new l("*", "multiply", [y, new u("coth", [M.clone()])]));
              break;
            case "coth":
              (A = !0),
                (D = new l("^", "pow", [new u("csch", [M.clone()]), S(2)]));
              break;
            case "asinh":
              (N = !0),
                (D = new u("sqrt", [
                  new l("+", "add", [
                    new l("^", "pow", [M.clone(), S(2)]),
                    S(1),
                  ]),
                ]));
              break;
            case "acosh":
              (N = !0),
                (D = new u("sqrt", [
                  new l("-", "subtract", [
                    new l("^", "pow", [M.clone(), S(2)]),
                    S(1),
                  ]),
                ]));
              break;
            case "atanh":
              (N = !0),
                (D = new l("-", "subtract", [
                  S(1),
                  new l("^", "pow", [M.clone(), S(2)]),
                ]));
              break;
            case "asech":
              (N = !0),
                (A = !0),
                (D = new l("*", "multiply", [
                  M.clone(),
                  new u("sqrt", [
                    new l("-", "subtract", [
                      S(1),
                      new l("^", "pow", [M.clone(), S(2)]),
                    ]),
                  ]),
                ]));
              break;
            case "acsch":
              (N = !0),
                (A = !0),
                (D = new l("*", "multiply", [
                  new u("abs", [M.clone()]),
                  new u("sqrt", [
                    new l("+", "add", [
                      new l("^", "pow", [M.clone(), S(2)]),
                      S(1),
                    ]),
                  ]),
                ]));
              break;
            case "acoth":
              (N = !0),
                (A = !0),
                (D = new l("-", "subtract", [
                  S(1),
                  new l("^", "pow", [M.clone(), S(2)]),
                ]));
              break;
            case "abs":
              D = new l("/", "divide", [
                new u(new h("abs"), [M.clone()]),
                M.clone(),
              ]);
              break;
            case "gamma":
            default:
              throw new Error(
                'Cannot process function "' +
                  y.name +
                  '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported'
              );
          }
          var z, $;
          N ? ((z = "/"), ($ = "divide")) : ((z = "*"), ($ = "multiply"));
          var I = p(M, E);
          return A && (I = new l("-", "unaryMinus", [I])), new l(z, $, [I, D]);
        },
        "OperatorNode, Object": function (y, E) {
          if (E[y] !== void 0) return S(0);
          if (y.op === "+")
            return new l(
              y.op,
              y.fn,
              y.args.map(function (L) {
                return p(L, E);
              })
            );
          if (y.op === "-") {
            if (y.isUnary()) return new l(y.op, y.fn, [p(y.args[0], E)]);
            if (y.isBinary())
              return new l(y.op, y.fn, [p(y.args[0], E), p(y.args[1], E)]);
          }
          if (y.op === "*") {
            var M = y.args.filter(function (L) {
              return E[L] !== void 0;
            });
            if (M.length > 0) {
              var T = y.args.filter(function (L) {
                  return E[L] === void 0;
                }),
                N = T.length === 1 ? T[0] : new l("*", "multiply", T),
                A = M.concat(p(N, E));
              return new l("*", "multiply", A);
            }
            return new l(
              "+",
              "add",
              y.args.map(function (L) {
                return new l(
                  "*",
                  "multiply",
                  y.args.map(function (C) {
                    return C === L ? p(C, E) : C.clone();
                  })
                );
              })
            );
          }
          if (y.op === "/" && y.isBinary()) {
            var D = y.args[0],
              z = y.args[1];
            return E[z] !== void 0
              ? new l("/", "divide", [p(D, E), z])
              : E[D] !== void 0
              ? new l("*", "multiply", [
                  new l("-", "unaryMinus", [D]),
                  new l("/", "divide", [
                    p(z, E),
                    new l("^", "pow", [z.clone(), S(2)]),
                  ]),
                ])
              : new l("/", "divide", [
                  new l("-", "subtract", [
                    new l("*", "multiply", [p(D, E), z.clone()]),
                    new l("*", "multiply", [D.clone(), p(z, E)]),
                  ]),
                  new l("^", "pow", [z.clone(), S(2)]),
                ]);
          }
          if (y.op === "^" && y.isBinary()) {
            var $ = y.args[0],
              I = y.args[1];
            if (E[$] !== void 0)
              return Qe($) && (s($.value) || a($.value, 1))
                ? S(0)
                : new l("*", "multiply", [
                    y,
                    new l("*", "multiply", [
                      new u("log", [$.clone()]),
                      p(I.clone(), E),
                    ]),
                  ]);
            if (E[I] !== void 0) {
              if (Qe(I)) {
                if (s(I.value)) return S(0);
                if (a(I.value, 1)) return p($, E);
              }
              var G = new l("^", "pow", [
                $.clone(),
                new l("-", "subtract", [I, S(1)]),
              ]);
              return new l("*", "multiply", [
                I.clone(),
                new l("*", "multiply", [p($, E), G]),
              ]);
            }
            return new l("*", "multiply", [
              new l("^", "pow", [$.clone(), I.clone()]),
              new l("+", "add", [
                new l("*", "multiply", [
                  p($, E),
                  new l("/", "divide", [I.clone(), $.clone()]),
                ]),
                new l("*", "multiply", [p(I, E), new u("log", [$.clone()])]),
              ]),
            ]);
          }
          throw new Error(
            'Cannot process operator "' +
              y.op +
              '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported'
          );
        },
      });
    function S(v, y) {
      return new c(o(v, y || t.number));
    }
    return g;
  }),
  Yh = "rationalize",
  TT = [
    "config",
    "typed",
    "equal",
    "isZero",
    "add",
    "subtract",
    "multiply",
    "divide",
    "pow",
    "parse",
    "simplifyConstant",
    "simplifyCore",
    "simplify",
    "?bignumber",
    "?fraction",
    "mathWithTransform",
    "matrix",
    "AccessorNode",
    "ArrayNode",
    "ConstantNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "SymbolNode",
    "ParenthesisNode",
  ],
  CT = me(Yh, TT, (n) => {
    var {
      config: e,
      typed: t,
      equal: r,
      isZero: i,
      add: a,
      subtract: s,
      multiply: o,
      divide: c,
      pow: u,
      parse: l,
      simplifyConstant: f,
      simplifyCore: h,
      simplify: d,
      fraction: g,
      bignumber: x,
      mathWithTransform: m,
      matrix: p,
      AccessorNode: S,
      ArrayNode: v,
      ConstantNode: y,
      FunctionNode: E,
      IndexNode: M,
      ObjectNode: T,
      OperatorNode: N,
      SymbolNode: A,
      ParenthesisNode: D,
    } = n;
    function z(C) {
      var k =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        Z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        ie = I(),
        ne = $(C, k, !0, ie.firstRules),
        Y = ne.variables.length,
        W = { exactFractions: !1 },
        te = { exactFractions: !0 };
      if (((C = ne.expression), Y >= 1)) {
        C = G(C);
        var ve,
          be,
          Ae = !0,
          Fe = !1;
        C = d(C, ie.firstRules, {}, W);
        for (
          var Pe;
          (be = Ae ? ie.distrDivRules : ie.sucDivRules),
            (C = d(C, be, {}, te)),
            (Ae = !Ae),
            (Pe = C.toString()),
            Pe !== ve;

        )
          (Fe = !0), (ve = Pe);
        Fe && (C = d(C, ie.firstRulesAgain, {}, W)),
          (C = d(C, ie.finalRules, {}, W));
      }
      var Te = [],
        ze = {};
      return (
        C.type === "OperatorNode" && C.isBinary() && C.op === "/"
          ? (Y === 1 &&
              ((C.args[0] = L(C.args[0], Te)), (C.args[1] = L(C.args[1]))),
            Z && ((ze.numerator = C.args[0]), (ze.denominator = C.args[1])))
          : (Y === 1 && (C = L(C, Te)),
            Z && ((ze.numerator = C), (ze.denominator = null))),
        Z
          ? ((ze.coefficients = Te),
            (ze.variables = ne.variables),
            (ze.expression = C),
            ze)
          : C
      );
    }
    return t(Yh, {
      Node: z,
      "Node, boolean": (C, k) => z(C, {}, k),
      "Node, Object": z,
      "Node, Object, boolean": z,
    });
    function $(C, k, Z, ie) {
      var ne = [],
        Y = d(C, ie, k, { exactFractions: !1 });
      Z = !!Z;
      var W = "+-*" + (Z ? "/" : "");
      ve(Y);
      var te = {};
      return (te.expression = Y), (te.variables = ne), te;
      function ve(be) {
        var Ae = be.type;
        if (Ae === "FunctionNode")
          throw new Error("There is an unsolved function call");
        if (Ae === "OperatorNode")
          if (be.op === "^") {
            if (
              be.args[1].type !== "ConstantNode" ||
              !rt(parseFloat(be.args[1].value))
            )
              throw new Error("There is a non-integer exponent");
            ve(be.args[0]);
          } else {
            if (!W.includes(be.op))
              throw new Error(
                "Operator " + be.op + " invalid in polynomial expression"
              );
            for (var Fe = 0; Fe < be.args.length; Fe++) ve(be.args[Fe]);
          }
        else if (Ae === "SymbolNode") {
          var Pe = be.name,
            Te = ne.indexOf(Pe);
          Te === -1 && ne.push(Pe);
        } else if (Ae === "ParenthesisNode") ve(be.content);
        else if (Ae !== "ConstantNode")
          throw new Error(
            "type " + Ae + " is not allowed in polynomial expression"
          );
      }
    }
    function I() {
      var C = [
          h,
          { l: "n+n", r: "2*n" },
          { l: "n+-n", r: "0" },
          f,
          { l: "n*(n1^-1)", r: "n/n1" },
          { l: "n*n1^-n2", r: "n/n1^n2" },
          { l: "n1^-1", r: "1/n1" },
          { l: "n*(n1/n2)", r: "(n*n1)/n2" },
          { l: "1*n", r: "n" },
        ],
        k = [
          { l: "(-n1)/(-n2)", r: "n1/n2" },
          { l: "(-n1)*(-n2)", r: "n1*n2" },
          { l: "n1--n2", r: "n1+n2" },
          { l: "n1-n2", r: "n1+(-n2)" },
          { l: "(n1+n2)*n3", r: "(n1*n3 + n2*n3)" },
          { l: "n1*(n2+n3)", r: "(n1*n2+n1*n3)" },
          { l: "c1*n + c2*n", r: "(c1+c2)*n" },
          { l: "c1*n + n", r: "(c1+1)*n" },
          { l: "c1*n - c2*n", r: "(c1-c2)*n" },
          { l: "c1*n - n", r: "(c1-1)*n" },
          { l: "v/c", r: "(1/c)*v" },
          { l: "v/-c", r: "-(1/c)*v" },
          { l: "-v*-c", r: "c*v" },
          { l: "-v*c", r: "-c*v" },
          { l: "v*-c", r: "-c*v" },
          { l: "v*c", r: "c*v" },
          { l: "-(-n1*n2)", r: "(n1*n2)" },
          { l: "-(n1*n2)", r: "(-n1*n2)" },
          { l: "-(-n1+n2)", r: "(n1-n2)" },
          { l: "-(n1+n2)", r: "(-n1-n2)" },
          { l: "(n1^n2)^n3", r: "(n1^(n2*n3))" },
          { l: "-(-n1/n2)", r: "(n1/n2)" },
          { l: "-(n1/n2)", r: "(-n1/n2)" },
        ],
        Z = [
          { l: "(n1/n2 + n3/n4)", r: "((n1*n4 + n3*n2)/(n2*n4))" },
          { l: "(n1/n2 + n3)", r: "((n1 + n3*n2)/n2)" },
          { l: "(n1 + n2/n3)", r: "((n1*n3 + n2)/n3)" },
        ],
        ie = [
          { l: "(n1/(n2/n3))", r: "((n1*n3)/n2)" },
          { l: "(n1/n2/n3)", r: "(n1/(n2*n3))" },
        ],
        ne = {};
      return (
        (ne.firstRules = C.concat(k, ie)),
        (ne.distrDivRules = Z),
        (ne.sucDivRules = ie),
        (ne.firstRulesAgain = C.concat(k)),
        (ne.finalRules = [
          h,
          { l: "n*-n", r: "-n^2" },
          { l: "n*n", r: "n^2" },
          f,
          { l: "n*-n^n1", r: "-n^(n1+1)" },
          { l: "n*n^n1", r: "n^(n1+1)" },
          { l: "n^n1*-n^n2", r: "-n^(n1+n2)" },
          { l: "n^n1*n^n2", r: "n^(n1+n2)" },
          { l: "n^n1*-n", r: "-n^(n1+1)" },
          { l: "n^n1*n", r: "n^(n1+1)" },
          { l: "n^n1/-n", r: "-n^(n1-1)" },
          { l: "n^n1/n", r: "n^(n1-1)" },
          { l: "n/-n^n1", r: "-n^(1-n1)" },
          { l: "n/n^n1", r: "n^(1-n1)" },
          { l: "n^n1/-n^n2", r: "n^(n1-n2)" },
          { l: "n^n1/n^n2", r: "n^(n1-n2)" },
          { l: "n1+(-n2*n3)", r: "n1-n2*n3" },
          { l: "v*(-c)", r: "-c*v" },
          { l: "n1+-n2", r: "n1-n2" },
          { l: "v*c", r: "c*v" },
          { l: "(n1^n2)^n3", r: "(n1^(n2*n3))" },
        ]),
        ne
      );
    }
    function G(C, k, Z) {
      var ie = C.type,
        ne = arguments.length > 1;
      if (ie === "OperatorNode" && C.isBinary()) {
        var Y = !1,
          W;
        if (
          (C.op === "^" &&
            (C.args[0].type === "ParenthesisNode" ||
              C.args[0].type === "OperatorNode") &&
            C.args[1].type === "ConstantNode" &&
            ((W = parseFloat(C.args[1].value)), (Y = W >= 2 && rt(W))),
          Y)
        ) {
          if (W > 2) {
            var te = C.args[0],
              ve = new N("^", "pow", [C.args[0].cloneDeep(), new y(W - 1)]);
            C = new N("*", "multiply", [te, ve]);
          } else C = new N("*", "multiply", [C.args[0], C.args[0].cloneDeep()]);
          ne && (Z === "content" ? (k.content = C) : (k.args[Z] = C));
        }
      }
      if (ie === "ParenthesisNode") G(C.content, C, "content");
      else if (ie !== "ConstantNode" && ie !== "SymbolNode")
        for (var be = 0; be < C.args.length; be++) G(C.args[be], C, be);
      if (!ne) return C;
    }
    function L(C, k) {
      k === void 0 && (k = []), (k[0] = 0);
      var Z = {};
      (Z.cte = 1), (Z.oper = "+"), (Z.fire = "");
      var ie = 0,
        ne = "";
      Pe(C, null, Z), (ie = k.length - 1);
      for (var Y = !0, W, te = ie; te >= 0; te--)
        if (k[te] !== 0) {
          var ve = new y(Y ? k[te] : Math.abs(k[te])),
            be = k[te] < 0 ? "-" : "+";
          if (te > 0) {
            var Ae = new A(ne);
            if (te > 1) {
              var Fe = new y(te);
              Ae = new N("^", "pow", [Ae, Fe]);
            }
            k[te] === -1 && Y
              ? (ve = new N("-", "unaryMinus", [Ae]))
              : Math.abs(k[te]) === 1
              ? (ve = Ae)
              : (ve = new N("*", "multiply", [ve, Ae]));
          }
          Y
            ? (W = ve)
            : be === "+"
            ? (W = new N("+", "add", [W, ve]))
            : (W = new N("-", "subtract", [W, ve])),
            (Y = !1);
        }
      if (Y) return new y(0);
      return W;
      function Pe(Te, ze, Ee) {
        var H = Te.type;
        if (H === "FunctionNode")
          throw new Error("There is an unsolved function call");
        if (H === "OperatorNode") {
          if (!"+-*^".includes(Te.op))
            throw new Error("Operator " + Te.op + " invalid");
          if (ze !== null) {
            if (
              (Te.fn === "unaryMinus" || Te.fn === "pow") &&
              ze.fn !== "add" &&
              ze.fn !== "subtract" &&
              ze.fn !== "multiply"
            )
              throw new Error("Invalid " + Te.op + " placing");
            if (
              (Te.fn === "subtract" ||
                Te.fn === "add" ||
                Te.fn === "multiply") &&
              ze.fn !== "add" &&
              ze.fn !== "subtract"
            )
              throw new Error("Invalid " + Te.op + " placing");
            if (
              (Te.fn === "subtract" ||
                Te.fn === "add" ||
                Te.fn === "unaryMinus") &&
              Ee.noFil !== 0
            )
              throw new Error("Invalid " + Te.op + " placing");
          }
          (Te.op === "^" || Te.op === "*") && (Ee.fire = Te.op);
          for (var we = 0; we < Te.args.length; we++)
            Te.fn === "unaryMinus" && (Ee.oper = "-"),
              (Te.op === "+" || Te.fn === "subtract") &&
                ((Ee.fire = ""),
                (Ee.cte = 1),
                (Ee.oper = we === 0 ? "+" : Te.op)),
              (Ee.noFil = we),
              Pe(Te.args[we], Te, Ee);
        } else if (H === "SymbolNode") {
          if (Te.name !== ne && ne !== "")
            throw new Error("There is more than one variable");
          if (((ne = Te.name), ze === null)) {
            k[1] = 1;
            return;
          }
          if (ze.op === "^" && Ee.noFil !== 0)
            throw new Error(
              "In power the variable should be the first parameter"
            );
          if (ze.op === "*" && Ee.noFil !== 1)
            throw new Error(
              "In multiply the variable should be the second parameter"
            );
          (Ee.fire === "" || Ee.fire === "*") &&
            (ie < 1 && (k[1] = 0),
            (k[1] += Ee.cte * (Ee.oper === "+" ? 1 : -1)),
            (ie = Math.max(1, ie)));
        } else if (H === "ConstantNode") {
          var he = parseFloat(Te.value);
          if (ze === null) {
            k[0] = he;
            return;
          }
          if (ze.op === "^") {
            if (Ee.noFil !== 1) throw new Error("Constant cannot be powered");
            if (!rt(he) || he <= 0)
              throw new Error("Non-integer exponent is not allowed");
            for (var _e = ie + 1; _e < he; _e++) k[_e] = 0;
            he > ie && (k[he] = 0),
              (k[he] += Ee.cte * (Ee.oper === "+" ? 1 : -1)),
              (ie = Math.max(he, ie));
            return;
          }
          (Ee.cte = he),
            Ee.fire === "" && (k[0] += Ee.cte * (Ee.oper === "+" ? 1 : -1));
        } else throw new Error("Type " + H + " is not allowed");
      }
    }
  });
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */ var Ji = 9e15,
  Br = 1e9,
  wc = "0123456789abcdef",
  Ro =
    "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
  Fo =
    "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
  Ec = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -Ji,
    maxE: Ji,
    crypto: !1,
  },
  i0,
  ur,
  je = !0,
  Jo = "[DecimalError] ",
  Lr = Jo + "Invalid argument: ",
  a0 = Jo + "Precision limit exceeded",
  s0 = Jo + "crypto unavailable",
  o0 = "[object Decimal]",
  Xt = Math.floor,
  Nt = Math.pow,
  NT = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
  RT = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
  FT = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
  u0 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
  On = 1e7,
  We = 7,
  PT = 9007199254740991,
  LT = Ro.length - 1,
  Sc = Fo.length - 1,
  xe = { toStringTag: o0 };
xe.absoluteValue = xe.abs = function () {
  var n = new this.constructor(this);
  return n.s < 0 && (n.s = 1), ke(n);
};
xe.ceil = function () {
  return ke(new this.constructor(this), this.e + 1, 2);
};
xe.clampedTo = xe.clamp = function (n, e) {
  var t,
    r = this,
    i = r.constructor;
  if (((n = new i(n)), (e = new i(e)), !n.s || !e.s)) return new i(NaN);
  if (n.gt(e)) throw Error(Lr + e);
  return (t = r.cmp(n)), t < 0 ? n : r.cmp(e) > 0 ? e : new i(r);
};
xe.comparedTo = xe.cmp = function (n) {
  var e,
    t,
    r,
    i,
    a = this,
    s = a.d,
    o = (n = new a.constructor(n)).d,
    c = a.s,
    u = n.s;
  if (!s || !o)
    return !c || !u ? NaN : c !== u ? c : s === o ? 0 : !s ^ (c < 0) ? 1 : -1;
  if (!s[0] || !o[0]) return s[0] ? c : o[0] ? -u : 0;
  if (c !== u) return c;
  if (a.e !== n.e) return (a.e > n.e) ^ (c < 0) ? 1 : -1;
  for (r = s.length, i = o.length, e = 0, t = r < i ? r : i; e < t; ++e)
    if (s[e] !== o[e]) return (s[e] > o[e]) ^ (c < 0) ? 1 : -1;
  return r === i ? 0 : (r > i) ^ (c < 0) ? 1 : -1;
};
xe.cosine = xe.cos = function () {
  var n,
    e,
    t = this,
    r = t.constructor;
  return t.d
    ? t.d[0]
      ? ((n = r.precision),
        (e = r.rounding),
        (r.precision = n + Math.max(t.e, t.sd()) + We),
        (r.rounding = 1),
        (t = IT(r, d0(r, t))),
        (r.precision = n),
        (r.rounding = e),
        ke(ur == 2 || ur == 3 ? t.neg() : t, n, e, !0))
      : new r(1)
    : new r(NaN);
};
xe.cubeRoot = xe.cbrt = function () {
  var n,
    e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u,
    l = this,
    f = l.constructor;
  if (!l.isFinite() || l.isZero()) return new f(l);
  for (
    je = !1,
      a = l.s * Nt(l.s * l, 1 / 3),
      !a || Math.abs(a) == 1 / 0
        ? ((t = Gt(l.d)),
          (n = l.e),
          (a = (n - t.length + 1) % 3) && (t += a == 1 || a == -2 ? "0" : "00"),
          (a = Nt(t, 1 / 3)),
          (n = Xt((n + 1) / 3) - (n % 3 == (n < 0 ? -1 : 2))),
          a == 1 / 0
            ? (t = "5e" + n)
            : ((t = a.toExponential()),
              (t = t.slice(0, t.indexOf("e") + 1) + n)),
          (r = new f(t)),
          (r.s = l.s))
        : (r = new f(a.toString())),
      s = (n = f.precision) + 3;
    ;

  )
    if (
      ((o = r),
      (c = o.times(o).times(o)),
      (u = c.plus(l)),
      (r = dt(u.plus(l).times(o), u.plus(c), s + 2, 1)),
      Gt(o.d).slice(0, s) === (t = Gt(r.d)).slice(0, s))
    )
      if (((t = t.slice(s - 3, s + 1)), t == "9999" || (!i && t == "4999"))) {
        if (!i && (ke(o, n + 1, 0), o.times(o).times(o).eq(l))) {
          r = o;
          break;
        }
        (s += 4), (i = 1);
      } else {
        (!+t || (!+t.slice(1) && t.charAt(0) == "5")) &&
          (ke(r, n + 1, 1), (e = !r.times(r).times(r).eq(l)));
        break;
      }
  return (je = !0), ke(r, n, f.rounding, e);
};
xe.decimalPlaces = xe.dp = function () {
  var n,
    e = this.d,
    t = NaN;
  if (e) {
    if (((n = e.length - 1), (t = (n - Xt(this.e / We)) * We), (n = e[n]), n))
      for (; n % 10 == 0; n /= 10) t--;
    t < 0 && (t = 0);
  }
  return t;
};
xe.dividedBy = xe.div = function (n) {
  return dt(this, new this.constructor(n));
};
xe.dividedToIntegerBy = xe.divToInt = function (n) {
  var e = this,
    t = e.constructor;
  return ke(dt(e, new t(n), 0, 1, 1), t.precision, t.rounding);
};
xe.equals = xe.eq = function (n) {
  return this.cmp(n) === 0;
};
xe.floor = function () {
  return ke(new this.constructor(this), this.e + 1, 3);
};
xe.greaterThan = xe.gt = function (n) {
  return this.cmp(n) > 0;
};
xe.greaterThanOrEqualTo = xe.gte = function (n) {
  var e = this.cmp(n);
  return e == 1 || e === 0;
};
xe.hyperbolicCosine = xe.cosh = function () {
  var n,
    e,
    t,
    r,
    i,
    a = this,
    s = a.constructor,
    o = new s(1);
  if (!a.isFinite()) return new s(a.s ? 1 / 0 : NaN);
  if (a.isZero()) return o;
  (t = s.precision),
    (r = s.rounding),
    (s.precision = t + Math.max(a.e, a.sd()) + 4),
    (s.rounding = 1),
    (i = a.d.length),
    i < 32
      ? ((n = Math.ceil(i / 3)), (e = (1 / Qo(4, n)).toString()))
      : ((n = 16), (e = "2.3283064365386962890625e-10")),
    (a = la(s, 1, a.times(e), new s(1), !0));
  for (var c, u = n, l = new s(8); u--; )
    (c = a.times(a)), (a = o.minus(c.times(l.minus(c.times(l)))));
  return ke(a, (s.precision = t), (s.rounding = r), !0);
};
xe.hyperbolicSine = xe.sinh = function () {
  var n,
    e,
    t,
    r,
    i = this,
    a = i.constructor;
  if (!i.isFinite() || i.isZero()) return new a(i);
  if (
    ((e = a.precision),
    (t = a.rounding),
    (a.precision = e + Math.max(i.e, i.sd()) + 4),
    (a.rounding = 1),
    (r = i.d.length),
    r < 3)
  )
    i = la(a, 2, i, i, !0);
  else {
    (n = 1.4 * Math.sqrt(r)),
      (n = n > 16 ? 16 : n | 0),
      (i = i.times(1 / Qo(5, n))),
      (i = la(a, 2, i, i, !0));
    for (var s, o = new a(5), c = new a(16), u = new a(20); n--; )
      (s = i.times(i)), (i = i.times(o.plus(s.times(c.times(s).plus(u)))));
  }
  return (a.precision = e), (a.rounding = t), ke(i, e, t, !0);
};
xe.hyperbolicTangent = xe.tanh = function () {
  var n,
    e,
    t = this,
    r = t.constructor;
  return t.isFinite()
    ? t.isZero()
      ? new r(t)
      : ((n = r.precision),
        (e = r.rounding),
        (r.precision = n + 7),
        (r.rounding = 1),
        dt(t.sinh(), t.cosh(), (r.precision = n), (r.rounding = e)))
    : new r(t.s);
};
xe.inverseCosine = xe.acos = function () {
  var n,
    e = this,
    t = e.constructor,
    r = e.abs().cmp(1),
    i = t.precision,
    a = t.rounding;
  return r !== -1
    ? r === 0
      ? e.isNeg()
        ? In(t, i, a)
        : new t(0)
      : new t(NaN)
    : e.isZero()
    ? In(t, i + 4, a).times(0.5)
    : ((t.precision = i + 6),
      (t.rounding = 1),
      (e = e.asin()),
      (n = In(t, i + 4, a).times(0.5)),
      (t.precision = i),
      (t.rounding = a),
      n.minus(e));
};
xe.inverseHyperbolicCosine = xe.acosh = function () {
  var n,
    e,
    t = this,
    r = t.constructor;
  return t.lte(1)
    ? new r(t.eq(1) ? 0 : NaN)
    : t.isFinite()
    ? ((n = r.precision),
      (e = r.rounding),
      (r.precision = n + Math.max(Math.abs(t.e), t.sd()) + 4),
      (r.rounding = 1),
      (je = !1),
      (t = t.times(t).minus(1).sqrt().plus(t)),
      (je = !0),
      (r.precision = n),
      (r.rounding = e),
      t.ln())
    : new r(t);
};
xe.inverseHyperbolicSine = xe.asinh = function () {
  var n,
    e,
    t = this,
    r = t.constructor;
  return !t.isFinite() || t.isZero()
    ? new r(t)
    : ((n = r.precision),
      (e = r.rounding),
      (r.precision = n + 2 * Math.max(Math.abs(t.e), t.sd()) + 6),
      (r.rounding = 1),
      (je = !1),
      (t = t.times(t).plus(1).sqrt().plus(t)),
      (je = !0),
      (r.precision = n),
      (r.rounding = e),
      t.ln());
};
xe.inverseHyperbolicTangent = xe.atanh = function () {
  var n,
    e,
    t,
    r,
    i = this,
    a = i.constructor;
  return i.isFinite()
    ? i.e >= 0
      ? new a(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN)
      : ((n = a.precision),
        (e = a.rounding),
        (r = i.sd()),
        Math.max(r, n) < 2 * -i.e - 1
          ? ke(new a(i), n, e, !0)
          : ((a.precision = t = r - i.e),
            (i = dt(i.plus(1), new a(1).minus(i), t + n, 1)),
            (a.precision = n + 4),
            (a.rounding = 1),
            (i = i.ln()),
            (a.precision = n),
            (a.rounding = e),
            i.times(0.5)))
    : new a(NaN);
};
xe.inverseSine = xe.asin = function () {
  var n,
    e,
    t,
    r,
    i = this,
    a = i.constructor;
  return i.isZero()
    ? new a(i)
    : ((e = i.abs().cmp(1)),
      (t = a.precision),
      (r = a.rounding),
      e !== -1
        ? e === 0
          ? ((n = In(a, t + 4, r).times(0.5)), (n.s = i.s), n)
          : new a(NaN)
        : ((a.precision = t + 6),
          (a.rounding = 1),
          (i = i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan()),
          (a.precision = t),
          (a.rounding = r),
          i.times(2)));
};
xe.inverseTangent = xe.atan = function () {
  var n,
    e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u = this,
    l = u.constructor,
    f = l.precision,
    h = l.rounding;
  if (u.isFinite()) {
    if (u.isZero()) return new l(u);
    if (u.abs().eq(1) && f + 4 <= Sc)
      return (s = In(l, f + 4, h).times(0.25)), (s.s = u.s), s;
  } else {
    if (!u.s) return new l(NaN);
    if (f + 4 <= Sc) return (s = In(l, f + 4, h).times(0.5)), (s.s = u.s), s;
  }
  for (
    l.precision = o = f + 10,
      l.rounding = 1,
      t = Math.min(28, (o / We + 2) | 0),
      n = t;
    n;
    --n
  )
    u = u.div(u.times(u).plus(1).sqrt().plus(1));
  for (
    je = !1, e = Math.ceil(o / We), r = 1, c = u.times(u), s = new l(u), i = u;
    n !== -1;

  )
    if (
      ((i = i.times(c)),
      (a = s.minus(i.div((r += 2)))),
      (i = i.times(c)),
      (s = a.plus(i.div((r += 2)))),
      s.d[e] !== void 0)
    )
      for (n = e; s.d[n] === a.d[n] && n--; );
  return (
    t && (s = s.times(2 << (t - 1))),
    (je = !0),
    ke(s, (l.precision = f), (l.rounding = h), !0)
  );
};
xe.isFinite = function () {
  return !!this.d;
};
xe.isInteger = xe.isInt = function () {
  return !!this.d && Xt(this.e / We) > this.d.length - 2;
};
xe.isNaN = function () {
  return !this.s;
};
xe.isNegative = xe.isNeg = function () {
  return this.s < 0;
};
xe.isPositive = xe.isPos = function () {
  return this.s > 0;
};
xe.isZero = function () {
  return !!this.d && this.d[0] === 0;
};
xe.lessThan = xe.lt = function (n) {
  return this.cmp(n) < 0;
};
xe.lessThanOrEqualTo = xe.lte = function (n) {
  return this.cmp(n) < 1;
};
xe.logarithm = xe.log = function (n) {
  var e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u = this,
    l = u.constructor,
    f = l.precision,
    h = l.rounding,
    d = 5;
  if (n == null) (n = new l(10)), (e = !0);
  else {
    if (((n = new l(n)), (t = n.d), n.s < 0 || !t || !t[0] || n.eq(1)))
      return new l(NaN);
    e = n.eq(10);
  }
  if (((t = u.d), u.s < 0 || !t || !t[0] || u.eq(1)))
    return new l(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
  if (e)
    if (t.length > 1) a = !0;
    else {
      for (i = t[0]; i % 10 === 0; ) i /= 10;
      a = i !== 1;
    }
  if (
    ((je = !1),
    (o = f + d),
    (s = Dr(u, o)),
    (r = e ? Po(l, o + 10) : Dr(n, o)),
    (c = dt(s, r, o, 1)),
    fs(c.d, (i = f), h))
  )
    do
      if (
        ((o += 10),
        (s = Dr(u, o)),
        (r = e ? Po(l, o + 10) : Dr(n, o)),
        (c = dt(s, r, o, 1)),
        !a)
      ) {
        +Gt(c.d).slice(i + 1, i + 15) + 1 == 1e14 && (c = ke(c, f + 1, 0));
        break;
      }
    while (fs(c.d, (i += 10), h));
  return (je = !0), ke(c, f, h);
};
xe.minus = xe.sub = function (n) {
  var e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u,
    l,
    f,
    h,
    d = this,
    g = d.constructor;
  if (((n = new g(n)), !d.d || !n.d))
    return (
      !d.s || !n.s
        ? (n = new g(NaN))
        : d.d
        ? (n.s = -n.s)
        : (n = new g(n.d || d.s !== n.s ? d : NaN)),
      n
    );
  if (d.s != n.s) return (n.s = -n.s), d.plus(n);
  if (
    ((u = d.d), (h = n.d), (o = g.precision), (c = g.rounding), !u[0] || !h[0])
  ) {
    if (h[0]) n.s = -n.s;
    else if (u[0]) n = new g(d);
    else return new g(c === 3 ? -0 : 0);
    return je ? ke(n, o, c) : n;
  }
  if (
    ((t = Xt(n.e / We)), (l = Xt(d.e / We)), (u = u.slice()), (a = l - t), a)
  ) {
    for (
      f = a < 0,
        f
          ? ((e = u), (a = -a), (s = h.length))
          : ((e = h), (t = l), (s = u.length)),
        r = Math.max(Math.ceil(o / We), s) + 2,
        a > r && ((a = r), (e.length = 1)),
        e.reverse(),
        r = a;
      r--;

    )
      e.push(0);
    e.reverse();
  } else {
    for (r = u.length, s = h.length, f = r < s, f && (s = r), r = 0; r < s; r++)
      if (u[r] != h[r]) {
        f = u[r] < h[r];
        break;
      }
    a = 0;
  }
  for (
    f && ((e = u), (u = h), (h = e), (n.s = -n.s)),
      s = u.length,
      r = h.length - s;
    r > 0;
    --r
  )
    u[s++] = 0;
  for (r = h.length; r > a; ) {
    if (u[--r] < h[r]) {
      for (i = r; i && u[--i] === 0; ) u[i] = On - 1;
      --u[i], (u[r] += On);
    }
    u[r] -= h[r];
  }
  for (; u[--s] === 0; ) u.pop();
  for (; u[0] === 0; u.shift()) --t;
  return u[0]
    ? ((n.d = u), (n.e = Ko(u, t)), je ? ke(n, o, c) : n)
    : new g(c === 3 ? -0 : 0);
};
xe.modulo = xe.mod = function (n) {
  var e,
    t = this,
    r = t.constructor;
  return (
    (n = new r(n)),
    !t.d || !n.s || (n.d && !n.d[0])
      ? new r(NaN)
      : !n.d || (t.d && !t.d[0])
      ? ke(new r(t), r.precision, r.rounding)
      : ((je = !1),
        r.modulo == 9
          ? ((e = dt(t, n.abs(), 0, 3, 1)), (e.s *= n.s))
          : (e = dt(t, n, 0, r.modulo, 1)),
        (e = e.times(n)),
        (je = !0),
        t.minus(e))
  );
};
xe.naturalExponential = xe.exp = function () {
  return Mc(this);
};
xe.naturalLogarithm = xe.ln = function () {
  return Dr(this);
};
xe.negated = xe.neg = function () {
  var n = new this.constructor(this);
  return (n.s = -n.s), ke(n);
};
xe.plus = xe.add = function (n) {
  var e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u,
    l,
    f = this,
    h = f.constructor;
  if (((n = new h(n)), !f.d || !n.d))
    return (
      !f.s || !n.s
        ? (n = new h(NaN))
        : f.d || (n = new h(n.d || f.s === n.s ? f : NaN)),
      n
    );
  if (f.s != n.s) return (n.s = -n.s), f.minus(n);
  if (
    ((u = f.d), (l = n.d), (o = h.precision), (c = h.rounding), !u[0] || !l[0])
  )
    return l[0] || (n = new h(f)), je ? ke(n, o, c) : n;
  if (
    ((a = Xt(f.e / We)), (r = Xt(n.e / We)), (u = u.slice()), (i = a - r), i)
  ) {
    for (
      i < 0
        ? ((t = u), (i = -i), (s = l.length))
        : ((t = l), (r = a), (s = u.length)),
        a = Math.ceil(o / We),
        s = a > s ? a + 1 : s + 1,
        i > s && ((i = s), (t.length = 1)),
        t.reverse();
      i--;

    )
      t.push(0);
    t.reverse();
  }
  for (
    s = u.length,
      i = l.length,
      s - i < 0 && ((i = s), (t = l), (l = u), (u = t)),
      e = 0;
    i;

  )
    (e = ((u[--i] = u[i] + l[i] + e) / On) | 0), (u[i] %= On);
  for (e && (u.unshift(e), ++r), s = u.length; u[--s] == 0; ) u.pop();
  return (n.d = u), (n.e = Ko(u, r)), je ? ke(n, o, c) : n;
};
xe.precision = xe.sd = function (n) {
  var e,
    t = this;
  if (n !== void 0 && n !== !!n && n !== 1 && n !== 0) throw Error(Lr + n);
  return (
    t.d ? ((e = c0(t.d)), n && t.e + 1 > e && (e = t.e + 1)) : (e = NaN), e
  );
};
xe.round = function () {
  var n = this,
    e = n.constructor;
  return ke(new e(n), n.e + 1, e.rounding);
};
xe.sine = xe.sin = function () {
  var n,
    e,
    t = this,
    r = t.constructor;
  return t.isFinite()
    ? t.isZero()
      ? new r(t)
      : ((n = r.precision),
        (e = r.rounding),
        (r.precision = n + Math.max(t.e, t.sd()) + We),
        (r.rounding = 1),
        (t = UT(r, d0(r, t))),
        (r.precision = n),
        (r.rounding = e),
        ke(ur > 2 ? t.neg() : t, n, e, !0))
    : new r(NaN);
};
xe.squareRoot = xe.sqrt = function () {
  var n,
    e,
    t,
    r,
    i,
    a,
    s = this,
    o = s.d,
    c = s.e,
    u = s.s,
    l = s.constructor;
  if (u !== 1 || !o || !o[0])
    return new l(!u || (u < 0 && (!o || o[0])) ? NaN : o ? s : 1 / 0);
  for (
    je = !1,
      u = Math.sqrt(+s),
      u == 0 || u == 1 / 0
        ? ((e = Gt(o)),
          (e.length + c) % 2 == 0 && (e += "0"),
          (u = Math.sqrt(e)),
          (c = Xt((c + 1) / 2) - (c < 0 || c % 2)),
          u == 1 / 0
            ? (e = "5e" + c)
            : ((e = u.toExponential()),
              (e = e.slice(0, e.indexOf("e") + 1) + c)),
          (r = new l(e)))
        : (r = new l(u.toString())),
      t = (c = l.precision) + 3;
    ;

  )
    if (
      ((a = r),
      (r = a.plus(dt(s, a, t + 2, 1)).times(0.5)),
      Gt(a.d).slice(0, t) === (e = Gt(r.d)).slice(0, t))
    )
      if (((e = e.slice(t - 3, t + 1)), e == "9999" || (!i && e == "4999"))) {
        if (!i && (ke(a, c + 1, 0), a.times(a).eq(s))) {
          r = a;
          break;
        }
        (t += 4), (i = 1);
      } else {
        (!+e || (!+e.slice(1) && e.charAt(0) == "5")) &&
          (ke(r, c + 1, 1), (n = !r.times(r).eq(s)));
        break;
      }
  return (je = !0), ke(r, c, l.rounding, n);
};
xe.tangent = xe.tan = function () {
  var n,
    e,
    t = this,
    r = t.constructor;
  return t.isFinite()
    ? t.isZero()
      ? new r(t)
      : ((n = r.precision),
        (e = r.rounding),
        (r.precision = n + 10),
        (r.rounding = 1),
        (t = t.sin()),
        (t.s = 1),
        (t = dt(t, new r(1).minus(t.times(t)).sqrt(), n + 10, 0)),
        (r.precision = n),
        (r.rounding = e),
        ke(ur == 2 || ur == 4 ? t.neg() : t, n, e, !0))
    : new r(NaN);
};
xe.times = xe.mul = function (n) {
  var e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u,
    l = this,
    f = l.constructor,
    h = l.d,
    d = (n = new f(n)).d;
  if (((n.s *= l.s), !h || !h[0] || !d || !d[0]))
    return new f(
      !n.s || (h && !h[0] && !d) || (d && !d[0] && !h)
        ? NaN
        : !h || !d
        ? n.s / 0
        : n.s * 0
    );
  for (
    t = Xt(l.e / We) + Xt(n.e / We),
      c = h.length,
      u = d.length,
      c < u && ((a = h), (h = d), (d = a), (s = c), (c = u), (u = s)),
      a = [],
      s = c + u,
      r = s;
    r--;

  )
    a.push(0);
  for (r = u; --r >= 0; ) {
    for (e = 0, i = c + r; i > r; )
      (o = a[i] + d[r] * h[i - r - 1] + e),
        (a[i--] = o % On | 0),
        (e = (o / On) | 0);
    a[i] = (a[i] + e) % On | 0;
  }
  for (; !a[--s]; ) a.pop();
  return (
    e ? ++t : a.shift(),
    (n.d = a),
    (n.e = Ko(a, t)),
    je ? ke(n, f.precision, f.rounding) : n
  );
};
xe.toBinary = function (n, e) {
  return pl(this, 2, n, e);
};
xe.toDecimalPlaces = xe.toDP = function (n, e) {
  var t = this,
    r = t.constructor;
  return (
    (t = new r(t)),
    n === void 0
      ? t
      : (un(n, 0, Br),
        e === void 0 ? (e = r.rounding) : un(e, 0, 8),
        ke(t, n + t.e + 1, e))
  );
};
xe.toExponential = function (n, e) {
  var t,
    r = this,
    i = r.constructor;
  return (
    n === void 0
      ? (t = $n(r, !0))
      : (un(n, 0, Br),
        e === void 0 ? (e = i.rounding) : un(e, 0, 8),
        (r = ke(new i(r), n + 1, e)),
        (t = $n(r, !0, n + 1))),
    r.isNeg() && !r.isZero() ? "-" + t : t
  );
};
xe.toFixed = function (n, e) {
  var t,
    r,
    i = this,
    a = i.constructor;
  return (
    n === void 0
      ? (t = $n(i))
      : (un(n, 0, Br),
        e === void 0 ? (e = a.rounding) : un(e, 0, 8),
        (r = ke(new a(i), n + i.e + 1, e)),
        (t = $n(r, !1, n + r.e + 1))),
    i.isNeg() && !i.isZero() ? "-" + t : t
  );
};
xe.toFraction = function (n) {
  var e,
    t,
    r,
    i,
    a,
    s,
    o,
    c,
    u,
    l,
    f,
    h,
    d = this,
    g = d.d,
    x = d.constructor;
  if (!g) return new x(d);
  if (
    ((u = t = new x(1)),
    (r = c = new x(0)),
    (e = new x(r)),
    (a = e.e = c0(g) - d.e - 1),
    (s = a % We),
    (e.d[0] = Nt(10, s < 0 ? We + s : s)),
    n == null)
  )
    n = a > 0 ? e : u;
  else {
    if (((o = new x(n)), !o.isInt() || o.lt(u))) throw Error(Lr + o);
    n = o.gt(e) ? (a > 0 ? e : u) : o;
  }
  for (
    je = !1,
      o = new x(Gt(g)),
      l = x.precision,
      x.precision = a = g.length * We * 2;
    (f = dt(o, e, 0, 1, 1)), (i = t.plus(f.times(r))), i.cmp(n) != 1;

  )
    (t = r),
      (r = i),
      (i = u),
      (u = c.plus(f.times(i))),
      (c = i),
      (i = e),
      (e = o.minus(f.times(i))),
      (o = i);
  return (
    (i = dt(n.minus(t), r, 0, 1, 1)),
    (c = c.plus(i.times(u))),
    (t = t.plus(i.times(r))),
    (c.s = u.s = d.s),
    (h =
      dt(u, r, a, 1).minus(d).abs().cmp(dt(c, t, a, 1).minus(d).abs()) < 1
        ? [u, r]
        : [c, t]),
    (x.precision = l),
    (je = !0),
    h
  );
};
xe.toHexadecimal = xe.toHex = function (n, e) {
  return pl(this, 16, n, e);
};
xe.toNearest = function (n, e) {
  var t = this,
    r = t.constructor;
  if (((t = new r(t)), n == null)) {
    if (!t.d) return t;
    (n = new r(1)), (e = r.rounding);
  } else {
    if (((n = new r(n)), e === void 0 ? (e = r.rounding) : un(e, 0, 8), !t.d))
      return n.s ? t : n;
    if (!n.d) return n.s && (n.s = t.s), n;
  }
  return (
    n.d[0]
      ? ((je = !1), (t = dt(t, n, 0, e, 1).times(n)), (je = !0), ke(t))
      : ((n.s = t.s), (t = n)),
    t
  );
};
xe.toNumber = function () {
  return +this;
};
xe.toOctal = function (n, e) {
  return pl(this, 8, n, e);
};
xe.toPower = xe.pow = function (n) {
  var e,
    t,
    r,
    i,
    a,
    s,
    o = this,
    c = o.constructor,
    u = +(n = new c(n));
  if (!o.d || !n.d || !o.d[0] || !n.d[0]) return new c(Nt(+o, u));
  if (((o = new c(o)), o.eq(1))) return o;
  if (((r = c.precision), (a = c.rounding), n.eq(1))) return ke(o, r, a);
  if (((e = Xt(n.e / We)), e >= n.d.length - 1 && (t = u < 0 ? -u : u) <= PT))
    return (i = l0(c, o, t, r)), n.s < 0 ? new c(1).div(i) : ke(i, r, a);
  if (((s = o.s), s < 0)) {
    if (e < n.d.length - 1) return new c(NaN);
    if ((n.d[e] & 1 || (s = 1), o.e == 0 && o.d[0] == 1 && o.d.length == 1))
      return (o.s = s), o;
  }
  return (
    (t = Nt(+o, u)),
    (e =
      t == 0 || !isFinite(t)
        ? Xt(u * (Math.log("0." + Gt(o.d)) / Math.LN10 + o.e + 1))
        : new c(t + "").e),
    e > c.maxE + 1 || e < c.minE - 1
      ? new c(e > 0 ? s / 0 : 0)
      : ((je = !1),
        (c.rounding = o.s = 1),
        (t = Math.min(12, (e + "").length)),
        (i = Mc(n.times(Dr(o, r + t)), r)),
        i.d &&
          ((i = ke(i, r + 5, 1)),
          fs(i.d, r, a) &&
            ((e = r + 10),
            (i = ke(Mc(n.times(Dr(o, e + t)), e), e + 5, 1)),
            +Gt(i.d).slice(r + 1, r + 15) + 1 == 1e14 &&
              (i = ke(i, r + 1, 0)))),
        (i.s = s),
        (je = !0),
        (c.rounding = a),
        ke(i, r, a))
  );
};
xe.toPrecision = function (n, e) {
  var t,
    r = this,
    i = r.constructor;
  return (
    n === void 0
      ? (t = $n(r, r.e <= i.toExpNeg || r.e >= i.toExpPos))
      : (un(n, 1, Br),
        e === void 0 ? (e = i.rounding) : un(e, 0, 8),
        (r = ke(new i(r), n, e)),
        (t = $n(r, n <= r.e || r.e <= i.toExpNeg, n))),
    r.isNeg() && !r.isZero() ? "-" + t : t
  );
};
xe.toSignificantDigits = xe.toSD = function (n, e) {
  var t = this,
    r = t.constructor;
  return (
    n === void 0
      ? ((n = r.precision), (e = r.rounding))
      : (un(n, 1, Br), e === void 0 ? (e = r.rounding) : un(e, 0, 8)),
    ke(new r(t), n, e)
  );
};
xe.toString = function () {
  var n = this,
    e = n.constructor,
    t = $n(n, n.e <= e.toExpNeg || n.e >= e.toExpPos);
  return n.isNeg() && !n.isZero() ? "-" + t : t;
};
xe.truncated = xe.trunc = function () {
  return ke(new this.constructor(this), this.e + 1, 1);
};
xe.valueOf = xe.toJSON = function () {
  var n = this,
    e = n.constructor,
    t = $n(n, n.e <= e.toExpNeg || n.e >= e.toExpPos);
  return n.isNeg() ? "-" + t : t;
};
function Gt(n) {
  var e,
    t,
    r,
    i = n.length - 1,
    a = "",
    s = n[0];
  if (i > 0) {
    for (a += s, e = 1; e < i; e++)
      (r = n[e] + ""), (t = We - r.length), t && (a += _r(t)), (a += r);
    (s = n[e]), (r = s + ""), (t = We - r.length), t && (a += _r(t));
  } else if (s === 0) return "0";
  for (; s % 10 === 0; ) s /= 10;
  return a + s;
}
function un(n, e, t) {
  if (n !== ~~n || n < e || n > t) throw Error(Lr + n);
}
function fs(n, e, t, r) {
  var i, a, s, o;
  for (a = n[0]; a >= 10; a /= 10) --e;
  return (
    --e < 0 ? ((e += We), (i = 0)) : ((i = Math.ceil((e + 1) / We)), (e %= We)),
    (a = Nt(10, We - e)),
    (o = n[i] % a | 0),
    r == null
      ? e < 3
        ? (e == 0 ? (o = (o / 100) | 0) : e == 1 && (o = (o / 10) | 0),
          (s =
            (t < 4 && o == 99999) ||
            (t > 3 && o == 49999) ||
            o == 5e4 ||
            o == 0))
        : (s =
            (((t < 4 && o + 1 == a) || (t > 3 && o + 1 == a / 2)) &&
              ((n[i + 1] / a / 100) | 0) == Nt(10, e - 2) - 1) ||
            ((o == a / 2 || o == 0) && ((n[i + 1] / a / 100) | 0) == 0))
      : e < 4
      ? (e == 0
          ? (o = (o / 1e3) | 0)
          : e == 1
          ? (o = (o / 100) | 0)
          : e == 2 && (o = (o / 10) | 0),
        (s = ((r || t < 4) && o == 9999) || (!r && t > 3 && o == 4999)))
      : (s =
          (((r || t < 4) && o + 1 == a) || (!r && t > 3 && o + 1 == a / 2)) &&
          ((n[i + 1] / a / 1e3) | 0) == Nt(10, e - 3) - 1),
    s
  );
}
function Eo(n, e, t) {
  for (var r, i = [0], a, s = 0, o = n.length; s < o; ) {
    for (a = i.length; a--; ) i[a] *= e;
    for (i[0] += wc.indexOf(n.charAt(s++)), r = 0; r < i.length; r++)
      i[r] > t - 1 &&
        (i[r + 1] === void 0 && (i[r + 1] = 0),
        (i[r + 1] += (i[r] / t) | 0),
        (i[r] %= t));
  }
  return i.reverse();
}
function IT(n, e) {
  var t, r, i;
  if (e.isZero()) return e;
  (r = e.d.length),
    r < 32
      ? ((t = Math.ceil(r / 3)), (i = (1 / Qo(4, t)).toString()))
      : ((t = 16), (i = "2.3283064365386962890625e-10")),
    (n.precision += t),
    (e = la(n, 1, e.times(i), new n(1)));
  for (var a = t; a--; ) {
    var s = e.times(e);
    e = s.times(s).minus(s).times(8).plus(1);
  }
  return (n.precision -= t), e;
}
var dt = (function () {
  function n(r, i, a) {
    var s,
      o = 0,
      c = r.length;
    for (r = r.slice(); c--; )
      (s = r[c] * i + o), (r[c] = s % a | 0), (o = (s / a) | 0);
    return o && r.unshift(o), r;
  }
  function e(r, i, a, s) {
    var o, c;
    if (a != s) c = a > s ? 1 : -1;
    else
      for (o = c = 0; o < a; o++)
        if (r[o] != i[o]) {
          c = r[o] > i[o] ? 1 : -1;
          break;
        }
    return c;
  }
  function t(r, i, a, s) {
    for (var o = 0; a--; )
      (r[a] -= o), (o = r[a] < i[a] ? 1 : 0), (r[a] = o * s + r[a] - i[a]);
    for (; !r[0] && r.length > 1; ) r.shift();
  }
  return function (r, i, a, s, o, c) {
    var u,
      l,
      f,
      h,
      d,
      g,
      x,
      m,
      p,
      S,
      v,
      y,
      E,
      M,
      T,
      N,
      A,
      D,
      z,
      $,
      I = r.constructor,
      G = r.s == i.s ? 1 : -1,
      L = r.d,
      C = i.d;
    if (!L || !L[0] || !C || !C[0])
      return new I(
        !r.s || !i.s || (L ? C && L[0] == C[0] : !C)
          ? NaN
          : (L && L[0] == 0) || !C
          ? G * 0
          : G / 0
      );
    for (
      c
        ? ((d = 1), (l = r.e - i.e))
        : ((c = On), (d = We), (l = Xt(r.e / d) - Xt(i.e / d))),
        z = C.length,
        A = L.length,
        p = new I(G),
        S = p.d = [],
        f = 0;
      C[f] == (L[f] || 0);
      f++
    );
    if (
      (C[f] > (L[f] || 0) && l--,
      a == null
        ? ((M = a = I.precision), (s = I.rounding))
        : o
        ? (M = a + (r.e - i.e) + 1)
        : (M = a),
      M < 0)
    )
      S.push(1), (g = !0);
    else {
      if (((M = (M / d + 2) | 0), (f = 0), z == 1)) {
        for (h = 0, C = C[0], M++; (f < A || h) && M--; f++)
          (T = h * c + (L[f] || 0)), (S[f] = (T / C) | 0), (h = T % C | 0);
        g = h || f < A;
      } else {
        for (
          h = (c / (C[0] + 1)) | 0,
            h > 1 &&
              ((C = n(C, h, c)),
              (L = n(L, h, c)),
              (z = C.length),
              (A = L.length)),
            N = z,
            v = L.slice(0, z),
            y = v.length;
          y < z;

        )
          v[y++] = 0;
        ($ = C.slice()), $.unshift(0), (D = C[0]), C[1] >= c / 2 && ++D;
        do
          (h = 0),
            (u = e(C, v, z, y)),
            u < 0
              ? ((E = v[0]),
                z != y && (E = E * c + (v[1] || 0)),
                (h = (E / D) | 0),
                h > 1
                  ? (h >= c && (h = c - 1),
                    (x = n(C, h, c)),
                    (m = x.length),
                    (y = v.length),
                    (u = e(x, v, m, y)),
                    u == 1 && (h--, t(x, z < m ? $ : C, m, c)))
                  : (h == 0 && (u = h = 1), (x = C.slice())),
                (m = x.length),
                m < y && x.unshift(0),
                t(v, x, y, c),
                u == -1 &&
                  ((y = v.length),
                  (u = e(C, v, z, y)),
                  u < 1 && (h++, t(v, z < y ? $ : C, y, c))),
                (y = v.length))
              : u === 0 && (h++, (v = [0])),
            (S[f++] = h),
            u && v[0] ? (v[y++] = L[N] || 0) : ((v = [L[N]]), (y = 1));
        while ((N++ < A || v[0] !== void 0) && M--);
        g = v[0] !== void 0;
      }
      S[0] || S.shift();
    }
    if (d == 1) (p.e = l), (i0 = g);
    else {
      for (f = 1, h = S[0]; h >= 10; h /= 10) f++;
      (p.e = f + l * d - 1), ke(p, o ? a + p.e + 1 : a, s, g);
    }
    return p;
  };
})();
function ke(n, e, t, r) {
  var i,
    a,
    s,
    o,
    c,
    u,
    l,
    f,
    h,
    d = n.constructor;
  e: if (e != null) {
    if (((f = n.d), !f)) return n;
    for (i = 1, o = f[0]; o >= 10; o /= 10) i++;
    if (((a = e - i), a < 0))
      (a += We),
        (s = e),
        (l = f[(h = 0)]),
        (c = (l / Nt(10, i - s - 1)) % 10 | 0);
    else if (((h = Math.ceil((a + 1) / We)), (o = f.length), h >= o))
      if (r) {
        for (; o++ <= h; ) f.push(0);
        (l = c = 0), (i = 1), (a %= We), (s = a - We + 1);
      } else break e;
    else {
      for (l = o = f[h], i = 1; o >= 10; o /= 10) i++;
      (a %= We),
        (s = a - We + i),
        (c = s < 0 ? 0 : (l / Nt(10, i - s - 1)) % 10 | 0);
    }
    if (
      ((r =
        r ||
        e < 0 ||
        f[h + 1] !== void 0 ||
        (s < 0 ? l : l % Nt(10, i - s - 1))),
      (u =
        t < 4
          ? (c || r) && (t == 0 || t == (n.s < 0 ? 3 : 2))
          : c > 5 ||
            (c == 5 &&
              (t == 4 ||
                r ||
                (t == 6 &&
                  (a > 0 ? (s > 0 ? l / Nt(10, i - s) : 0) : f[h - 1]) % 10 &
                    1) ||
                t == (n.s < 0 ? 8 : 7)))),
      e < 1 || !f[0])
    )
      return (
        (f.length = 0),
        u
          ? ((e -= n.e + 1),
            (f[0] = Nt(10, (We - (e % We)) % We)),
            (n.e = -e || 0))
          : (f[0] = n.e = 0),
        n
      );
    if (
      (a == 0
        ? ((f.length = h), (o = 1), h--)
        : ((f.length = h + 1),
          (o = Nt(10, We - a)),
          (f[h] = s > 0 ? ((l / Nt(10, i - s)) % Nt(10, s) | 0) * o : 0)),
      u)
    )
      for (;;)
        if (h == 0) {
          for (a = 1, s = f[0]; s >= 10; s /= 10) a++;
          for (s = f[0] += o, o = 1; s >= 10; s /= 10) o++;
          a != o && (n.e++, f[0] == On && (f[0] = 1));
          break;
        } else {
          if (((f[h] += o), f[h] != On)) break;
          (f[h--] = 0), (o = 1);
        }
    for (a = f.length; f[--a] === 0; ) f.pop();
  }
  return (
    je &&
      (n.e > d.maxE
        ? ((n.d = null), (n.e = NaN))
        : n.e < d.minE && ((n.e = 0), (n.d = [0]))),
    n
  );
}
function $n(n, e, t) {
  if (!n.isFinite()) return h0(n);
  var r,
    i = n.e,
    a = Gt(n.d),
    s = a.length;
  return (
    e
      ? (t && (r = t - s) > 0
          ? (a = a.charAt(0) + "." + a.slice(1) + _r(r))
          : s > 1 && (a = a.charAt(0) + "." + a.slice(1)),
        (a = a + (n.e < 0 ? "e" : "e+") + n.e))
      : i < 0
      ? ((a = "0." + _r(-i - 1) + a), t && (r = t - s) > 0 && (a += _r(r)))
      : i >= s
      ? ((a += _r(i + 1 - s)),
        t && (r = t - i - 1) > 0 && (a = a + "." + _r(r)))
      : ((r = i + 1) < s && (a = a.slice(0, r) + "." + a.slice(r)),
        t && (r = t - s) > 0 && (i + 1 === s && (a += "."), (a += _r(r)))),
    a
  );
}
function Ko(n, e) {
  var t = n[0];
  for (e *= We; t >= 10; t /= 10) e++;
  return e;
}
function Po(n, e, t) {
  if (e > LT) throw ((je = !0), t && (n.precision = t), Error(a0));
  return ke(new n(Ro), e, 1, !0);
}
function In(n, e, t) {
  if (e > Sc) throw Error(a0);
  return ke(new n(Fo), e, t, !0);
}
function c0(n) {
  var e = n.length - 1,
    t = e * We + 1;
  if (((e = n[e]), e)) {
    for (; e % 10 == 0; e /= 10) t--;
    for (e = n[0]; e >= 10; e /= 10) t++;
  }
  return t;
}
function _r(n) {
  for (var e = ""; n--; ) e += "0";
  return e;
}
function l0(n, e, t, r) {
  var i,
    a = new n(1),
    s = Math.ceil(r / We + 4);
  for (je = !1; ; ) {
    if (
      (t % 2 && ((a = a.times(e)), Jh(a.d, s) && (i = !0)),
      (t = Xt(t / 2)),
      t === 0)
    ) {
      (t = a.d.length - 1), i && a.d[t] === 0 && ++a.d[t];
      break;
    }
    (e = e.times(e)), Jh(e.d, s);
  }
  return (je = !0), a;
}
function Zh(n) {
  return n.d[n.d.length - 1] & 1;
}
function f0(n, e, t) {
  for (var r, i = new n(e[0]), a = 0; ++a < e.length; )
    if (((r = new n(e[a])), r.s)) i[t](r) && (i = r);
    else {
      i = r;
      break;
    }
  return i;
}
function Mc(n, e) {
  var t,
    r,
    i,
    a,
    s,
    o,
    c,
    u = 0,
    l = 0,
    f = 0,
    h = n.constructor,
    d = h.rounding,
    g = h.precision;
  if (!n.d || !n.d[0] || n.e > 17)
    return new h(
      n.d
        ? n.d[0]
          ? n.s < 0
            ? 0
            : 1 / 0
          : 1
        : n.s
        ? n.s < 0
          ? 0
          : n
        : 0 / 0
    );
  for (
    e == null ? ((je = !1), (c = g)) : (c = e), o = new h(0.03125);
    n.e > -2;

  )
    (n = n.times(o)), (f += 5);
  for (
    r = ((Math.log(Nt(2, f)) / Math.LN10) * 2 + 5) | 0,
      c += r,
      t = a = s = new h(1),
      h.precision = c;
    ;

  ) {
    if (
      ((a = ke(a.times(n), c, 1)),
      (t = t.times(++l)),
      (o = s.plus(dt(a, t, c, 1))),
      Gt(o.d).slice(0, c) === Gt(s.d).slice(0, c))
    ) {
      for (i = f; i--; ) s = ke(s.times(s), c, 1);
      if (e == null)
        if (u < 3 && fs(s.d, c - r, d, u))
          (h.precision = c += 10), (t = a = o = new h(1)), (l = 0), u++;
        else return ke(s, (h.precision = g), d, (je = !0));
      else return (h.precision = g), s;
    }
    s = o;
  }
}
function Dr(n, e) {
  var t,
    r,
    i,
    a,
    s,
    o,
    c,
    u,
    l,
    f,
    h,
    d = 1,
    g = 10,
    x = n,
    m = x.d,
    p = x.constructor,
    S = p.rounding,
    v = p.precision;
  if (x.s < 0 || !m || !m[0] || (!x.e && m[0] == 1 && m.length == 1))
    return new p(m && !m[0] ? -1 / 0 : x.s != 1 ? NaN : m ? 0 : x);
  if (
    (e == null ? ((je = !1), (l = v)) : (l = e),
    (p.precision = l += g),
    (t = Gt(m)),
    (r = t.charAt(0)),
    Math.abs((a = x.e)) < 15e14)
  ) {
    for (; (r < 7 && r != 1) || (r == 1 && t.charAt(1) > 3); )
      (x = x.times(n)), (t = Gt(x.d)), (r = t.charAt(0)), d++;
    (a = x.e),
      r > 1 ? ((x = new p("0." + t)), a++) : (x = new p(r + "." + t.slice(1)));
  } else
    return (
      (u = Po(p, l + 2, v).times(a + "")),
      (x = Dr(new p(r + "." + t.slice(1)), l - g).plus(u)),
      (p.precision = v),
      e == null ? ke(x, v, S, (je = !0)) : x
    );
  for (
    f = x,
      c = s = x = dt(x.minus(1), x.plus(1), l, 1),
      h = ke(x.times(x), l, 1),
      i = 3;
    ;

  ) {
    if (
      ((s = ke(s.times(h), l, 1)),
      (u = c.plus(dt(s, new p(i), l, 1))),
      Gt(u.d).slice(0, l) === Gt(c.d).slice(0, l))
    )
      if (
        ((c = c.times(2)),
        a !== 0 && (c = c.plus(Po(p, l + 2, v).times(a + ""))),
        (c = dt(c, new p(d), l, 1)),
        e == null)
      )
        if (fs(c.d, l - g, S, o))
          (p.precision = l += g),
            (u = s = x = dt(f.minus(1), f.plus(1), l, 1)),
            (h = ke(x.times(x), l, 1)),
            (i = o = 1);
        else return ke(c, (p.precision = v), S, (je = !0));
      else return (p.precision = v), c;
    (c = u), (i += 2);
  }
}
function h0(n) {
  return String((n.s * n.s) / 0);
}
function Ac(n, e) {
  var t, r, i;
  for (
    (t = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
      (r = e.search(/e/i)) > 0
        ? (t < 0 && (t = r), (t += +e.slice(r + 1)), (e = e.substring(0, r)))
        : t < 0 && (t = e.length),
      r = 0;
    e.charCodeAt(r) === 48;
    r++
  );
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i);
  if (((e = e.slice(r, i)), e)) {
    if (
      ((i -= r),
      (n.e = t = t - r - 1),
      (n.d = []),
      (r = (t + 1) % We),
      t < 0 && (r += We),
      r < i)
    ) {
      for (r && n.d.push(+e.slice(0, r)), i -= We; r < i; )
        n.d.push(+e.slice(r, (r += We)));
      (e = e.slice(r)), (r = We - e.length);
    } else r -= i;
    for (; r--; ) e += "0";
    n.d.push(+e),
      je &&
        (n.e > n.constructor.maxE
          ? ((n.d = null), (n.e = NaN))
          : n.e < n.constructor.minE && ((n.e = 0), (n.d = [0])));
  } else (n.e = 0), (n.d = [0]);
  return n;
}
function OT(n, e) {
  var t, r, i, a, s, o, c, u, l;
  if (e.indexOf("_") > -1) {
    if (((e = e.replace(/(\d)_(?=\d)/g, "$1")), u0.test(e))) return Ac(n, e);
  } else if (e === "Infinity" || e === "NaN")
    return +e || (n.s = NaN), (n.e = NaN), (n.d = null), n;
  if (RT.test(e)) (t = 16), (e = e.toLowerCase());
  else if (NT.test(e)) t = 2;
  else if (FT.test(e)) t = 8;
  else throw Error(Lr + e);
  for (
    a = e.search(/p/i),
      a > 0
        ? ((c = +e.slice(a + 1)), (e = e.substring(2, a)))
        : (e = e.slice(2)),
      a = e.indexOf("."),
      s = a >= 0,
      r = n.constructor,
      s &&
        ((e = e.replace(".", "")),
        (o = e.length),
        (a = o - a),
        (i = l0(r, new r(t), a, a * 2))),
      u = Eo(e, t, On),
      l = u.length - 1,
      a = l;
    u[a] === 0;
    --a
  )
    u.pop();
  return a < 0
    ? new r(n.s * 0)
    : ((n.e = Ko(u, l)),
      (n.d = u),
      (je = !1),
      s && (n = dt(n, i, o * 4)),
      c && (n = n.times(Math.abs(c) < 54 ? Nt(2, c) : eu.pow(2, c))),
      (je = !0),
      n);
}
function UT(n, e) {
  var t,
    r = e.d.length;
  if (r < 3) return e.isZero() ? e : la(n, 2, e, e);
  (t = 1.4 * Math.sqrt(r)),
    (t = t > 16 ? 16 : t | 0),
    (e = e.times(1 / Qo(5, t))),
    (e = la(n, 2, e, e));
  for (var i, a = new n(5), s = new n(16), o = new n(20); t--; )
    (i = e.times(e)), (e = e.times(a.plus(i.times(s.times(i).minus(o)))));
  return e;
}
function la(n, e, t, r, i) {
  var a,
    s,
    o,
    c,
    u = n.precision,
    l = Math.ceil(u / We);
  for (je = !1, c = t.times(t), o = new n(r); ; ) {
    if (
      ((s = dt(o.times(c), new n(e++ * e++), u, 1)),
      (o = i ? r.plus(s) : r.minus(s)),
      (r = dt(s.times(c), new n(e++ * e++), u, 1)),
      (s = o.plus(r)),
      s.d[l] !== void 0)
    ) {
      for (a = l; s.d[a] === o.d[a] && a--; );
      if (a == -1) break;
    }
    (a = o), (o = r), (r = s), (s = a);
  }
  return (je = !0), (s.d.length = l + 1), s;
}
function Qo(n, e) {
  for (var t = n; --e; ) t *= n;
  return t;
}
function d0(n, e) {
  var t,
    r = e.s < 0,
    i = In(n, n.precision, 1),
    a = i.times(0.5);
  if (((e = e.abs()), e.lte(a))) return (ur = r ? 4 : 1), e;
  if (((t = e.divToInt(i)), t.isZero())) ur = r ? 3 : 2;
  else {
    if (((e = e.minus(t.times(i))), e.lte(a)))
      return (ur = Zh(t) ? (r ? 2 : 3) : r ? 4 : 1), e;
    ur = Zh(t) ? (r ? 1 : 4) : r ? 3 : 2;
  }
  return e.minus(i).abs();
}
function pl(n, e, t, r) {
  var i,
    a,
    s,
    o,
    c,
    u,
    l,
    f,
    h,
    d = n.constructor,
    g = t !== void 0;
  if (
    (g
      ? (un(t, 1, Br), r === void 0 ? (r = d.rounding) : un(r, 0, 8))
      : ((t = d.precision), (r = d.rounding)),
    !n.isFinite())
  )
    l = h0(n);
  else {
    for (
      l = $n(n),
        s = l.indexOf("."),
        g
          ? ((i = 2), e == 16 ? (t = t * 4 - 3) : e == 8 && (t = t * 3 - 2))
          : (i = e),
        s >= 0 &&
          ((l = l.replace(".", "")),
          (h = new d(1)),
          (h.e = l.length - s),
          (h.d = Eo($n(h), 10, i)),
          (h.e = h.d.length)),
        f = Eo(l, 10, i),
        a = c = f.length;
      f[--c] == 0;

    )
      f.pop();
    if (!f[0]) l = g ? "0p+0" : "0";
    else {
      if (
        (s < 0
          ? a--
          : ((n = new d(n)),
            (n.d = f),
            (n.e = a),
            (n = dt(n, h, t, r, 0, i)),
            (f = n.d),
            (a = n.e),
            (u = i0)),
        (s = f[t]),
        (o = i / 2),
        (u = u || f[t + 1] !== void 0),
        (u =
          r < 4
            ? (s !== void 0 || u) && (r === 0 || r === (n.s < 0 ? 3 : 2))
            : s > o ||
              (s === o &&
                (r === 4 ||
                  u ||
                  (r === 6 && f[t - 1] & 1) ||
                  r === (n.s < 0 ? 8 : 7)))),
        (f.length = t),
        u)
      )
        for (; ++f[--t] > i - 1; ) (f[t] = 0), t || (++a, f.unshift(1));
      for (c = f.length; !f[c - 1]; --c);
      for (s = 0, l = ""; s < c; s++) l += wc.charAt(f[s]);
      if (g) {
        if (c > 1)
          if (e == 16 || e == 8) {
            for (s = e == 16 ? 4 : 3, --c; c % s; c++) l += "0";
            for (f = Eo(l, i, e), c = f.length; !f[c - 1]; --c);
            for (s = 1, l = "1."; s < c; s++) l += wc.charAt(f[s]);
          } else l = l.charAt(0) + "." + l.slice(1);
        l = l + (a < 0 ? "p" : "p+") + a;
      } else if (a < 0) {
        for (; ++a; ) l = "0" + l;
        l = "0." + l;
      } else if (++a > c) for (a -= c; a--; ) l += "0";
      else a < c && (l = l.slice(0, a) + "." + l.slice(a));
    }
    l = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + l;
  }
  return n.s < 0 ? "-" + l : l;
}
function Jh(n, e) {
  if (n.length > e) return (n.length = e), !0;
}
function BT(n) {
  return new this(n).abs();
}
function zT(n) {
  return new this(n).acos();
}
function kT(n) {
  return new this(n).acosh();
}
function HT(n, e) {
  return new this(n).plus(e);
}
function GT(n) {
  return new this(n).asin();
}
function VT(n) {
  return new this(n).asinh();
}
function WT(n) {
  return new this(n).atan();
}
function qT(n) {
  return new this(n).atanh();
}
function $T(n, e) {
  (n = new this(n)), (e = new this(e));
  var t,
    r = this.precision,
    i = this.rounding,
    a = r + 4;
  return (
    !n.s || !e.s
      ? (t = new this(NaN))
      : !n.d && !e.d
      ? ((t = In(this, a, 1).times(e.s > 0 ? 0.25 : 0.75)), (t.s = n.s))
      : !e.d || n.isZero()
      ? ((t = e.s < 0 ? In(this, r, i) : new this(0)), (t.s = n.s))
      : !n.d || e.isZero()
      ? ((t = In(this, a, 1).times(0.5)), (t.s = n.s))
      : e.s < 0
      ? ((this.precision = a),
        (this.rounding = 1),
        (t = this.atan(dt(n, e, a, 1))),
        (e = In(this, a, 1)),
        (this.precision = r),
        (this.rounding = i),
        (t = n.s < 0 ? t.minus(e) : t.plus(e)))
      : (t = this.atan(dt(n, e, a, 1))),
    t
  );
}
function jT(n) {
  return new this(n).cbrt();
}
function XT(n) {
  return ke((n = new this(n)), n.e + 1, 2);
}
function YT(n, e, t) {
  return new this(n).clamp(e, t);
}
function ZT(n) {
  if (!n || typeof n != "object") throw Error(Jo + "Object expected");
  var e,
    t,
    r,
    i = n.defaults === !0,
    a = [
      "precision",
      1,
      Br,
      "rounding",
      0,
      8,
      "toExpNeg",
      -Ji,
      0,
      "toExpPos",
      0,
      Ji,
      "maxE",
      0,
      Ji,
      "minE",
      -Ji,
      0,
      "modulo",
      0,
      9,
    ];
  for (e = 0; e < a.length; e += 3)
    if (((t = a[e]), i && (this[t] = Ec[t]), (r = n[t]) !== void 0))
      if (Xt(r) === r && r >= a[e + 1] && r <= a[e + 2]) this[t] = r;
      else throw Error(Lr + t + ": " + r);
  if (((t = "crypto"), i && (this[t] = Ec[t]), (r = n[t]) !== void 0))
    if (r === !0 || r === !1 || r === 0 || r === 1)
      if (r)
        if (
          typeof crypto < "u" &&
          crypto &&
          (crypto.getRandomValues || crypto.randomBytes)
        )
          this[t] = !0;
        else throw Error(s0);
      else this[t] = !1;
    else throw Error(Lr + t + ": " + r);
  return this;
}
function JT(n) {
  return new this(n).cos();
}
function KT(n) {
  return new this(n).cosh();
}
function p0(n) {
  var e, t, r;
  function i(a) {
    var s,
      o,
      c,
      u = this;
    if (!(u instanceof i)) return new i(a);
    if (((u.constructor = i), Kh(a))) {
      (u.s = a.s),
        je
          ? !a.d || a.e > i.maxE
            ? ((u.e = NaN), (u.d = null))
            : a.e < i.minE
            ? ((u.e = 0), (u.d = [0]))
            : ((u.e = a.e), (u.d = a.d.slice()))
          : ((u.e = a.e), (u.d = a.d ? a.d.slice() : a.d));
      return;
    }
    if (((c = typeof a), c === "number")) {
      if (a === 0) {
        (u.s = 1 / a < 0 ? -1 : 1), (u.e = 0), (u.d = [0]);
        return;
      }
      if ((a < 0 ? ((a = -a), (u.s = -1)) : (u.s = 1), a === ~~a && a < 1e7)) {
        for (s = 0, o = a; o >= 10; o /= 10) s++;
        je
          ? s > i.maxE
            ? ((u.e = NaN), (u.d = null))
            : s < i.minE
            ? ((u.e = 0), (u.d = [0]))
            : ((u.e = s), (u.d = [a]))
          : ((u.e = s), (u.d = [a]));
        return;
      } else if (a * 0 !== 0) {
        a || (u.s = NaN), (u.e = NaN), (u.d = null);
        return;
      }
      return Ac(u, a.toString());
    } else if (c !== "string") throw Error(Lr + a);
    return (
      (o = a.charCodeAt(0)) === 45
        ? ((a = a.slice(1)), (u.s = -1))
        : (o === 43 && (a = a.slice(1)), (u.s = 1)),
      u0.test(a) ? Ac(u, a) : OT(u, a)
    );
  }
  if (
    ((i.prototype = xe),
    (i.ROUND_UP = 0),
    (i.ROUND_DOWN = 1),
    (i.ROUND_CEIL = 2),
    (i.ROUND_FLOOR = 3),
    (i.ROUND_HALF_UP = 4),
    (i.ROUND_HALF_DOWN = 5),
    (i.ROUND_HALF_EVEN = 6),
    (i.ROUND_HALF_CEIL = 7),
    (i.ROUND_HALF_FLOOR = 8),
    (i.EUCLID = 9),
    (i.config = i.set = ZT),
    (i.clone = p0),
    (i.isDecimal = Kh),
    (i.abs = BT),
    (i.acos = zT),
    (i.acosh = kT),
    (i.add = HT),
    (i.asin = GT),
    (i.asinh = VT),
    (i.atan = WT),
    (i.atanh = qT),
    (i.atan2 = $T),
    (i.cbrt = jT),
    (i.ceil = XT),
    (i.clamp = YT),
    (i.cos = JT),
    (i.cosh = KT),
    (i.div = QT),
    (i.exp = eC),
    (i.floor = tC),
    (i.hypot = nC),
    (i.ln = rC),
    (i.log = iC),
    (i.log10 = sC),
    (i.log2 = aC),
    (i.max = oC),
    (i.min = uC),
    (i.mod = cC),
    (i.mul = lC),
    (i.pow = fC),
    (i.random = hC),
    (i.round = dC),
    (i.sign = pC),
    (i.sin = mC),
    (i.sinh = gC),
    (i.sqrt = vC),
    (i.sub = yC),
    (i.sum = xC),
    (i.tan = bC),
    (i.tanh = _C),
    (i.trunc = wC),
    n === void 0 && (n = {}),
    n && n.defaults !== !0)
  )
    for (
      r = [
        "precision",
        "rounding",
        "toExpNeg",
        "toExpPos",
        "maxE",
        "minE",
        "modulo",
        "crypto",
      ],
        e = 0;
      e < r.length;

    )
      n.hasOwnProperty((t = r[e++])) || (n[t] = this[t]);
  return i.config(n), i;
}
function QT(n, e) {
  return new this(n).div(e);
}
function eC(n) {
  return new this(n).exp();
}
function tC(n) {
  return ke((n = new this(n)), n.e + 1, 3);
}
function nC() {
  var n,
    e,
    t = new this(0);
  for (je = !1, n = 0; n < arguments.length; )
    if (((e = new this(arguments[n++])), e.d)) t.d && (t = t.plus(e.times(e)));
    else {
      if (e.s) return (je = !0), new this(1 / 0);
      t = e;
    }
  return (je = !0), t.sqrt();
}
function Kh(n) {
  return n instanceof eu || (n && n.toStringTag === o0) || !1;
}
function rC(n) {
  return new this(n).ln();
}
function iC(n, e) {
  return new this(n).log(e);
}
function aC(n) {
  return new this(n).log(2);
}
function sC(n) {
  return new this(n).log(10);
}
function oC() {
  return f0(this, arguments, "lt");
}
function uC() {
  return f0(this, arguments, "gt");
}
function cC(n, e) {
  return new this(n).mod(e);
}
function lC(n, e) {
  return new this(n).mul(e);
}
function fC(n, e) {
  return new this(n).pow(e);
}
function hC(n) {
  var e,
    t,
    r,
    i,
    a = 0,
    s = new this(1),
    o = [];
  if (
    (n === void 0 ? (n = this.precision) : un(n, 1, Br),
    (r = Math.ceil(n / We)),
    this.crypto)
  )
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(r)); a < r; )
        (i = e[a]),
          i >= 429e7
            ? (e[a] = crypto.getRandomValues(new Uint32Array(1))[0])
            : (o[a++] = i % 1e7);
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes((r *= 4)); a < r; )
        (i =
          e[a] + (e[a + 1] << 8) + (e[a + 2] << 16) + ((e[a + 3] & 127) << 24)),
          i >= 214e7
            ? crypto.randomBytes(4).copy(e, a)
            : (o.push(i % 1e7), (a += 4));
      a = r / 4;
    } else throw Error(s0);
  else for (; a < r; ) o[a++] = (Math.random() * 1e7) | 0;
  for (
    r = o[--a],
      n %= We,
      r && n && ((i = Nt(10, We - n)), (o[a] = ((r / i) | 0) * i));
    o[a] === 0;
    a--
  )
    o.pop();
  if (a < 0) (t = 0), (o = [0]);
  else {
    for (t = -1; o[0] === 0; t -= We) o.shift();
    for (r = 1, i = o[0]; i >= 10; i /= 10) r++;
    r < We && (t -= We - r);
  }
  return (s.e = t), (s.d = o), s;
}
function dC(n) {
  return ke((n = new this(n)), n.e + 1, this.rounding);
}
function pC(n) {
  return (n = new this(n)), n.d ? (n.d[0] ? n.s : 0 * n.s) : n.s || NaN;
}
function mC(n) {
  return new this(n).sin();
}
function gC(n) {
  return new this(n).sinh();
}
function vC(n) {
  return new this(n).sqrt();
}
function yC(n, e) {
  return new this(n).sub(e);
}
function xC() {
  var n = 0,
    e = arguments,
    t = new this(e[n]);
  for (je = !1; t.s && ++n < e.length; ) t = t.plus(e[n]);
  return (je = !0), ke(t, this.precision, this.rounding);
}
function bC(n) {
  return new this(n).tan();
}
function _C(n) {
  return new this(n).tanh();
}
function wC(n) {
  return ke((n = new this(n)), n.e + 1, 1);
}
xe[Symbol.for("nodejs.util.inspect.custom")] = xe.toString;
xe[Symbol.toStringTag] = "Decimal";
var eu = (xe.constructor = p0(Ec));
Ro = new eu(Ro);
Fo = new eu(Fo);
function Xn(n, e, t) {
  if (!(this instanceof Xn))
    throw new SyntaxError("Constructor must be called with the new operator");
  (this.index = n),
    arguments.length < 3
      ? ((this.min = 0), (this.max = e))
      : ((this.min = e), (this.max = t)),
    this.min !== void 0 && this.index < this.min
      ? (this.message =
          "Index out of range (" + this.index + " < " + this.min + ")")
      : this.max !== void 0 && this.index >= this.max
      ? (this.message =
          "Index out of range (" + this.index + " > " + (this.max - 1) + ")")
      : (this.message = "Index out of range (" + this.index + ")"),
    (this.stack = new Error().stack);
}
Xn.prototype = new RangeError();
Xn.prototype.constructor = RangeError;
Xn.prototype.name = "IndexError";
Xn.prototype.isIndexError = !0;
function _a(n, e, t) {
  if (!(this instanceof _a))
    throw new SyntaxError("Constructor must be called with the new operator");
  (this.actual = n),
    (this.expected = e),
    (this.relation = t),
    (this.message =
      "Dimension mismatch (" +
      (Array.isArray(n) ? "[" + n.join(", ") + "]" : n) +
      " " +
      (this.relation || "!=") +
      " " +
      (Array.isArray(e) ? "[" + e.join(", ") + "]" : e) +
      ")"),
    (this.stack = new Error().stack);
}
_a.prototype = new RangeError();
_a.prototype.constructor = RangeError;
_a.prototype.name = "DimensionError";
_a.prototype.isDimensionError = !0;
function mi(n) {
  for (var e = []; Array.isArray(n); ) e.push(n.length), (n = n[0]);
  return e;
}
function oi(n) {
  if (!Array.isArray(n)) return n;
  var e = [];
  return (
    n.forEach(function t(r) {
      Array.isArray(r) ? r.forEach(t) : e.push(r);
    }),
    e
  );
}
function cr(n, e) {
  return Array.prototype.map.call(n, e);
}
function tu(n, e) {
  Array.prototype.forEach.call(n, e);
}
function m0(n, e) {
  if (mi(n).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(n, e);
}
function Lo(n, e) {
  if (mi(n).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(n, (t) => e.test(t));
}
function Qh(n, e) {
  return Array.prototype.join.call(n, e);
}
function g0(n) {
  var e = n.length,
    t = n[0].length,
    r,
    i,
    a = [];
  for (i = 0; i < t; i++) {
    var s = [];
    for (r = 0; r < e; r++) s.push(n[r][i]);
    a.push(s);
  }
  return a;
}
function wa(n) {
  for (var e = 0; e < n.length; e++) if (si(n[e])) return !0;
  return !1;
}
function dr(n, e) {
  tn(n) && (n = n.valueOf());
  for (var t = 0, r = n.length; t < r; t++) {
    var i = n[t];
    Array.isArray(i) ? dr(i, e) : e(i);
  }
}
function Sn(n, e, t) {
  return n && typeof n.map == "function"
    ? n.map(function (r) {
        return Sn(r, e);
      })
    : e(n);
}
function nu(n, e, t) {
  var r = Array.isArray(n) ? mi(n) : n.size();
  if (e < 0 || e >= r.length) throw new Xn(e, r.length);
  return tn(n) ? n.create(Io(n.valueOf(), e, t)) : Io(n, e, t);
}
function Io(n, e, t) {
  var r, i, a, s;
  if (e <= 0)
    if (Array.isArray(n[0])) {
      for (s = g0(n), i = [], r = 0; r < s.length; r++)
        i[r] = Io(s[r], e - 1, t);
      return i;
    } else {
      for (a = n[0], r = 1; r < n.length; r++) a = t(a, n[r]);
      return a;
    }
  else {
    for (i = [], r = 0; r < n.length; r++) i[r] = Io(n[r], e - 1, t);
    return i;
  }
}
var ed = "ceil",
  EC = me(ed, ["typed", "config", "round"], (n) => {
    var { typed: e, config: t, round: r } = n;
    return e(ed, {
      number: function (a) {
        return qn(a, r(a), t.epsilon) ? r(a) : Math.ceil(a);
      },
      "number, number": function (a, s) {
        if (qn(a, r(a, s), t.epsilon)) return r(a, s);
        var [o, c] = "".concat(a, "e").split("e"),
          u = Math.ceil(Number("".concat(o, "e").concat(Number(c) + s)));
        return (
          ([o, c] = "".concat(u, "e").split("e")),
          Number("".concat(o, "e").concat(Number(c) - s))
        );
      },
    });
  }),
  td = "fix",
  SC = me(td, ["typed", "ceil", "floor"], (n) => {
    var { typed: e, ceil: t, floor: r } = n;
    return e(td, {
      number: function (a) {
        return a > 0 ? r(a) : t(a);
      },
      "number, number": function (a, s) {
        return a > 0 ? r(a, s) : t(a, s);
      },
    });
  }),
  nd = "floor",
  MC = me(nd, ["typed", "config", "round"], (n) => {
    var { typed: e, config: t, round: r } = n;
    return e(nd, {
      number: function (a) {
        return qn(a, r(a), t.epsilon) ? r(a) : Math.floor(a);
      },
      "number, number": function (a, s) {
        if (qn(a, r(a, s), t.epsilon)) return r(a, s);
        var [o, c] = "".concat(a, "e").split("e"),
          u = Math.floor(Number("".concat(o, "e").concat(Number(c) + s)));
        return (
          ([o, c] = "".concat(u, "e").split("e")),
          Number("".concat(o, "e").concat(Number(c) - s))
        );
      },
    });
  }),
  rd = "hypot",
  AC = [
    "typed",
    "abs",
    "addScalar",
    "divideScalar",
    "multiplyScalar",
    "sqrt",
    "smaller",
    "isPositive",
  ],
  DC = me(rd, AC, (n) => {
    var {
      typed: e,
      abs: t,
      addScalar: r,
      divideScalar: i,
      multiplyScalar: a,
      sqrt: s,
      smaller: o,
      isPositive: c,
    } = n;
    return e(rd, {
      "... number | BigNumber": u,
      Array: u,
      Matrix: (l) => u(oi(l.toArray())),
    });
    function u(l) {
      for (var f = 0, h = 0, d = 0; d < l.length; d++) {
        if (ya(l[d]))
          throw new TypeError("Unexpected type of argument to hypot");
        var g = t(l[d]);
        o(h, g)
          ? ((f = a(f, a(i(h, g), i(h, g)))), (f = r(f, 1)), (h = g))
          : (f = r(f, c(g) ? a(i(g, h), i(g, h)) : g));
      }
      return a(h, s(f));
    }
  }),
  id = "stirlingS2",
  TC = [
    "typed",
    "addScalar",
    "subtractScalar",
    "multiplyScalar",
    "divideScalar",
    "pow",
    "factorial",
    "combinations",
    "isNegative",
    "isInteger",
    "number",
    "?bignumber",
    "larger",
  ],
  CC = me(id, TC, (n) => {
    var {
        typed: e,
        addScalar: t,
        subtractScalar: r,
        multiplyScalar: i,
        divideScalar: a,
        pow: s,
        factorial: o,
        combinations: c,
        isNegative: u,
        isInteger: l,
        number: f,
        bignumber: h,
        larger: d,
      } = n,
      g = [],
      x = [];
    return e(id, {
      "number | BigNumber, number | BigNumber": function (p, S) {
        if (!l(p) || u(p) || !l(S) || u(S))
          throw new TypeError(
            "Non-negative integer value expected in function stirlingS2"
          );
        if (d(S, p))
          throw new TypeError(
            "k must be less than or equal to n in function stirlingS2"
          );
        var v = !(Dt(p) && Dt(S)),
          y = v ? x : g,
          E = v ? h : f,
          M = f(p),
          T = f(S);
        if (y[M] && y[M].length > T) return y[M][T];
        for (var N = 0; N <= M; ++N)
          if ((y[N] || (y[N] = [E(N === 0 ? 1 : 0)]), N !== 0))
            for (
              var A = y[N], D = y[N - 1], z = A.length;
              z <= N && z <= T;
              ++z
            )
              z === N ? (A[z] = 1) : (A[z] = t(i(E(z), D[z]), D[z - 1]));
        return y[M][T];
      },
    });
  }),
  ad = "bellNumbers",
  NC = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"],
  RC = me(ad, NC, (n) => {
    var {
      typed: e,
      addScalar: t,
      isNegative: r,
      isInteger: i,
      stirlingS2: a,
    } = n;
    return e(ad, {
      "number | BigNumber": function (o) {
        if (!i(o) || r(o))
          throw new TypeError(
            "Non-negative integer value expected in function bellNumbers"
          );
        for (var c = 0, u = 0; u <= o; u++) c = t(c, a(o, u));
        return c;
      },
    });
  }),
  sd = "catalan",
  FC = [
    "typed",
    "addScalar",
    "divideScalar",
    "multiplyScalar",
    "combinations",
    "isNegative",
    "isInteger",
  ],
  PC = me(sd, FC, (n) => {
    var {
      typed: e,
      addScalar: t,
      divideScalar: r,
      multiplyScalar: i,
      combinations: a,
      isNegative: s,
      isInteger: o,
    } = n;
    return e(sd, {
      "number | BigNumber": function (u) {
        if (!o(u) || s(u))
          throw new TypeError(
            "Non-negative integer value expected in function catalan"
          );
        return r(a(i(u, 2), u), t(u, 1));
      },
    });
  }),
  od = "composition",
  LC = [
    "typed",
    "addScalar",
    "combinations",
    "isNegative",
    "isPositive",
    "isInteger",
    "larger",
  ],
  IC = me(od, LC, (n) => {
    var {
      typed: e,
      addScalar: t,
      combinations: r,
      isPositive: i,
      isNegative: a,
      isInteger: s,
      larger: o,
    } = n;
    return e(od, {
      "number | BigNumber, number | BigNumber": function (u, l) {
        if (!s(u) || !i(u) || !s(l) || !i(l))
          throw new TypeError(
            "Positive integer value expected in function composition"
          );
        if (o(l, u))
          throw new TypeError(
            "k must be less than or equal to n in function composition"
          );
        return r(t(u, -1), t(l, -1));
      },
    });
  }),
  OC = "12.4.3";
function UC(n) {
  var e = 0,
    t = 1,
    r = Object.create(null),
    i = Object.create(null),
    a = 0,
    s = function (c) {
      var u = i[c];
      if (u && (delete r[u], delete i[c], --e, t === u)) {
        if (!e) {
          (a = 0), (t = 1);
          return;
        }
        for (; !Object.prototype.hasOwnProperty.call(r, ++t); );
      }
    };
  return (
    (n = Math.abs(n)),
    {
      hit: function (c) {
        var u = i[c],
          l = ++a;
        if (((r[l] = c), (i[c] = l), !u))
          return ++e, e <= n ? void 0 : ((c = r[t]), s(c), c);
        if ((delete r[u], t === u))
          for (; !Object.prototype.hasOwnProperty.call(r, ++t); );
      },
      delete: s,
      clear: function () {
        (e = a = 0),
          (t = 1),
          (r = Object.create(null)),
          (i = Object.create(null));
      },
    }
  );
}
function ru(n) {
  var { hasher: e, limit: t } =
    arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return (
    (t = t ?? Number.POSITIVE_INFINITY),
    (e = e ?? JSON.stringify),
    function r() {
      typeof r.cache != "object" &&
        (r.cache = {
          values: new Map(),
          lru: UC(t || Number.POSITIVE_INFINITY),
        });
      for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a];
      var s = e(i);
      if (r.cache.values.has(s))
        return r.cache.lru.hit(s), r.cache.values.get(s);
      var o = n.apply(n, i);
      return (
        r.cache.values.set(s, o), r.cache.values.delete(r.cache.lru.hit(s)), o
      );
    }
  );
}
var BC = ru(
    function (n) {
      return new n(1).exp();
    },
    { hasher: iu }
  ),
  zC = ru(
    function (n) {
      return new n(1).plus(new n(5).sqrt()).div(2);
    },
    { hasher: iu }
  ),
  v0 = ru(
    function (n) {
      return n.acos(-1);
    },
    { hasher: iu }
  ),
  kC = ru(
    function (n) {
      return v0(n).times(2);
    },
    { hasher: iu }
  );
function iu(n) {
  return n[0].precision;
}
var HC = me("true", [], () => !0),
  GC = me("false", [], () => !1),
  VC = me("null", [], () => null),
  WC = Mn("Infinity", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t(1 / 0) : 1 / 0;
  }),
  qC = Mn("NaN", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t(NaN) : NaN;
  }),
  $C = Mn("pi", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? v0(t) : ZE;
  }),
  jC = Mn("tau", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? kC(t) : JE;
  }),
  XC = Mn("e", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? BC(t) : KE;
  }),
  YC = Mn("phi", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? zC(t) : QE;
  }),
  ZC = Mn("LN2", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t(2).ln() : Math.LN2;
  }),
  JC = Mn("LN10", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t(10).ln() : Math.LN10;
  }),
  KC = Mn("LOG2E", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t(1).div(new t(2).ln()) : Math.LOG2E;
  }),
  QC = Mn("LOG10E", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber"
      ? new t(1).div(new t(10).ln())
      : Math.LOG10E;
  }),
  eN = Mn("SQRT1_2", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t("0.5").sqrt() : Math.SQRT1_2;
  }),
  tN = Mn("SQRT2", ["config", "?BigNumber"], (n) => {
    var { config: e, BigNumber: t } = n;
    return e.number === "BigNumber" ? new t(2).sqrt() : Math.SQRT2;
  }),
  nN = me("PI", ["pi"], (n) => {
    var { pi: e } = n;
    return e;
  }),
  rN = me("E", ["e"], (n) => {
    var { e } = n;
    return e;
  }),
  iN = me("version", [], () => OC);
function Mn(n, e, t) {
  return me(n, e, t, { recreateOnConfigChange: !0 });
}
var aN = "number",
  sN = ["typed"];
function oN(n) {
  var e = n.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (e) {
    var t = { "0b": 2, "0o": 8, "0x": 16 }[e[1]],
      r = e[2],
      i = e[3];
    return { input: n, radix: t, integerPart: r, fractionalPart: i };
  } else return null;
}
function uN(n) {
  for (
    var e = parseInt(n.integerPart, n.radix), t = 0, r = 0;
    r < n.fractionalPart.length;
    r++
  ) {
    var i = parseInt(n.fractionalPart[r], n.radix);
    t += i / Math.pow(n.radix, r + 1);
  }
  var a = e + t;
  if (isNaN(a))
    throw new SyntaxError('String "' + n.input + '" is not a valid number');
  return a;
}
var cN = me(aN, sN, (n) => {
    var { typed: e } = n,
      t = e("number", {
        "": function () {
          return 0;
        },
        number: function (i) {
          return i;
        },
        string: function (i) {
          if (i === "NaN") return NaN;
          var a = oN(i);
          if (a) return uN(a);
          var s = 0,
            o = i.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
          o && ((s = Number(o[2])), (i = o[1]));
          var c = Number(i);
          if (isNaN(c))
            throw new SyntaxError('String "' + i + '" is not a valid number');
          if (o) {
            if (c > 2 ** s - 1)
              throw new SyntaxError('String "'.concat(i, '" is out of range'));
            c >= 2 ** (s - 1) && (c = c - 2 ** s);
          }
          return c;
        },
        BigNumber: function (i) {
          return i.toNumber();
        },
        Fraction: function (i) {
          return i.valueOf();
        },
        Unit: e.referToSelf((r) => (i) => {
          var a = i.clone();
          return (a.value = r(i.value)), a;
        }),
        null: function (i) {
          return 0;
        },
        "Unit, string | Unit": function (i, a) {
          return i.toNumber(a);
        },
        "Array | Matrix": e.referToSelf((r) => (i) => Sn(i, r)),
      });
    return (
      (t.fromJSON = function (r) {
        return parseFloat(r.value);
      }),
      t
    );
  }),
  ud = "string",
  lN = ["typed"],
  fN = me(ud, lN, (n) => {
    var { typed: e } = n;
    return e(ud, {
      "": function () {
        return "";
      },
      number: Ja,
      null: function (r) {
        return "null";
      },
      boolean: function (r) {
        return r + "";
      },
      string: function (r) {
        return r;
      },
      "Array | Matrix": e.referToSelf((t) => (r) => Sn(r, t)),
      any: function (r) {
        return String(r);
      },
    });
  }),
  cd = "boolean",
  hN = ["typed"],
  dN = me(cd, hN, (n) => {
    var { typed: e } = n;
    return e(cd, {
      "": function () {
        return !1;
      },
      boolean: function (r) {
        return r;
      },
      number: function (r) {
        return !!r;
      },
      null: function (r) {
        return !1;
      },
      BigNumber: function (r) {
        return !r.isZero();
      },
      string: function (r) {
        var i = r.toLowerCase();
        if (i === "true") return !0;
        if (i === "false") return !1;
        var a = Number(r);
        if (r !== "" && !isNaN(a)) return !!a;
        throw new Error('Cannot convert "' + r + '" to a boolean');
      },
      "Array | Matrix": e.referToSelf((t) => (r) => Sn(r, t)),
    });
  }),
  ld = "parser",
  pN = ["typed", "Parser"],
  mN = me(ld, pN, (n) => {
    var { typed: e, Parser: t } = n;
    return e(ld, {
      "": function () {
        return new t();
      },
    });
  }),
  y0 = new Set(["end"]),
  gN = "Node",
  vN = ["mathWithTransform"],
  yN = me(
    gN,
    vN,
    (n) => {
      var { mathWithTransform: e } = n;
      function t(i) {
        for (var a of [...y0])
          if (i.has(a))
            throw new Error(
              'Scope contains an illegal symbol, "' +
                a +
                '" is a reserved keyword'
            );
      }
      class r {
        get type() {
          return "Node";
        }
        get isNode() {
          return !0;
        }
        evaluate(a) {
          return this.compile().evaluate(a);
        }
        compile() {
          var a = this._compile(e, {}),
            s = {},
            o = null;
          function c(u) {
            var l = ra(u);
            return t(l), a(l, s, o);
          }
          return { evaluate: c };
        }
        _compile(a, s) {
          throw new Error(
            "Method _compile must be implemented by type " + this.type
          );
        }
        forEach(a) {
          throw new Error("Cannot run forEach on a Node interface");
        }
        map(a) {
          throw new Error("Cannot run map on a Node interface");
        }
        _ifNode(a) {
          if (!at(a))
            throw new TypeError("Callback function must return a Node");
          return a;
        }
        traverse(a) {
          a(this, null, null);
          function s(o, c) {
            o.forEach(function (u, l, f) {
              c(u, l, f), s(u, c);
            });
          }
          s(this, a);
        }
        transform(a) {
          function s(o, c, u) {
            var l = a(o, c, u);
            return l !== o ? l : o.map(s);
          }
          return s(this, null, null);
        }
        filter(a) {
          var s = [];
          return (
            this.traverse(function (o, c, u) {
              a(o, c, u) && s.push(o);
            }),
            s
          );
        }
        clone() {
          throw new Error("Cannot clone a Node interface");
        }
        cloneDeep() {
          return this.map(function (a) {
            return a.cloneDeep();
          });
        }
        equals(a) {
          return a ? this.type === a.type && _c(this, a) : !1;
        }
        toString(a) {
          var s = this._getCustomString(a);
          return typeof s < "u" ? s : this._toString(a);
        }
        _toString() {
          throw new Error("_toString not implemented for " + this.type);
        }
        toJSON() {
          throw new Error(
            "Cannot serialize object: toJSON not implemented by " + this.type
          );
        }
        toHTML(a) {
          var s = this._getCustomString(a);
          return typeof s < "u" ? s : this._toHTML(a);
        }
        _toHTML() {
          throw new Error("_toHTML not implemented for " + this.type);
        }
        toTex(a) {
          var s = this._getCustomString(a);
          return typeof s < "u" ? s : this._toTex(a);
        }
        _toTex(a) {
          throw new Error("_toTex not implemented for " + this.type);
        }
        _getCustomString(a) {
          if (a && typeof a == "object")
            switch (typeof a.handler) {
              case "object":
              case "undefined":
                return;
              case "function":
                return a.handler(this, a);
              default:
                throw new TypeError("Object or function expected as callback");
            }
        }
        getIdentifier() {
          return this.type;
        }
        getContent() {
          return this;
        }
      }
      return r;
    },
    { isClass: !0, isNode: !0 }
  );
function Yn(n) {
  return n && n.isIndexError
    ? new Xn(n.index + 1, n.min + 1, n.max !== void 0 ? n.max + 1 : void 0)
    : n;
}
function x0(n) {
  var { subset: e } = n;
  return function (r, i) {
    try {
      if (Array.isArray(r)) return e(r, i);
      if (r && typeof r.subset == "function") return r.subset(i);
      if (typeof r == "string") return e(r, i);
      if (typeof r == "object") {
        if (!i.isObjectProperty())
          throw new TypeError(
            "Cannot apply a numeric index as object property"
          );
        return on(r, i.getObjectProperty());
      } else
        throw new TypeError("Cannot apply index: unsupported type of object");
    } catch (a) {
      throw Yn(a);
    }
  };
}
var no = "AccessorNode",
  xN = ["subset", "Node"],
  bN = me(
    no,
    xN,
    (n) => {
      var { subset: e, Node: t } = n,
        r = x0({ subset: e });
      function i(s) {
        return !(Pr(s) || pn(s) || Qe(s) || fr(s) || xs(s) || Wn(s) || Rt(s));
      }
      class a extends t {
        constructor(o, c) {
          if ((super(), !at(o)))
            throw new TypeError('Node expected for parameter "object"');
          if (!pi(c))
            throw new TypeError('IndexNode expected for parameter "index"');
          (this.object = o), (this.index = c);
        }
        get name() {
          return this.index
            ? this.index.isObjectProperty()
              ? this.index.getObjectProperty()
              : ""
            : this.object.name || "";
        }
        get type() {
          return no;
        }
        get isAccessorNode() {
          return !0;
        }
        _compile(o, c) {
          var u = this.object._compile(o, c),
            l = this.index._compile(o, c);
          if (this.index.isObjectProperty()) {
            var f = this.index.getObjectProperty();
            return function (d, g, x) {
              return on(u(d, g, x), f);
            };
          } else
            return function (d, g, x) {
              var m = u(d, g, x),
                p = l(d, g, m);
              return r(m, p);
            };
        }
        forEach(o) {
          o(this.object, "object", this), o(this.index, "index", this);
        }
        map(o) {
          return new a(
            this._ifNode(o(this.object, "object", this)),
            this._ifNode(o(this.index, "index", this))
          );
        }
        clone() {
          return new a(this.object, this.index);
        }
        _toString(o) {
          var c = this.object.toString(o);
          return (
            i(this.object) && (c = "(" + c + ")"), c + this.index.toString(o)
          );
        }
        _toHTML(o) {
          var c = this.object.toHTML(o);
          return (
            i(this.object) &&
              (c =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                c +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            c + this.index.toHTML(o)
          );
        }
        _toTex(o) {
          var c = this.object.toTex(o);
          return (
            i(this.object) && (c = "\\left(' + object + '\\right)"),
            c + this.index.toTex(o)
          );
        }
        toJSON() {
          return { mathjs: no, object: this.object, index: this.index };
        }
        static fromJSON(o) {
          return new a(o.object, o.index);
        }
      }
      return Wt(a, "name", no), a;
    },
    { isClass: !0, isNode: !0 }
  ),
  ro = "ArrayNode",
  _N = ["Node"],
  wN = me(
    ro,
    _N,
    (n) => {
      var { Node: e } = n;
      class t extends e {
        constructor(i) {
          if (
            (super(),
            (this.items = i || []),
            !Array.isArray(this.items) || !this.items.every(at))
          )
            throw new TypeError("Array containing Nodes expected");
        }
        get type() {
          return ro;
        }
        get isArrayNode() {
          return !0;
        }
        _compile(i, a) {
          var s = cr(this.items, function (u) {
              return u._compile(i, a);
            }),
            o = i.config.matrix !== "Array";
          if (o) {
            var c = i.matrix;
            return function (l, f, h) {
              return c(
                cr(s, function (d) {
                  return d(l, f, h);
                })
              );
            };
          } else
            return function (l, f, h) {
              return cr(s, function (d) {
                return d(l, f, h);
              });
            };
        }
        forEach(i) {
          for (var a = 0; a < this.items.length; a++) {
            var s = this.items[a];
            i(s, "items[" + a + "]", this);
          }
        }
        map(i) {
          for (var a = [], s = 0; s < this.items.length; s++)
            a[s] = this._ifNode(i(this.items[s], "items[" + s + "]", this));
          return new t(a);
        }
        clone() {
          return new t(this.items.slice(0));
        }
        _toString(i) {
          var a = this.items.map(function (s) {
            return s.toString(i);
          });
          return "[" + a.join(", ") + "]";
        }
        toJSON() {
          return { mathjs: ro, items: this.items };
        }
        static fromJSON(i) {
          return new t(i.items);
        }
        _toHTML(i) {
          var a = this.items.map(function (s) {
            return s.toHTML(i);
          });
          return (
            '<span class="math-parenthesis math-square-parenthesis">[</span>' +
            a.join('<span class="math-separator">,</span>') +
            '<span class="math-parenthesis math-square-parenthesis">]</span>'
          );
        }
        _toTex(i) {
          function a(s, o) {
            var c = s.some(pn) && !s.every(pn),
              u = o || c,
              l = u ? "&" : "\\\\",
              f = s
                .map(function (h) {
                  return h.items ? a(h.items, !o) : h.toTex(i);
                })
                .join(l);
            return c || !u || (u && !o)
              ? "\\begin{bmatrix}" + f + "\\end{bmatrix}"
              : f;
          }
          return a(this.items, !1);
        }
      }
      return Wt(t, "name", ro), t;
    },
    { isClass: !0, isNode: !0 }
  );
function EN(n) {
  var { subset: e, matrix: t } = n;
  return function (i, a, s) {
    try {
      if (Array.isArray(i)) {
        var o = t(i).subset(a, s).valueOf();
        return (
          o.forEach((c, u) => {
            i[u] = c;
          }),
          i
        );
      } else {
        if (i && typeof i.subset == "function") return i.subset(a, s);
        if (typeof i == "string") return e(i, a, s);
        if (typeof i == "object") {
          if (!a.isObjectProperty())
            throw TypeError("Cannot apply a numeric index as object property");
          return us(i, a.getObjectProperty(), s), i;
        } else
          throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (c) {
      throw Yn(c);
    }
  };
}
var io = "AssignmentNode",
  SN = ["subset", "?matrix", "Node"],
  MN = me(
    io,
    SN,
    (n) => {
      var { subset: e, matrix: t, Node: r } = n,
        i = x0({ subset: e }),
        a = EN({ subset: e, matrix: t });
      function s(c, u, l) {
        u || (u = "keep");
        var f = ot(c, u, l),
          h = ot(c.value, u, l);
        return u === "all" || (h !== null && h <= f);
      }
      class o extends r {
        constructor(u, l, f) {
          if (
            (super(),
            (this.object = u),
            (this.index = f ? l : null),
            (this.value = f || l),
            !Rt(u) && !Pr(u))
          )
            throw new TypeError(
              'SymbolNode or AccessorNode expected as "object"'
            );
          if (Rt(u) && u.name === "end")
            throw new Error('Cannot assign to symbol "end"');
          if (this.index && !pi(this.index))
            throw new TypeError('IndexNode expected as "index"');
          if (!at(this.value)) throw new TypeError('Node expected as "value"');
        }
        get name() {
          return this.index
            ? this.index.isObjectProperty()
              ? this.index.getObjectProperty()
              : ""
            : this.object.name || "";
        }
        get type() {
          return io;
        }
        get isAssignmentNode() {
          return !0;
        }
        _compile(u, l) {
          var f = this.object._compile(u, l),
            h = this.index ? this.index._compile(u, l) : null,
            d = this.value._compile(u, l),
            g = this.object.name;
          if (this.index)
            if (this.index.isObjectProperty()) {
              var x = this.index.getObjectProperty();
              return function (y, E, M) {
                var T = f(y, E, M),
                  N = d(y, E, M);
                return us(T, x, N), N;
              };
            } else {
              if (Rt(this.object))
                return function (y, E, M) {
                  var T = f(y, E, M),
                    N = d(y, E, M),
                    A = h(y, E, T);
                  return y.set(g, a(T, A, N)), N;
                };
              var m = this.object.object._compile(u, l);
              if (this.object.index.isObjectProperty()) {
                var p = this.object.index.getObjectProperty();
                return function (y, E, M) {
                  var T = m(y, E, M),
                    N = on(T, p),
                    A = h(y, E, N),
                    D = d(y, E, M);
                  return us(T, p, a(N, A, D)), D;
                };
              } else {
                var S = this.object.index._compile(u, l);
                return function (y, E, M) {
                  var T = m(y, E, M),
                    N = S(y, E, T),
                    A = i(T, N),
                    D = h(y, E, A),
                    z = d(y, E, M);
                  return a(T, N, a(A, D, z)), z;
                };
              }
            }
          else {
            if (!Rt(this.object))
              throw new TypeError("SymbolNode expected as object");
            return function (y, E, M) {
              var T = d(y, E, M);
              return y.set(g, T), T;
            };
          }
        }
        forEach(u) {
          u(this.object, "object", this),
            this.index && u(this.index, "index", this),
            u(this.value, "value", this);
        }
        map(u) {
          var l = this._ifNode(u(this.object, "object", this)),
            f = this.index ? this._ifNode(u(this.index, "index", this)) : null,
            h = this._ifNode(u(this.value, "value", this));
          return new o(l, f, h);
        }
        clone() {
          return new o(this.object, this.index, this.value);
        }
        _toString(u) {
          var l = this.object.toString(u),
            f = this.index ? this.index.toString(u) : "",
            h = this.value.toString(u);
          return (
            s(this, u && u.parenthesis, u && u.implicit) && (h = "(" + h + ")"),
            l + f + " = " + h
          );
        }
        toJSON() {
          return {
            mathjs: io,
            object: this.object,
            index: this.index,
            value: this.value,
          };
        }
        static fromJSON(u) {
          return new o(u.object, u.index, u.value);
        }
        _toHTML(u) {
          var l = this.object.toHTML(u),
            f = this.index ? this.index.toHTML(u) : "",
            h = this.value.toHTML(u);
          return (
            s(this, u && u.parenthesis, u && u.implicit) &&
              (h =
                '<span class="math-paranthesis math-round-parenthesis">(</span>' +
                h +
                '<span class="math-paranthesis math-round-parenthesis">)</span>'),
            l +
              f +
              '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' +
              h
          );
        }
        _toTex(u) {
          var l = this.object.toTex(u),
            f = this.index ? this.index.toTex(u) : "",
            h = this.value.toTex(u);
          return (
            s(this, u && u.parenthesis, u && u.implicit) &&
              (h = "\\left(".concat(h, "\\right)")),
            l + f + "=" + h
          );
        }
      }
      return Wt(o, "name", io), o;
    },
    { isClass: !0, isNode: !0 }
  ),
  ao = "BlockNode",
  AN = ["ResultSet", "Node"],
  DN = me(
    ao,
    AN,
    (n) => {
      var { ResultSet: e, Node: t } = n;
      class r extends t {
        constructor(a) {
          if ((super(), !Array.isArray(a))) throw new Error("Array expected");
          this.blocks = a.map(function (s) {
            var o = s && s.node,
              c = s && s.visible !== void 0 ? s.visible : !0;
            if (!at(o)) throw new TypeError('Property "node" must be a Node');
            if (typeof c != "boolean")
              throw new TypeError('Property "visible" must be a boolean');
            return { node: o, visible: c };
          });
        }
        get type() {
          return ao;
        }
        get isBlockNode() {
          return !0;
        }
        _compile(a, s) {
          var o = cr(this.blocks, function (c) {
            return { evaluate: c.node._compile(a, s), visible: c.visible };
          });
          return function (u, l, f) {
            var h = [];
            return (
              tu(o, function (g) {
                var x = g.evaluate(u, l, f);
                g.visible && h.push(x);
              }),
              new e(h)
            );
          };
        }
        forEach(a) {
          for (var s = 0; s < this.blocks.length; s++)
            a(this.blocks[s].node, "blocks[" + s + "].node", this);
        }
        map(a) {
          for (var s = [], o = 0; o < this.blocks.length; o++) {
            var c = this.blocks[o],
              u = this._ifNode(a(c.node, "blocks[" + o + "].node", this));
            s[o] = { node: u, visible: c.visible };
          }
          return new r(s);
        }
        clone() {
          var a = this.blocks.map(function (s) {
            return { node: s.node, visible: s.visible };
          });
          return new r(a);
        }
        _toString(a) {
          return this.blocks.map(function (s) {
            return s.node.toString(a) + (s.visible ? "" : ";");
          }).join(`
`);
        }
        toJSON() {
          return { mathjs: ao, blocks: this.blocks };
        }
        static fromJSON(a) {
          return new r(a.blocks);
        }
        _toHTML(a) {
          return this.blocks
            .map(function (s) {
              return (
                s.node.toHTML(a) +
                (s.visible ? "" : '<span class="math-separator">;</span>')
              );
            })
            .join('<span class="math-separator"><br /></span>');
        }
        _toTex(a) {
          return this.blocks.map(function (s) {
            return s.node.toTex(a) + (s.visible ? "" : ";");
          }).join(`\\;\\;
`);
        }
      }
      return Wt(r, "name", ao), r;
    },
    { isClass: !0, isNode: !0 }
  ),
  so = "ConditionalNode",
  TN = ["Node"],
  CN = me(
    so,
    TN,
    (n) => {
      var { Node: e } = n;
      function t(i) {
        if (
          typeof i == "number" ||
          typeof i == "boolean" ||
          typeof i == "string"
        )
          return !!i;
        if (i) {
          if (Bt(i)) return !i.isZero();
          if (ya(i)) return !!(i.re || i.im);
          if (jo(i)) return !!i.value;
        }
        if (i == null) return !1;
        throw new TypeError('Unsupported type of condition "' + Vt(i) + '"');
      }
      class r extends e {
        constructor(a, s, o) {
          if ((super(), !at(a)))
            throw new TypeError("Parameter condition must be a Node");
          if (!at(s)) throw new TypeError("Parameter trueExpr must be a Node");
          if (!at(o)) throw new TypeError("Parameter falseExpr must be a Node");
          (this.condition = a), (this.trueExpr = s), (this.falseExpr = o);
        }
        get type() {
          return so;
        }
        get isConditionalNode() {
          return !0;
        }
        _compile(a, s) {
          var o = this.condition._compile(a, s),
            c = this.trueExpr._compile(a, s),
            u = this.falseExpr._compile(a, s);
          return function (f, h, d) {
            return t(o(f, h, d)) ? c(f, h, d) : u(f, h, d);
          };
        }
        forEach(a) {
          a(this.condition, "condition", this),
            a(this.trueExpr, "trueExpr", this),
            a(this.falseExpr, "falseExpr", this);
        }
        map(a) {
          return new r(
            this._ifNode(a(this.condition, "condition", this)),
            this._ifNode(a(this.trueExpr, "trueExpr", this)),
            this._ifNode(a(this.falseExpr, "falseExpr", this))
          );
        }
        clone() {
          return new r(this.condition, this.trueExpr, this.falseExpr);
        }
        _toString(a) {
          var s = a && a.parenthesis ? a.parenthesis : "keep",
            o = ot(this, s, a && a.implicit),
            c = this.condition.toString(a),
            u = ot(this.condition, s, a && a.implicit);
          (s === "all" ||
            this.condition.type === "OperatorNode" ||
            (u !== null && u <= o)) &&
            (c = "(" + c + ")");
          var l = this.trueExpr.toString(a),
            f = ot(this.trueExpr, s, a && a.implicit);
          (s === "all" ||
            this.trueExpr.type === "OperatorNode" ||
            (f !== null && f <= o)) &&
            (l = "(" + l + ")");
          var h = this.falseExpr.toString(a),
            d = ot(this.falseExpr, s, a && a.implicit);
          return (
            (s === "all" ||
              this.falseExpr.type === "OperatorNode" ||
              (d !== null && d <= o)) &&
              (h = "(" + h + ")"),
            c + " ? " + l + " : " + h
          );
        }
        toJSON() {
          return {
            mathjs: so,
            condition: this.condition,
            trueExpr: this.trueExpr,
            falseExpr: this.falseExpr,
          };
        }
        static fromJSON(a) {
          return new r(a.condition, a.trueExpr, a.falseExpr);
        }
        _toHTML(a) {
          var s = a && a.parenthesis ? a.parenthesis : "keep",
            o = ot(this, s, a && a.implicit),
            c = this.condition.toHTML(a),
            u = ot(this.condition, s, a && a.implicit);
          (s === "all" ||
            this.condition.type === "OperatorNode" ||
            (u !== null && u <= o)) &&
            (c =
              '<span class="math-parenthesis math-round-parenthesis">(</span>' +
              c +
              '<span class="math-parenthesis math-round-parenthesis">)</span>');
          var l = this.trueExpr.toHTML(a),
            f = ot(this.trueExpr, s, a && a.implicit);
          (s === "all" ||
            this.trueExpr.type === "OperatorNode" ||
            (f !== null && f <= o)) &&
            (l =
              '<span class="math-parenthesis math-round-parenthesis">(</span>' +
              l +
              '<span class="math-parenthesis math-round-parenthesis">)</span>');
          var h = this.falseExpr.toHTML(a),
            d = ot(this.falseExpr, s, a && a.implicit);
          return (
            (s === "all" ||
              this.falseExpr.type === "OperatorNode" ||
              (d !== null && d <= o)) &&
              (h =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                h +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            c +
              '<span class="math-operator math-conditional-operator">?</span>' +
              l +
              '<span class="math-operator math-conditional-operator">:</span>' +
              h
          );
        }
        _toTex(a) {
          return (
            "\\begin{cases} {" +
            this.trueExpr.toTex(a) +
            "}, &\\quad{\\text{if }\\;" +
            this.condition.toTex(a) +
            "}\\\\{" +
            this.falseExpr.toTex(a) +
            "}, &\\quad{\\text{otherwise}}\\end{cases}"
          );
        }
      }
      return Wt(r, "name", so), r;
    },
    { isClass: !0, isNode: !0 }
  ),
  Dc =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    },
  NN = {
    "{": "\\{",
    "}": "\\}",
    "\\": "\\textbackslash{}",
    "#": "\\#",
    $: "\\$",
    "%": "\\%",
    "&": "\\&",
    "^": "\\textasciicircum{}",
    _: "\\_",
    "~": "\\textasciitilde{}",
  },
  RN = {
    "–": "\\--",
    "—": "\\---",
    " ": "~",
    "	": "\\qquad{}",
    "\r\n": "\\newline{}",
    "\n": "\\newline{}",
  },
  FN = function (e, t) {
    return Dc({}, e, t);
  },
  PN = function (n) {
    for (
      var e =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        t = e.preserveFormatting,
        r = t === void 0 ? !1 : t,
        i = e.escapeMapFn,
        a = i === void 0 ? FN : i,
        s = String(n),
        o = "",
        c = a(Dc({}, NN), r ? Dc({}, RN) : {}),
        u = Object.keys(c),
        l = function () {
          var h = !1;
          u.forEach(function (d, g) {
            h ||
              (s.length >= d.length &&
                s.slice(0, d.length) === d &&
                ((o += c[u[g]]), (s = s.slice(d.length, s.length)), (h = !0)));
          }),
            h || ((o += s.slice(0, 1)), (s = s.slice(1, s.length)));
        };
      s;

    )
      l();
    return o;
  };
const LN = gs(PN);
var Tc = {
    Alpha: "A",
    alpha: "\\alpha",
    Beta: "B",
    beta: "\\beta",
    Gamma: "\\Gamma",
    gamma: "\\gamma",
    Delta: "\\Delta",
    delta: "\\delta",
    Epsilon: "E",
    epsilon: "\\epsilon",
    varepsilon: "\\varepsilon",
    Zeta: "Z",
    zeta: "\\zeta",
    Eta: "H",
    eta: "\\eta",
    Theta: "\\Theta",
    theta: "\\theta",
    vartheta: "\\vartheta",
    Iota: "I",
    iota: "\\iota",
    Kappa: "K",
    kappa: "\\kappa",
    varkappa: "\\varkappa",
    Lambda: "\\Lambda",
    lambda: "\\lambda",
    Mu: "M",
    mu: "\\mu",
    Nu: "N",
    nu: "\\nu",
    Xi: "\\Xi",
    xi: "\\xi",
    Omicron: "O",
    omicron: "o",
    Pi: "\\Pi",
    pi: "\\pi",
    varpi: "\\varpi",
    Rho: "P",
    rho: "\\rho",
    varrho: "\\varrho",
    Sigma: "\\Sigma",
    sigma: "\\sigma",
    varsigma: "\\varsigma",
    Tau: "T",
    tau: "\\tau",
    Upsilon: "\\Upsilon",
    upsilon: "\\upsilon",
    Phi: "\\Phi",
    phi: "\\phi",
    varphi: "\\varphi",
    Chi: "X",
    chi: "\\chi",
    Psi: "\\Psi",
    psi: "\\psi",
    Omega: "\\Omega",
    omega: "\\omega",
    true: "\\mathrm{True}",
    false: "\\mathrm{False}",
    i: "i",
    inf: "\\infty",
    Inf: "\\infty",
    infinity: "\\infty",
    Infinity: "\\infty",
    oo: "\\infty",
    lim: "\\lim",
    undefined: "\\mathbf{?}",
  },
  et = {
    transpose: "^\\top",
    ctranspose: "^H",
    factorial: "!",
    pow: "^",
    dotPow: ".^\\wedge",
    unaryPlus: "+",
    unaryMinus: "-",
    bitNot: "\\~",
    not: "\\neg",
    multiply: "\\cdot",
    divide: "\\frac",
    dotMultiply: ".\\cdot",
    dotDivide: ".:",
    mod: "\\mod",
    add: "+",
    subtract: "-",
    to: "\\rightarrow",
    leftShift: "<<",
    rightArithShift: ">>",
    rightLogShift: ">>>",
    equal: "=",
    unequal: "\\neq",
    smaller: "<",
    larger: ">",
    smallerEq: "\\leq",
    largerEq: "\\geq",
    bitAnd: "\\&",
    bitXor: "\\underline{|}",
    bitOr: "|",
    and: "\\wedge",
    xor: "\\veebar",
    or: "\\vee",
  },
  fd = {
    abs: { 1: "\\left|${args[0]}\\right|" },
    add: { 2: "\\left(${args[0]}".concat(et.add, "${args[1]}\\right)") },
    cbrt: { 1: "\\sqrt[3]{${args[0]}}" },
    ceil: { 1: "\\left\\lceil${args[0]}\\right\\rceil" },
    cube: { 1: "\\left(${args[0]}\\right)^3" },
    divide: { 2: "\\frac{${args[0]}}{${args[1]}}" },
    dotDivide: {
      2: "\\left(${args[0]}".concat(et.dotDivide, "${args[1]}\\right)"),
    },
    dotMultiply: {
      2: "\\left(${args[0]}".concat(et.dotMultiply, "${args[1]}\\right)"),
    },
    dotPow: { 2: "\\left(${args[0]}".concat(et.dotPow, "${args[1]}\\right)") },
    exp: { 1: "\\exp\\left(${args[0]}\\right)" },
    expm1: "\\left(e".concat(et.pow, "{${args[0]}}-1\\right)"),
    fix: { 1: "\\mathrm{${name}}\\left(${args[0]}\\right)" },
    floor: { 1: "\\left\\lfloor${args[0]}\\right\\rfloor" },
    gcd: "\\gcd\\left(${args}\\right)",
    hypot: "\\hypot\\left(${args}\\right)",
    log: {
      1: "\\ln\\left(${args[0]}\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}\\right)",
    },
    log10: { 1: "\\log_{10}\\left(${args[0]}\\right)" },
    log1p: {
      1: "\\ln\\left(${args[0]}+1\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)",
    },
    log2: "\\log_{2}\\left(${args[0]}\\right)",
    mod: { 2: "\\left(${args[0]}".concat(et.mod, "${args[1]}\\right)") },
    multiply: {
      2: "\\left(${args[0]}".concat(et.multiply, "${args[1]}\\right)"),
    },
    norm: { 1: "\\left\\|${args[0]}\\right\\|", 2: void 0 },
    nthRoot: { 2: "\\sqrt[${args[1]}]{${args[0]}}" },
    nthRoots: { 2: "\\{y : $y^{args[1]} = {${args[0]}}\\}" },
    pow: { 2: "\\left(${args[0]}\\right)".concat(et.pow, "{${args[1]}}") },
    round: { 1: "\\left\\lfloor${args[0]}\\right\\rceil", 2: void 0 },
    sign: { 1: "\\mathrm{${name}}\\left(${args[0]}\\right)" },
    sqrt: { 1: "\\sqrt{${args[0]}}" },
    square: { 1: "\\left(${args[0]}\\right)^2" },
    subtract: {
      2: "\\left(${args[0]}".concat(et.subtract, "${args[1]}\\right)"),
    },
    unaryMinus: { 1: "".concat(et.unaryMinus, "\\left(${args[0]}\\right)") },
    unaryPlus: { 1: "".concat(et.unaryPlus, "\\left(${args[0]}\\right)") },
    bitAnd: { 2: "\\left(${args[0]}".concat(et.bitAnd, "${args[1]}\\right)") },
    bitNot: { 1: et.bitNot + "\\left(${args[0]}\\right)" },
    bitOr: { 2: "\\left(${args[0]}".concat(et.bitOr, "${args[1]}\\right)") },
    bitXor: { 2: "\\left(${args[0]}".concat(et.bitXor, "${args[1]}\\right)") },
    leftShift: {
      2: "\\left(${args[0]}".concat(et.leftShift, "${args[1]}\\right)"),
    },
    rightArithShift: {
      2: "\\left(${args[0]}".concat(et.rightArithShift, "${args[1]}\\right)"),
    },
    rightLogShift: {
      2: "\\left(${args[0]}".concat(et.rightLogShift, "${args[1]}\\right)"),
    },
    bellNumbers: { 1: "\\mathrm{B}_{${args[0]}}" },
    catalan: { 1: "\\mathrm{C}_{${args[0]}}" },
    stirlingS2: { 2: "\\mathrm{S}\\left(${args}\\right)" },
    arg: { 1: "\\arg\\left(${args[0]}\\right)" },
    conj: { 1: "\\left(${args[0]}\\right)^*" },
    im: { 1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace" },
    re: { 1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace" },
    and: { 2: "\\left(${args[0]}".concat(et.and, "${args[1]}\\right)") },
    not: { 1: et.not + "\\left(${args[0]}\\right)" },
    or: { 2: "\\left(${args[0]}".concat(et.or, "${args[1]}\\right)") },
    xor: { 2: "\\left(${args[0]}".concat(et.xor, "${args[1]}\\right)") },
    cross: { 2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)" },
    ctranspose: { 1: "\\left(${args[0]}\\right)".concat(et.ctranspose) },
    det: { 1: "\\det\\left(${args[0]}\\right)" },
    dot: { 2: "\\left(${args[0]}\\cdot${args[1]}\\right)" },
    expm: { 1: "\\exp\\left(${args[0]}\\right)" },
    inv: { 1: "\\left(${args[0]}\\right)^{-1}" },
    pinv: { 1: "\\left(${args[0]}\\right)^{+}" },
    sqrtm: { 1: "{${args[0]}}".concat(et.pow, "{\\frac{1}{2}}") },
    trace: { 1: "\\mathrm{tr}\\left(${args[0]}\\right)" },
    transpose: { 1: "\\left(${args[0]}\\right)".concat(et.transpose) },
    combinations: { 2: "\\binom{${args[0]}}{${args[1]}}" },
    combinationsWithRep: {
      2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)",
    },
    factorial: { 1: "\\left(${args[0]}\\right)".concat(et.factorial) },
    gamma: { 1: "\\Gamma\\left(${args[0]}\\right)" },
    lgamma: { 1: "\\ln\\Gamma\\left(${args[0]}\\right)" },
    equal: { 2: "\\left(${args[0]}".concat(et.equal, "${args[1]}\\right)") },
    larger: { 2: "\\left(${args[0]}".concat(et.larger, "${args[1]}\\right)") },
    largerEq: {
      2: "\\left(${args[0]}".concat(et.largerEq, "${args[1]}\\right)"),
    },
    smaller: {
      2: "\\left(${args[0]}".concat(et.smaller, "${args[1]}\\right)"),
    },
    smallerEq: {
      2: "\\left(${args[0]}".concat(et.smallerEq, "${args[1]}\\right)"),
    },
    unequal: {
      2: "\\left(${args[0]}".concat(et.unequal, "${args[1]}\\right)"),
    },
    erf: { 1: "erf\\left(${args[0]}\\right)" },
    max: "\\max\\left(${args}\\right)",
    min: "\\min\\left(${args}\\right)",
    variance: "\\mathrm{Var}\\left(${args}\\right)",
    acos: { 1: "\\cos^{-1}\\left(${args[0]}\\right)" },
    acosh: { 1: "\\cosh^{-1}\\left(${args[0]}\\right)" },
    acot: { 1: "\\cot^{-1}\\left(${args[0]}\\right)" },
    acoth: { 1: "\\coth^{-1}\\left(${args[0]}\\right)" },
    acsc: { 1: "\\csc^{-1}\\left(${args[0]}\\right)" },
    acsch: { 1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)" },
    asec: { 1: "\\sec^{-1}\\left(${args[0]}\\right)" },
    asech: { 1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)" },
    asin: { 1: "\\sin^{-1}\\left(${args[0]}\\right)" },
    asinh: { 1: "\\sinh^{-1}\\left(${args[0]}\\right)" },
    atan: { 1: "\\tan^{-1}\\left(${args[0]}\\right)" },
    atan2: { 2: "\\mathrm{atan2}\\left(${args}\\right)" },
    atanh: { 1: "\\tanh^{-1}\\left(${args[0]}\\right)" },
    cos: { 1: "\\cos\\left(${args[0]}\\right)" },
    cosh: { 1: "\\cosh\\left(${args[0]}\\right)" },
    cot: { 1: "\\cot\\left(${args[0]}\\right)" },
    coth: { 1: "\\coth\\left(${args[0]}\\right)" },
    csc: { 1: "\\csc\\left(${args[0]}\\right)" },
    csch: { 1: "\\mathrm{csch}\\left(${args[0]}\\right)" },
    sec: { 1: "\\sec\\left(${args[0]}\\right)" },
    sech: { 1: "\\mathrm{sech}\\left(${args[0]}\\right)" },
    sin: { 1: "\\sin\\left(${args[0]}\\right)" },
    sinh: { 1: "\\sinh\\left(${args[0]}\\right)" },
    tan: { 1: "\\tan\\left(${args[0]}\\right)" },
    tanh: { 1: "\\tanh\\left(${args[0]}\\right)" },
    to: { 2: "\\left(${args[0]}".concat(et.to, "${args[1]}\\right)") },
    numeric: function (e, t) {
      return e.args[0].toTex();
    },
    number: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)",
    },
    string: {
      0: '\\mathtt{""}',
      1: "\\mathrm{string}\\left(${args[0]}\\right)",
    },
    bignumber: { 0: "0", 1: "\\left(${args[0]}\\right)" },
    complex: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)+".concat(
        Tc.i,
        "\\cdot\\left(${args[1]}\\right)\\right)"
      ),
    },
    matrix: {
      0: "\\begin{bmatrix}\\end{bmatrix}",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(${args[0]}\\right)",
    },
    sparse: {
      0: "\\begin{bsparse}\\end{bsparse}",
      1: "\\left(${args[0]}\\right)",
    },
    unit: {
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)",
    },
  },
  IN = "\\mathrm{${name}}\\left(${args}\\right)",
  hd = { deg: "^\\circ" };
function Cc(n) {
  return LN(n, { preserveFormatting: !0 });
}
function b0(n, e) {
  return (
    (e = typeof e > "u" ? !1 : e),
    e
      ? Ve(hd, n)
        ? hd[n]
        : "\\mathrm{" + Cc(n) + "}"
      : Ve(Tc, n)
      ? Tc[n]
      : Cc(n)
  );
}
var oo = "ConstantNode",
  ON = ["Node"],
  UN = me(
    oo,
    ON,
    (n) => {
      var { Node: e } = n;
      class t extends e {
        constructor(i) {
          super(), (this.value = i);
        }
        get type() {
          return oo;
        }
        get isConstantNode() {
          return !0;
        }
        _compile(i, a) {
          var s = this.value;
          return function () {
            return s;
          };
        }
        forEach(i) {}
        map(i) {
          return this.clone();
        }
        clone() {
          return new t(this.value);
        }
        _toString(i) {
          return hr(this.value, i);
        }
        _toHTML(i) {
          var a = this._toString(i);
          switch (Vt(this.value)) {
            case "number":
            case "BigNumber":
            case "Fraction":
              return '<span class="math-number">' + a + "</span>";
            case "string":
              return '<span class="math-string">' + a + "</span>";
            case "boolean":
              return '<span class="math-boolean">' + a + "</span>";
            case "null":
              return '<span class="math-null-symbol">' + a + "</span>";
            case "undefined":
              return '<span class="math-undefined">' + a + "</span>";
            default:
              return '<span class="math-symbol">' + a + "</span>";
          }
        }
        toJSON() {
          return { mathjs: oo, value: this.value };
        }
        static fromJSON(i) {
          return new t(i.value);
        }
        _toTex(i) {
          var a = this._toString(i),
            s = Vt(this.value);
          switch (s) {
            case "string":
              return "\\mathtt{" + Cc(a) + "}";
            case "number":
            case "BigNumber": {
              var o =
                s === "BigNumber"
                  ? this.value.isFinite()
                  : isFinite(this.value);
              if (!o) return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
              var c = a.toLowerCase().indexOf("e");
              return c !== -1
                ? a.substring(0, c) + "\\cdot10^{" + a.substring(c + 1) + "}"
                : a;
            }
            case "Fraction":
              return this.value.toLatex();
            default:
              return a;
          }
        }
      }
      return Wt(t, "name", oo), t;
    },
    { isClass: !0, isNode: !0 }
  ),
  uo = "FunctionAssignmentNode",
  BN = ["typed", "Node"],
  zN = me(
    uo,
    BN,
    (n) => {
      var { typed: e, Node: t } = n;
      function r(a, s, o) {
        var c = ot(a, s, o),
          u = ot(a.expr, s, o);
        return s === "all" || (u !== null && u <= c);
      }
      class i extends t {
        constructor(s, o, c) {
          if ((super(), typeof s != "string"))
            throw new TypeError('String expected for parameter "name"');
          if (!Array.isArray(o))
            throw new TypeError(
              'Array containing strings or objects expected for parameter "params"'
            );
          if (!at(c)) throw new TypeError('Node expected for parameter "expr"');
          if (y0.has(s))
            throw new Error(
              'Illegal function name, "' + s + '" is a reserved keyword'
            );
          var u = new Set();
          for (var l of o) {
            var f = typeof l == "string" ? l : l.name;
            if (u.has(f))
              throw new Error('Duplicate parameter name "'.concat(f, '"'));
            u.add(f);
          }
          (this.name = s),
            (this.params = o.map(function (h) {
              return (h && h.name) || h;
            })),
            (this.types = o.map(function (h) {
              return (h && h.type) || "any";
            })),
            (this.expr = c);
        }
        get type() {
          return uo;
        }
        get isFunctionAssignmentNode() {
          return !0;
        }
        _compile(s, o) {
          var c = Object.create(o);
          tu(this.params, function (g) {
            c[g] = !0;
          });
          var u = this.expr._compile(s, c),
            l = this.name,
            f = this.params,
            h = Qh(this.types, ","),
            d = l + "(" + Qh(this.params, ", ") + ")";
          return function (x, m, p) {
            var S = {};
            S[h] = function () {
              for (var y = Object.create(m), E = 0; E < f.length; E++)
                y[f[E]] = arguments[E];
              return u(x, y, p);
            };
            var v = e(l, S);
            return (v.syntax = d), x.set(l, v), v;
          };
        }
        forEach(s) {
          s(this.expr, "expr", this);
        }
        map(s) {
          var o = this._ifNode(s(this.expr, "expr", this));
          return new i(this.name, this.params.slice(0), o);
        }
        clone() {
          return new i(this.name, this.params.slice(0), this.expr);
        }
        _toString(s) {
          var o = s && s.parenthesis ? s.parenthesis : "keep",
            c = this.expr.toString(s);
          return (
            r(this, o, s && s.implicit) && (c = "(" + c + ")"),
            this.name + "(" + this.params.join(", ") + ") = " + c
          );
        }
        toJSON() {
          var s = this.types;
          return {
            mathjs: uo,
            name: this.name,
            params: this.params.map(function (o, c) {
              return { name: o, type: s[c] };
            }),
            expr: this.expr,
          };
        }
        static fromJSON(s) {
          return new i(s.name, s.params, s.expr);
        }
        _toHTML(s) {
          for (
            var o = s && s.parenthesis ? s.parenthesis : "keep", c = [], u = 0;
            u < this.params.length;
            u++
          )
            c.push(
              '<span class="math-symbol math-parameter">' +
                En(this.params[u]) +
                "</span>"
            );
          var l = this.expr.toHTML(s);
          return (
            r(this, o, s && s.implicit) &&
              (l =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                l +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            '<span class="math-function">' +
              En(this.name) +
              '</span><span class="math-parenthesis math-round-parenthesis">(</span>' +
              c.join('<span class="math-separator">,</span>') +
              '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' +
              l
          );
        }
        _toTex(s) {
          var o = s && s.parenthesis ? s.parenthesis : "keep",
            c = this.expr.toTex(s);
          return (
            r(this, o, s && s.implicit) &&
              (c = "\\left(".concat(c, "\\right)")),
            "\\mathrm{" +
              this.name +
              "}\\left(" +
              this.params.map(b0).join(",") +
              "\\right)=" +
              c
          );
        }
      }
      return Wt(i, "name", uo), i;
    },
    { isClass: !0, isNode: !0 }
  ),
  co = "IndexNode",
  kN = ["Node", "size"],
  HN = me(
    co,
    kN,
    (n) => {
      var { Node: e, size: t } = n;
      class r extends e {
        constructor(a, s) {
          if (
            (super(),
            (this.dimensions = a),
            (this.dotNotation = s || !1),
            !Array.isArray(a) || !a.every(at))
          )
            throw new TypeError(
              'Array containing Nodes expected for parameter "dimensions"'
            );
          if (this.dotNotation && !this.isObjectProperty())
            throw new Error(
              "dotNotation only applicable for object properties"
            );
        }
        get type() {
          return co;
        }
        get isIndexNode() {
          return !0;
        }
        _compile(a, s) {
          var o = cr(this.dimensions, function (u, l) {
              var f =
                u.filter((g) => g.isSymbolNode && g.name === "end").length > 0;
              if (f) {
                var h = Object.create(s);
                h.end = !0;
                var d = u._compile(a, h);
                return function (x, m, p) {
                  if (!tn(p) && !el(p) && !Fr(p))
                    throw new TypeError(
                      'Cannot resolve "end": context must be a Matrix, Array, or string but is ' +
                        Vt(p)
                    );
                  var S = t(p).valueOf(),
                    v = Object.create(m);
                  return (v.end = S[l]), d(x, v, p);
                };
              } else return u._compile(a, s);
            }),
            c = on(a, "index");
          return function (l, f, h) {
            var d = cr(o, function (g) {
              return g(l, f, h);
            });
            return c(...d);
          };
        }
        forEach(a) {
          for (var s = 0; s < this.dimensions.length; s++)
            a(this.dimensions[s], "dimensions[" + s + "]", this);
        }
        map(a) {
          for (var s = [], o = 0; o < this.dimensions.length; o++)
            s[o] = this._ifNode(
              a(this.dimensions[o], "dimensions[" + o + "]", this)
            );
          return new r(s, this.dotNotation);
        }
        clone() {
          return new r(this.dimensions.slice(0), this.dotNotation);
        }
        isObjectProperty() {
          return (
            this.dimensions.length === 1 &&
            Qe(this.dimensions[0]) &&
            typeof this.dimensions[0].value == "string"
          );
        }
        getObjectProperty() {
          return this.isObjectProperty() ? this.dimensions[0].value : null;
        }
        _toString(a) {
          return this.dotNotation
            ? "." + this.getObjectProperty()
            : "[" + this.dimensions.join(", ") + "]";
        }
        toJSON() {
          return {
            mathjs: co,
            dimensions: this.dimensions,
            dotNotation: this.dotNotation,
          };
        }
        static fromJSON(a) {
          return new r(a.dimensions, a.dotNotation);
        }
        _toHTML(a) {
          for (var s = [], o = 0; o < this.dimensions.length; o++)
            s[o] = this.dimensions[o].toHTML();
          return this.dotNotation
            ? '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' +
                En(this.getObjectProperty()) +
                "</span>"
            : '<span class="math-parenthesis math-square-parenthesis">[</span>' +
                s.join('<span class="math-separator">,</span>') +
                '<span class="math-parenthesis math-square-parenthesis">]</span>';
        }
        _toTex(a) {
          var s = this.dimensions.map(function (o) {
            return o.toTex(a);
          });
          return this.dotNotation
            ? "." + this.getObjectProperty()
            : "_{" + s.join(",") + "}";
        }
      }
      return Wt(r, "name", co), r;
    },
    { isClass: !0, isNode: !0 }
  ),
  lo = "ObjectNode",
  GN = ["Node"],
  VN = me(
    lo,
    GN,
    (n) => {
      var { Node: e } = n;
      class t extends e {
        constructor(i) {
          if (
            (super(),
            (this.properties = i || {}),
            i &&
              (typeof i != "object" ||
                !Object.keys(i).every(function (a) {
                  return at(i[a]);
                })))
          )
            throw new TypeError("Object containing Nodes expected");
        }
        get type() {
          return lo;
        }
        get isObjectNode() {
          return !0;
        }
        _compile(i, a) {
          var s = {};
          for (var o in this.properties)
            if (Ve(this.properties, o)) {
              var c = Zi(o),
                u = JSON.parse(c),
                l = on(this.properties, o);
              s[u] = l._compile(i, a);
            }
          return function (h, d, g) {
            var x = {};
            for (var m in s) Ve(s, m) && (x[m] = s[m](h, d, g));
            return x;
          };
        }
        forEach(i) {
          for (var a in this.properties)
            Ve(this.properties, a) &&
              i(this.properties[a], "properties[" + Zi(a) + "]", this);
        }
        map(i) {
          var a = {};
          for (var s in this.properties)
            Ve(this.properties, s) &&
              (a[s] = this._ifNode(
                i(this.properties[s], "properties[" + Zi(s) + "]", this)
              ));
          return new t(a);
        }
        clone() {
          var i = {};
          for (var a in this.properties)
            Ve(this.properties, a) && (i[a] = this.properties[a]);
          return new t(i);
        }
        _toString(i) {
          var a = [];
          for (var s in this.properties)
            Ve(this.properties, s) &&
              a.push(Zi(s) + ": " + this.properties[s].toString(i));
          return "{" + a.join(", ") + "}";
        }
        toJSON() {
          return { mathjs: lo, properties: this.properties };
        }
        static fromJSON(i) {
          return new t(i.properties);
        }
        _toHTML(i) {
          var a = [];
          for (var s in this.properties)
            Ve(this.properties, s) &&
              a.push(
                '<span class="math-symbol math-property">' +
                  En(s) +
                  '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' +
                  this.properties[s].toHTML(i)
              );
          return (
            '<span class="math-parenthesis math-curly-parenthesis">{</span>' +
            a.join('<span class="math-separator">,</span>') +
            '<span class="math-parenthesis math-curly-parenthesis">}</span>'
          );
        }
        _toTex(i) {
          var a = [];
          for (var s in this.properties)
            Ve(this.properties, s) &&
              a.push(
                "\\mathbf{" + s + ":} & " + this.properties[s].toTex(i) + "\\\\"
              );
          var o =
            "\\left\\{\\begin{array}{ll}" +
            a.join(`
`) +
            "\\end{array}\\right\\}";
          return o;
        }
      }
      return Wt(t, "name", lo), t;
    },
    { isClass: !0, isNode: !0 }
  );
function Wa(n, e) {
  return new Kg(n, new Zo(e), new Set(Object.keys(e)));
}
var fo = "OperatorNode",
  WN = ["Node"],
  qN = me(
    fo,
    WN,
    (n) => {
      var { Node: e } = n;
      function t(a, s) {
        var o = a;
        if (s === "auto") for (; Wn(o); ) o = o.content;
        return Qe(o) ? !0 : Et(o) ? t(o.args[0], s) : !1;
      }
      function r(a, s, o, c, u) {
        var l = ot(a, s, o),
          f = Oa(a, s);
        if (
          s === "all" ||
          (c.length > 2 &&
            a.getIdentifier() !== "OperatorNode:add" &&
            a.getIdentifier() !== "OperatorNode:multiply")
        )
          return c.map(function (D) {
            switch (D.getContent().type) {
              case "ArrayNode":
              case "ConstantNode":
              case "SymbolNode":
              case "ParenthesisNode":
                return !1;
              default:
                return !0;
            }
          });
        var h;
        switch (c.length) {
          case 0:
            h = [];
            break;
          case 1:
            {
              var d = ot(c[0], s, o, a);
              if (u && d !== null) {
                var g, x;
                if (
                  (s === "keep"
                    ? ((g = c[0].getIdentifier()), (x = a.getIdentifier()))
                    : ((g = c[0].getContent().getIdentifier()),
                      (x = a.getContent().getIdentifier())),
                  Fn[l][x].latexLeftParens === !1)
                ) {
                  h = [!1];
                  break;
                }
                if (Fn[d][g].latexParens === !1) {
                  h = [!1];
                  break;
                }
              }
              if (d === null) {
                h = [!1];
                break;
              }
              if (d <= l) {
                h = [!0];
                break;
              }
              h = [!1];
            }
            break;
          case 2:
            {
              var m,
                p = ot(c[0], s, o, a),
                S = ac(a, c[0], s);
              p === null
                ? (m = !1)
                : (p === l && f === "right" && !S) || p < l
                ? (m = !0)
                : (m = !1);
              var v,
                y = ot(c[1], s, o, a),
                E = ac(a, c[1], s);
              if (
                (y === null
                  ? (v = !1)
                  : (y === l && f === "left" && !E) || y < l
                  ? (v = !0)
                  : (v = !1),
                u)
              ) {
                var M, T, N;
                s === "keep"
                  ? ((M = a.getIdentifier()),
                    (T = a.args[0].getIdentifier()),
                    (N = a.args[1].getIdentifier()))
                  : ((M = a.getContent().getIdentifier()),
                    (T = a.args[0].getContent().getIdentifier()),
                    (N = a.args[1].getContent().getIdentifier())),
                  p !== null &&
                    (Fn[l][M].latexLeftParens === !1 && (m = !1),
                    Fn[p][T].latexParens === !1 && (m = !1)),
                  y !== null &&
                    (Fn[l][M].latexRightParens === !1 && (v = !1),
                    Fn[y][N].latexParens === !1 && (v = !1));
              }
              h = [m, v];
            }
            break;
          default:
            (a.getIdentifier() === "OperatorNode:add" ||
              a.getIdentifier() === "OperatorNode:multiply") &&
              (h = c.map(function (D) {
                var z = ot(D, s, o, a),
                  $ = ac(a, D, s),
                  I = Oa(D, s);
                return z === null ? !1 : l === z && f === I && !$ ? !0 : z < l;
              }));
            break;
        }
        if (
          c.length >= 2 &&
          a.getIdentifier() === "OperatorNode:multiply" &&
          a.implicit &&
          s !== "all" &&
          o === "hide"
        )
          for (var A = 1; A < h.length; ++A)
            t(c[A], s) &&
              !h[A - 1] &&
              (s !== "keep" || !Wn(c[A - 1])) &&
              (h[A] = !0);
        return h;
      }
      class i extends e {
        constructor(s, o, c, u, l) {
          if ((super(), typeof s != "string"))
            throw new TypeError('string expected for parameter "op"');
          if (typeof o != "string")
            throw new TypeError('string expected for parameter "fn"');
          if (!Array.isArray(c) || !c.every(at))
            throw new TypeError(
              'Array containing Nodes expected for parameter "args"'
            );
          (this.implicit = u === !0),
            (this.isPercentage = l === !0),
            (this.op = s),
            (this.fn = o),
            (this.args = c || []);
        }
        get type() {
          return fo;
        }
        get isOperatorNode() {
          return !0;
        }
        _compile(s, o) {
          if (typeof this.fn != "string" || !hl(s, this.fn))
            throw s[this.fn]
              ? new Error('No access to function "' + this.fn + '"')
              : new Error(
                  "Function " +
                    this.fn +
                    ' missing in provided namespace "math"'
                );
          var c = on(s, this.fn),
            u = cr(this.args, function (g) {
              return g._compile(s, o);
            });
          if (typeof c == "function" && c.rawArgs === !0) {
            var l = this.args;
            return function (x, m, p) {
              return c(l, s, Wa(x, m));
            };
          } else if (u.length === 1) {
            var f = u[0];
            return function (x, m, p) {
              return c(f(x, m, p));
            };
          } else if (u.length === 2) {
            var h = u[0],
              d = u[1];
            return function (x, m, p) {
              return c(h(x, m, p), d(x, m, p));
            };
          } else
            return function (x, m, p) {
              return c.apply(
                null,
                cr(u, function (S) {
                  return S(x, m, p);
                })
              );
            };
        }
        forEach(s) {
          for (var o = 0; o < this.args.length; o++)
            s(this.args[o], "args[" + o + "]", this);
        }
        map(s) {
          for (var o = [], c = 0; c < this.args.length; c++)
            o[c] = this._ifNode(s(this.args[c], "args[" + c + "]", this));
          return new i(this.op, this.fn, o, this.implicit, this.isPercentage);
        }
        clone() {
          return new i(
            this.op,
            this.fn,
            this.args.slice(0),
            this.implicit,
            this.isPercentage
          );
        }
        isUnary() {
          return this.args.length === 1;
        }
        isBinary() {
          return this.args.length === 2;
        }
        _toString(s) {
          var o = s && s.parenthesis ? s.parenthesis : "keep",
            c = s && s.implicit ? s.implicit : "hide",
            u = this.args,
            l = r(this, o, c, u, !1);
          if (u.length === 1) {
            var f = Oa(this, o),
              h = u[0].toString(s);
            l[0] && (h = "(" + h + ")");
            var d = /[a-zA-Z]+/.test(this.op);
            return f === "right"
              ? this.op + (d ? " " : "") + h
              : f === "left"
              ? h + (d ? " " : "") + this.op
              : h + this.op;
          } else if (u.length === 2) {
            var g = u[0].toString(s),
              x = u[1].toString(s);
            return (
              l[0] && (g = "(" + g + ")"),
              l[1] && (x = "(" + x + ")"),
              this.implicit &&
              this.getIdentifier() === "OperatorNode:multiply" &&
              c === "hide"
                ? g + " " + x
                : g + " " + this.op + " " + x
            );
          } else if (
            u.length > 2 &&
            (this.getIdentifier() === "OperatorNode:add" ||
              this.getIdentifier() === "OperatorNode:multiply")
          ) {
            var m = u.map(function (p, S) {
              return (p = p.toString(s)), l[S] && (p = "(" + p + ")"), p;
            });
            return this.implicit &&
              this.getIdentifier() === "OperatorNode:multiply" &&
              c === "hide"
              ? m.join(" ")
              : m.join(" " + this.op + " ");
          } else return this.fn + "(" + this.args.join(", ") + ")";
        }
        toJSON() {
          return {
            mathjs: fo,
            op: this.op,
            fn: this.fn,
            args: this.args,
            implicit: this.implicit,
            isPercentage: this.isPercentage,
          };
        }
        static fromJSON(s) {
          return new i(s.op, s.fn, s.args, s.implicit, s.isPercentage);
        }
        _toHTML(s) {
          var o = s && s.parenthesis ? s.parenthesis : "keep",
            c = s && s.implicit ? s.implicit : "hide",
            u = this.args,
            l = r(this, o, c, u, !1);
          if (u.length === 1) {
            var f = Oa(this, o),
              h = u[0].toHTML(s);
            return (
              l[0] &&
                (h =
                  '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                  h +
                  '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              f === "right"
                ? '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' +
                  En(this.op) +
                  "</span>" +
                  h
                : h +
                  '<span class="math-operator math-unary-operator math-righthand-unary-operator">' +
                  En(this.op) +
                  "</span>"
            );
          } else if (u.length === 2) {
            var d = u[0].toHTML(s),
              g = u[1].toHTML(s);
            return (
              l[0] &&
                (d =
                  '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                  d +
                  '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              l[1] &&
                (g =
                  '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                  g +
                  '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              this.implicit &&
              this.getIdentifier() === "OperatorNode:multiply" &&
              c === "hide"
                ? d +
                  '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' +
                  g
                : d +
                  '<span class="math-operator math-binary-operator math-explicit-binary-operator">' +
                  En(this.op) +
                  "</span>" +
                  g
            );
          } else {
            var x = u.map(function (m, p) {
              return (
                (m = m.toHTML(s)),
                l[p] &&
                  (m =
                    '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                    m +
                    '<span class="math-parenthesis math-round-parenthesis">)</span>'),
                m
              );
            });
            return u.length > 2 &&
              (this.getIdentifier() === "OperatorNode:add" ||
                this.getIdentifier() === "OperatorNode:multiply")
              ? this.implicit &&
                this.getIdentifier() === "OperatorNode:multiply" &&
                c === "hide"
                ? x.join(
                    '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'
                  )
                : x.join(
                    '<span class="math-operator math-binary-operator math-explicit-binary-operator">' +
                      En(this.op) +
                      "</span>"
                  )
              : '<span class="math-function">' +
                  En(this.fn) +
                  '</span><span class="math-paranthesis math-round-parenthesis">(</span>' +
                  x.join('<span class="math-separator">,</span>') +
                  '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
        }
        _toTex(s) {
          var o = s && s.parenthesis ? s.parenthesis : "keep",
            c = s && s.implicit ? s.implicit : "hide",
            u = this.args,
            l = r(this, o, c, u, !0),
            f = et[this.fn];
          if (((f = typeof f > "u" ? this.op : f), u.length === 1)) {
            var h = Oa(this, o),
              d = u[0].toTex(s);
            return (
              l[0] && (d = "\\left(".concat(d, "\\right)")),
              h === "right" ? f + d : d + f
            );
          } else if (u.length === 2) {
            var g = u[0],
              x = g.toTex(s);
            l[0] && (x = "\\left(".concat(x, "\\right)"));
            var m = u[1],
              p = m.toTex(s);
            l[1] && (p = "\\left(".concat(p, "\\right)"));
            var S;
            switch (
              (o === "keep"
                ? (S = g.getIdentifier())
                : (S = g.getContent().getIdentifier()),
              this.getIdentifier())
            ) {
              case "OperatorNode:divide":
                return f + "{" + x + "}{" + p + "}";
              case "OperatorNode:pow":
                switch (((x = "{" + x + "}"), (p = "{" + p + "}"), S)) {
                  case "ConditionalNode":
                  case "OperatorNode:divide":
                    x = "\\left(".concat(x, "\\right)");
                }
                break;
              case "OperatorNode:multiply":
                if (this.implicit && c === "hide") return x + "~" + p;
            }
            return x + f + p;
          } else if (
            u.length > 2 &&
            (this.getIdentifier() === "OperatorNode:add" ||
              this.getIdentifier() === "OperatorNode:multiply")
          ) {
            var v = u.map(function (y, E) {
              return (
                (y = y.toTex(s)),
                l[E] && (y = "\\left(".concat(y, "\\right)")),
                y
              );
            });
            return this.getIdentifier() === "OperatorNode:multiply" &&
              this.implicit &&
              c === "hide"
              ? v.join("~")
              : v.join(f);
          } else
            return (
              "\\mathrm{" +
              this.fn +
              "}\\left(" +
              u
                .map(function (y) {
                  return y.toTex(s);
                })
                .join(",") +
              "\\right)"
            );
        }
        getIdentifier() {
          return this.type + ":" + this.fn;
        }
      }
      return Wt(i, "name", fo), i;
    },
    { isClass: !0, isNode: !0 }
  ),
  ho = "ParenthesisNode",
  $N = ["Node"],
  jN = me(
    ho,
    $N,
    (n) => {
      var { Node: e } = n;
      class t extends e {
        constructor(i) {
          if ((super(), !at(i)))
            throw new TypeError('Node expected for parameter "content"');
          this.content = i;
        }
        get type() {
          return ho;
        }
        get isParenthesisNode() {
          return !0;
        }
        _compile(i, a) {
          return this.content._compile(i, a);
        }
        getContent() {
          return this.content.getContent();
        }
        forEach(i) {
          i(this.content, "content", this);
        }
        map(i) {
          var a = i(this.content, "content", this);
          return new t(a);
        }
        clone() {
          return new t(this.content);
        }
        _toString(i) {
          return !i || (i && !i.parenthesis) || (i && i.parenthesis === "keep")
            ? "(" + this.content.toString(i) + ")"
            : this.content.toString(i);
        }
        toJSON() {
          return { mathjs: ho, content: this.content };
        }
        static fromJSON(i) {
          return new t(i.content);
        }
        _toHTML(i) {
          return !i || (i && !i.parenthesis) || (i && i.parenthesis === "keep")
            ? '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                this.content.toHTML(i) +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'
            : this.content.toHTML(i);
        }
        _toTex(i) {
          return !i || (i && !i.parenthesis) || (i && i.parenthesis === "keep")
            ? "\\left(".concat(this.content.toTex(i), "\\right)")
            : this.content.toTex(i);
        }
      }
      return Wt(t, "name", ho), t;
    },
    { isClass: !0, isNode: !0 }
  ),
  po = "RangeNode",
  XN = ["Node"],
  YN = me(
    po,
    XN,
    (n) => {
      var { Node: e } = n;
      function t(i, a, s) {
        var o = ot(i, a, s),
          c = {},
          u = ot(i.start, a, s);
        if (((c.start = (u !== null && u <= o) || a === "all"), i.step)) {
          var l = ot(i.step, a, s);
          c.step = (l !== null && l <= o) || a === "all";
        }
        var f = ot(i.end, a, s);
        return (c.end = (f !== null && f <= o) || a === "all"), c;
      }
      class r extends e {
        constructor(a, s, o) {
          if ((super(), !at(a))) throw new TypeError("Node expected");
          if (!at(s)) throw new TypeError("Node expected");
          if (o && !at(o)) throw new TypeError("Node expected");
          if (arguments.length > 3) throw new Error("Too many arguments");
          (this.start = a), (this.end = s), (this.step = o || null);
        }
        get type() {
          return po;
        }
        get isRangeNode() {
          return !0;
        }
        needsEnd() {
          var a = this.filter(function (s) {
            return Rt(s) && s.name === "end";
          });
          return a.length > 0;
        }
        _compile(a, s) {
          var o = a.range,
            c = this.start._compile(a, s),
            u = this.end._compile(a, s);
          if (this.step) {
            var l = this.step._compile(a, s);
            return function (h, d, g) {
              return o(c(h, d, g), u(h, d, g), l(h, d, g));
            };
          } else
            return function (h, d, g) {
              return o(c(h, d, g), u(h, d, g));
            };
        }
        forEach(a) {
          a(this.start, "start", this),
            a(this.end, "end", this),
            this.step && a(this.step, "step", this);
        }
        map(a) {
          return new r(
            this._ifNode(a(this.start, "start", this)),
            this._ifNode(a(this.end, "end", this)),
            this.step && this._ifNode(a(this.step, "step", this))
          );
        }
        clone() {
          return new r(this.start, this.end, this.step && this.step);
        }
        _toString(a) {
          var s = a && a.parenthesis ? a.parenthesis : "keep",
            o = t(this, s, a && a.implicit),
            c,
            u = this.start.toString(a);
          if ((o.start && (u = "(" + u + ")"), (c = u), this.step)) {
            var l = this.step.toString(a);
            o.step && (l = "(" + l + ")"), (c += ":" + l);
          }
          var f = this.end.toString(a);
          return o.end && (f = "(" + f + ")"), (c += ":" + f), c;
        }
        toJSON() {
          return {
            mathjs: po,
            start: this.start,
            end: this.end,
            step: this.step,
          };
        }
        static fromJSON(a) {
          return new r(a.start, a.end, a.step);
        }
        _toHTML(a) {
          var s = a && a.parenthesis ? a.parenthesis : "keep",
            o = t(this, s, a && a.implicit),
            c,
            u = this.start.toHTML(a);
          if (
            (o.start &&
              (u =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                u +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            (c = u),
            this.step)
          ) {
            var l = this.step.toHTML(a);
            o.step &&
              (l =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                l +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
              (c +=
                '<span class="math-operator math-range-operator">:</span>' + l);
          }
          var f = this.end.toHTML(a);
          return (
            o.end &&
              (f =
                '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                f +
                '<span class="math-parenthesis math-round-parenthesis">)</span>'),
            (c +=
              '<span class="math-operator math-range-operator">:</span>' + f),
            c
          );
        }
        _toTex(a) {
          var s = a && a.parenthesis ? a.parenthesis : "keep",
            o = t(this, s, a && a.implicit),
            c = this.start.toTex(a);
          if ((o.start && (c = "\\left(".concat(c, "\\right)")), this.step)) {
            var u = this.step.toTex(a);
            o.step && (u = "\\left(".concat(u, "\\right)")), (c += ":" + u);
          }
          var l = this.end.toTex(a);
          return (
            o.end && (l = "\\left(".concat(l, "\\right)")), (c += ":" + l), c
          );
        }
      }
      return Wt(r, "name", po), r;
    },
    { isClass: !0, isNode: !0 }
  ),
  mo = "RelationalNode",
  ZN = ["Node"],
  JN = me(
    mo,
    ZN,
    (n) => {
      var { Node: e } = n,
        t = {
          equal: "==",
          unequal: "!=",
          smaller: "<",
          larger: ">",
          smallerEq: "<=",
          largerEq: ">=",
        };
      class r extends e {
        constructor(a, s) {
          if ((super(), !Array.isArray(a)))
            throw new TypeError("Parameter conditionals must be an array");
          if (!Array.isArray(s))
            throw new TypeError("Parameter params must be an array");
          if (a.length !== s.length - 1)
            throw new TypeError(
              "Parameter params must contain exactly one more element than parameter conditionals"
            );
          (this.conditionals = a), (this.params = s);
        }
        get type() {
          return mo;
        }
        get isRelationalNode() {
          return !0;
        }
        _compile(a, s) {
          var o = this,
            c = this.params.map((u) => u._compile(a, s));
          return function (l, f, h) {
            for (
              var d, g = c[0](l, f, h), x = 0;
              x < o.conditionals.length;
              x++
            ) {
              (d = g), (g = c[x + 1](l, f, h));
              var m = on(a, o.conditionals[x]);
              if (!m(d, g)) return !1;
            }
            return !0;
          };
        }
        forEach(a) {
          this.params.forEach((s, o) => a(s, "params[" + o + "]", this), this);
        }
        map(a) {
          return new r(
            this.conditionals.slice(),
            this.params.map(
              (s, o) => this._ifNode(a(s, "params[" + o + "]", this)),
              this
            )
          );
        }
        clone() {
          return new r(this.conditionals, this.params);
        }
        _toString(a) {
          for (
            var s = a && a.parenthesis ? a.parenthesis : "keep",
              o = ot(this, s, a && a.implicit),
              c = this.params.map(function (f, h) {
                var d = ot(f, s, a && a.implicit);
                return s === "all" || (d !== null && d <= o)
                  ? "(" + f.toString(a) + ")"
                  : f.toString(a);
              }),
              u = c[0],
              l = 0;
            l < this.conditionals.length;
            l++
          )
            (u += " " + t[this.conditionals[l]]), (u += " " + c[l + 1]);
          return u;
        }
        toJSON() {
          return {
            mathjs: mo,
            conditionals: this.conditionals,
            params: this.params,
          };
        }
        static fromJSON(a) {
          return new r(a.conditionals, a.params);
        }
        _toHTML(a) {
          for (
            var s = a && a.parenthesis ? a.parenthesis : "keep",
              o = ot(this, s, a && a.implicit),
              c = this.params.map(function (f, h) {
                var d = ot(f, s, a && a.implicit);
                return s === "all" || (d !== null && d <= o)
                  ? '<span class="math-parenthesis math-round-parenthesis">(</span>' +
                      f.toHTML(a) +
                      '<span class="math-parenthesis math-round-parenthesis">)</span>'
                  : f.toHTML(a);
              }),
              u = c[0],
              l = 0;
            l < this.conditionals.length;
            l++
          )
            u +=
              '<span class="math-operator math-binary-operator math-explicit-binary-operator">' +
              En(t[this.conditionals[l]]) +
              "</span>" +
              c[l + 1];
          return u;
        }
        _toTex(a) {
          for (
            var s = a && a.parenthesis ? a.parenthesis : "keep",
              o = ot(this, s, a && a.implicit),
              c = this.params.map(function (f, h) {
                var d = ot(f, s, a && a.implicit);
                return s === "all" || (d !== null && d <= o)
                  ? "\\left(" + f.toTex(a) + "\right)"
                  : f.toTex(a);
              }),
              u = c[0],
              l = 0;
            l < this.conditionals.length;
            l++
          )
            u += et[this.conditionals[l]] + c[l + 1];
          return u;
        }
      }
      return Wt(r, "name", mo), r;
    },
    { isClass: !0, isNode: !0 }
  ),
  KN = "SymbolNode",
  QN = ["math", "?Unit", "Node"],
  e3 = me(
    KN,
    QN,
    (n) => {
      var { math: e, Unit: t, Node: r } = n;
      function i(s) {
        return t ? t.isValuelessUnit(s) : !1;
      }
      class a extends r {
        constructor(o) {
          if ((super(), typeof o != "string"))
            throw new TypeError('String expected for parameter "name"');
          this.name = o;
        }
        get type() {
          return "SymbolNode";
        }
        get isSymbolNode() {
          return !0;
        }
        _compile(o, c) {
          var u = this.name;
          if (c[u] === !0)
            return function (f, h, d) {
              return on(h, u);
            };
          if (u in o)
            return function (f, h, d) {
              return f.has(u) ? f.get(u) : on(o, u);
            };
          var l = i(u);
          return function (f, h, d) {
            return f.has(u)
              ? f.get(u)
              : l
              ? new t(null, u)
              : a.onUndefinedSymbol(u);
          };
        }
        forEach(o) {}
        map(o) {
          return this.clone();
        }
        static onUndefinedSymbol(o) {
          throw new Error("Undefined symbol " + o);
        }
        clone() {
          return new a(this.name);
        }
        _toString(o) {
          return this.name;
        }
        _toHTML(o) {
          var c = En(this.name);
          return c === "true" || c === "false"
            ? '<span class="math-symbol math-boolean">' + c + "</span>"
            : c === "i"
            ? '<span class="math-symbol math-imaginary-symbol">' + c + "</span>"
            : c === "Infinity"
            ? '<span class="math-symbol math-infinity-symbol">' + c + "</span>"
            : c === "NaN"
            ? '<span class="math-symbol math-nan-symbol">' + c + "</span>"
            : c === "null"
            ? '<span class="math-symbol math-null-symbol">' + c + "</span>"
            : c === "undefined"
            ? '<span class="math-symbol math-undefined-symbol">' + c + "</span>"
            : '<span class="math-symbol">' + c + "</span>";
        }
        toJSON() {
          return { mathjs: "SymbolNode", name: this.name };
        }
        static fromJSON(o) {
          return new a(o.name);
        }
        _toTex(o) {
          var c = !1;
          typeof e[this.name] > "u" && i(this.name) && (c = !0);
          var u = b0(this.name, c);
          return u[0] === "\\" ? u : " " + u;
        }
      }
      return a;
    },
    { isClass: !0, isNode: !0 }
  ),
  go = "FunctionNode",
  t3 = ["math", "Node", "SymbolNode"],
  n3 = me(
    go,
    t3,
    (n) => {
      var e,
        { math: t, Node: r, SymbolNode: i } = n,
        a = (c) => hr(c, { truncate: 78 });
      function s(c, u, l) {
        for (
          var f = "",
            h = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi,
            d = 0,
            g;
          (g = h.exec(c)) !== null;

        )
          if (((f += c.substring(d, g.index)), (d = g.index), g[0] === "$$"))
            (f += "$"), d++;
          else {
            d += g[0].length;
            var x = u[g[1]];
            if (!x)
              throw new ReferenceError(
                "Template: Property " + g[1] + " does not exist."
              );
            if (g[2] === void 0)
              switch (typeof x) {
                case "string":
                  f += x;
                  break;
                case "object":
                  if (at(x)) f += x.toTex(l);
                  else if (Array.isArray(x))
                    f += x
                      .map(function (m, p) {
                        if (at(m)) return m.toTex(l);
                        throw new TypeError(
                          "Template: " + g[1] + "[" + p + "] is not a Node."
                        );
                      })
                      .join(",");
                  else
                    throw new TypeError(
                      "Template: " +
                        g[1] +
                        " has to be a Node, String or array of Nodes"
                    );
                  break;
                default:
                  throw new TypeError(
                    "Template: " +
                      g[1] +
                      " has to be a Node, String or array of Nodes"
                  );
              }
            else if (at(x[g[2]] && x[g[2]])) f += x[g[2]].toTex(l);
            else
              throw new TypeError(
                "Template: " + g[1] + "[" + g[2] + "] is not a Node."
              );
          }
        return (f += c.slice(d)), f;
      }
      class o extends r {
        constructor(u, l) {
          if ((super(), typeof u == "string" && (u = new i(u)), !at(u)))
            throw new TypeError('Node expected as parameter "fn"');
          if (!Array.isArray(l) || !l.every(at))
            throw new TypeError(
              'Array containing Nodes expected for parameter "args"'
            );
          (this.fn = u), (this.args = l || []);
        }
        get name() {
          return this.fn.name || "";
        }
        get type() {
          return go;
        }
        get isFunctionNode() {
          return !0;
        }
        _compile(u, l) {
          var f = this.args.map((N) => N._compile(u, l));
          if (Rt(this.fn)) {
            var h = this.fn.name;
            if (l[h]) {
              var p = this.args;
              return function (A, D, z) {
                var $ = on(D, h);
                if (typeof $ != "function")
                  throw new TypeError(
                    "Argument '"
                      .concat(h, "' was not a function; received: ")
                      .concat(a($))
                  );
                if ($.rawArgs) return $(p, u, Wa(A, D));
                var I = f.map((G) => G(A, D, z));
                return $.apply($, I);
              };
            } else {
              var d = h in u ? on(u, h) : void 0,
                g = typeof d == "function" && d.rawArgs === !0,
                x = (N) => {
                  var A;
                  if (N.has(h)) A = N.get(h);
                  else if (h in u) A = on(u, h);
                  else return o.onUndefinedFunction(h);
                  if (typeof A == "function") return A;
                  throw new TypeError(
                    "'"
                      .concat(
                        h,
                        `' is not a function; its value is:
  `
                      )
                      .concat(a(A))
                  );
                };
              if (g) {
                var m = this.args;
                return function (A, D, z) {
                  var $ = x(A);
                  return $(m, u, Wa(A, D));
                };
              } else
                switch (f.length) {
                  case 0:
                    return function (A, D, z) {
                      var $ = x(A);
                      return $();
                    };
                  case 1:
                    return function (A, D, z) {
                      var $ = x(A),
                        I = f[0];
                      return $(I(A, D, z));
                    };
                  case 2:
                    return function (A, D, z) {
                      var $ = x(A),
                        I = f[0],
                        G = f[1];
                      return $(I(A, D, z), G(A, D, z));
                    };
                  default:
                    return function (A, D, z) {
                      var $ = x(A),
                        I = f.map((G) => G(A, D, z));
                      return $(...I);
                    };
                }
            }
          } else if (
            Pr(this.fn) &&
            pi(this.fn.index) &&
            this.fn.index.isObjectProperty()
          ) {
            var S = this.fn.object._compile(u, l),
              v = this.fn.index.getObjectProperty(),
              y = this.args;
            return function (A, D, z) {
              var $ = S(A, D, z),
                I = lS($, v);
              if (I != null && I.rawArgs) return I(y, u, Wa(A, D));
              var G = f.map((L) => L(A, D, z));
              return I.apply($, G);
            };
          } else {
            var E = this.fn.toString(),
              M = this.fn._compile(u, l),
              T = this.args;
            return function (A, D, z) {
              var $ = M(A, D, z);
              if (typeof $ != "function")
                throw new TypeError(
                  "Expression '".concat(
                    E,
                    "' did not evaluate to a function; value is:"
                  ) +
                    `
  `.concat(a($))
                );
              if ($.rawArgs) return $(T, u, Wa(A, D));
              var I = f.map((G) => G(A, D, z));
              return $.apply($, I);
            };
          }
        }
        forEach(u) {
          u(this.fn, "fn", this);
          for (var l = 0; l < this.args.length; l++)
            u(this.args[l], "args[" + l + "]", this);
        }
        map(u) {
          for (
            var l = this._ifNode(u(this.fn, "fn", this)), f = [], h = 0;
            h < this.args.length;
            h++
          )
            f[h] = this._ifNode(u(this.args[h], "args[" + h + "]", this));
          return new o(l, f);
        }
        clone() {
          return new o(this.fn, this.args.slice(0));
        }
        toString(u) {
          var l,
            f = this.fn.toString(u);
          return (
            u &&
              typeof u.handler == "object" &&
              Ve(u.handler, f) &&
              (l = u.handler[f](this, u)),
            typeof l < "u" ? l : super.toString(u)
          );
        }
        _toString(u) {
          var l = this.args.map(function (h) {
              return h.toString(u);
            }),
            f = xa(this.fn)
              ? "(" + this.fn.toString(u) + ")"
              : this.fn.toString(u);
          return f + "(" + l.join(", ") + ")";
        }
        toJSON() {
          return { mathjs: go, fn: this.fn, args: this.args };
        }
        _toHTML(u) {
          var l = this.args.map(function (f) {
            return f.toHTML(u);
          });
          return (
            '<span class="math-function">' +
            En(this.fn) +
            '</span><span class="math-paranthesis math-round-parenthesis">(</span>' +
            l.join('<span class="math-separator">,</span>') +
            '<span class="math-paranthesis math-round-parenthesis">)</span>'
          );
        }
        toTex(u) {
          var l;
          return (
            u &&
              typeof u.handler == "object" &&
              Ve(u.handler, this.name) &&
              (l = u.handler[this.name](this, u)),
            typeof l < "u" ? l : super.toTex(u)
          );
        }
        _toTex(u) {
          var l = this.args.map(function (d) {
              return d.toTex(u);
            }),
            f;
          fd[this.name] && (f = fd[this.name]),
            t[this.name] &&
              (typeof t[this.name].toTex == "function" ||
                typeof t[this.name].toTex == "object" ||
                typeof t[this.name].toTex == "string") &&
              (f = t[this.name].toTex);
          var h;
          switch (typeof f) {
            case "function":
              h = f(this, u);
              break;
            case "string":
              h = s(f, this, u);
              break;
            case "object":
              switch (typeof f[l.length]) {
                case "function":
                  h = f[l.length](this, u);
                  break;
                case "string":
                  h = s(f[l.length], this, u);
                  break;
              }
          }
          return typeof h < "u" ? h : s(IN, this, u);
        }
        getIdentifier() {
          return this.type + ":" + this.name;
        }
      }
      return (
        (e = o),
        Wt(o, "name", go),
        Wt(o, "onUndefinedFunction", function (c) {
          throw new Error("Undefined function " + c);
        }),
        Wt(o, "fromJSON", function (c) {
          return new e(c.fn, c.args);
        }),
        o
      );
    },
    { isClass: !0, isNode: !0 }
  ),
  dd = "parse",
  r3 = [
    "typed",
    "numeric",
    "config",
    "AccessorNode",
    "ArrayNode",
    "AssignmentNode",
    "BlockNode",
    "ConditionalNode",
    "ConstantNode",
    "FunctionAssignmentNode",
    "FunctionNode",
    "IndexNode",
    "ObjectNode",
    "OperatorNode",
    "ParenthesisNode",
    "RangeNode",
    "RelationalNode",
    "SymbolNode",
  ],
  i3 = me(dd, r3, (n) => {
    var {
        typed: e,
        numeric: t,
        config: r,
        AccessorNode: i,
        ArrayNode: a,
        AssignmentNode: s,
        BlockNode: o,
        ConditionalNode: c,
        ConstantNode: u,
        FunctionAssignmentNode: l,
        FunctionNode: f,
        IndexNode: h,
        ObjectNode: d,
        OperatorNode: g,
        ParenthesisNode: x,
        RangeNode: m,
        RelationalNode: p,
        SymbolNode: S,
      } = n,
      v = e(dd, {
        string: function (U) {
          return Y(U, {});
        },
        "Array | Matrix": function (U) {
          return y(U, {});
        },
        "string, Object": function (U, R) {
          var re = R.nodes !== void 0 ? R.nodes : {};
          return Y(U, re);
        },
        "Array | Matrix, Object": y,
      });
    function y(_) {
      var U =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        R = U.nodes !== void 0 ? U.nodes : {};
      return Sn(_, function (re) {
        if (typeof re != "string") throw new TypeError("String expected");
        return Y(re, R);
      });
    }
    var E = { NULL: 0, DELIMITER: 1, NUMBER: 2, SYMBOL: 3, UNKNOWN: 4 },
      M = {
        ",": !0,
        "(": !0,
        ")": !0,
        "[": !0,
        "]": !0,
        "{": !0,
        "}": !0,
        '"': !0,
        "'": !0,
        ";": !0,
        "+": !0,
        "-": !0,
        "*": !0,
        ".*": !0,
        "/": !0,
        "./": !0,
        "%": !0,
        "^": !0,
        ".^": !0,
        "~": !0,
        "!": !0,
        "&": !0,
        "|": !0,
        "^|": !0,
        "=": !0,
        ":": !0,
        "?": !0,
        "==": !0,
        "!=": !0,
        "<": !0,
        ">": !0,
        "<=": !0,
        ">=": !0,
        "<<": !0,
        ">>": !0,
        ">>>": !0,
      },
      T = { mod: !0, to: !0, in: !0, and: !0, xor: !0, or: !0, not: !0 },
      N = { true: !0, false: !1, null: null, undefined: void 0 },
      A = ["NaN", "Infinity"],
      D = {
        '"': '"',
        "'": "'",
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: `
`,
        r: "\r",
        t: "	",
      };
    function z() {
      return {
        extraNodes: {},
        expression: "",
        comment: "",
        index: 0,
        token: "",
        tokenType: E.NULL,
        nestingLevel: 0,
        conditionalLevel: null,
      };
    }
    function $(_, U) {
      return _.expression.substr(_.index, U);
    }
    function I(_) {
      return $(_, 1);
    }
    function G(_) {
      _.index++;
    }
    function L(_) {
      return _.expression.charAt(_.index - 1);
    }
    function C(_) {
      return _.expression.charAt(_.index + 1);
    }
    function k(_) {
      for (_.tokenType = E.NULL, _.token = "", _.comment = ""; ; ) {
        if (I(_) === "#")
          for (
            ;
            I(_) !==
              `
` && I(_) !== "";

          )
            (_.comment += I(_)), G(_);
        if (v.isWhitespace(I(_), _.nestingLevel)) G(_);
        else break;
      }
      if (I(_) === "") {
        _.tokenType = E.DELIMITER;
        return;
      }
      if (
        I(_) ===
          `
` &&
        !_.nestingLevel
      ) {
        (_.tokenType = E.DELIMITER), (_.token = I(_)), G(_);
        return;
      }
      var U = I(_),
        R = $(_, 2),
        re = $(_, 3);
      if (re.length === 3 && M[re]) {
        (_.tokenType = E.DELIMITER), (_.token = re), G(_), G(_), G(_);
        return;
      }
      if (R.length === 2 && M[R]) {
        (_.tokenType = E.DELIMITER), (_.token = R), G(_), G(_);
        return;
      }
      if (M[U]) {
        (_.tokenType = E.DELIMITER), (_.token = U), G(_);
        return;
      }
      if (v.isDigitDot(U)) {
        _.tokenType = E.NUMBER;
        var K = $(_, 2);
        if (K === "0b" || K === "0o" || K === "0x") {
          for (
            _.token += I(_), G(_), _.token += I(_), G(_);
            v.isHexDigit(I(_));

          )
            (_.token += I(_)), G(_);
          if (I(_) === ".")
            for (_.token += ".", G(_); v.isHexDigit(I(_)); )
              (_.token += I(_)), G(_);
          else if (I(_) === "i")
            for (_.token += "i", G(_); v.isDigit(I(_)); )
              (_.token += I(_)), G(_);
          return;
        }
        if (I(_) === ".") {
          if (((_.token += I(_)), G(_), !v.isDigit(I(_)))) {
            _.tokenType = E.DELIMITER;
            return;
          }
        } else {
          for (; v.isDigit(I(_)); ) (_.token += I(_)), G(_);
          v.isDecimalMark(I(_), C(_)) && ((_.token += I(_)), G(_));
        }
        for (; v.isDigit(I(_)); ) (_.token += I(_)), G(_);
        if (I(_) === "E" || I(_) === "e") {
          if (v.isDigit(C(_)) || C(_) === "-" || C(_) === "+") {
            if (
              ((_.token += I(_)),
              G(_),
              (I(_) === "+" || I(_) === "-") && ((_.token += I(_)), G(_)),
              !v.isDigit(I(_)))
            )
              throw fe(_, 'Digit expected, got "' + I(_) + '"');
            for (; v.isDigit(I(_)); ) (_.token += I(_)), G(_);
            if (v.isDecimalMark(I(_), C(_)))
              throw fe(_, 'Digit expected, got "' + I(_) + '"');
          } else if (C(_) === ".")
            throw (G(_), fe(_, 'Digit expected, got "' + I(_) + '"'));
        }
        return;
      }
      if (v.isAlpha(I(_), L(_), C(_))) {
        for (; v.isAlpha(I(_), L(_), C(_)) || v.isDigit(I(_)); )
          (_.token += I(_)), G(_);
        Ve(T, _.token) ? (_.tokenType = E.DELIMITER) : (_.tokenType = E.SYMBOL);
        return;
      }
      for (_.tokenType = E.UNKNOWN; I(_) !== ""; ) (_.token += I(_)), G(_);
      throw fe(_, 'Syntax error in part "' + _.token + '"');
    }
    function Z(_) {
      do k(_);
      while (
        _.token ===
        `
`
      );
    }
    function ie(_) {
      _.nestingLevel++;
    }
    function ne(_) {
      _.nestingLevel--;
    }
    (v.isAlpha = function (U, R, re) {
      return (
        v.isValidLatinOrGreek(U) ||
        v.isValidMathSymbol(U, re) ||
        v.isValidMathSymbol(R, U)
      );
    }),
      (v.isValidLatinOrGreek = function (U) {
        return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(U);
      }),
      (v.isValidMathSymbol = function (U, R) {
        return (
          /^[\uD835]$/.test(U) &&
          /^[\uDC00-\uDFFF]$/.test(R) &&
          /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(
            R
          )
        );
      }),
      (v.isWhitespace = function (U, R) {
        return (
          U === " " ||
          U === "	" ||
          (U ===
            `
` &&
            R > 0)
        );
      }),
      (v.isDecimalMark = function (U, R) {
        return U === "." && R !== "/" && R !== "*" && R !== "^";
      }),
      (v.isDigitDot = function (U) {
        return (U >= "0" && U <= "9") || U === ".";
      }),
      (v.isDigit = function (U) {
        return U >= "0" && U <= "9";
      }),
      (v.isHexDigit = function (U) {
        return (
          (U >= "0" && U <= "9") ||
          (U >= "a" && U <= "f") ||
          (U >= "A" && U <= "F")
        );
      });
    function Y(_, U) {
      var R = z();
      ir(R, { expression: _, extraNodes: U }), k(R);
      var re = W(R);
      if (R.token !== "")
        throw R.tokenType === E.DELIMITER
          ? Me(R, "Unexpected operator " + R.token)
          : fe(R, 'Unexpected part "' + R.token + '"');
      return re;
    }
    function W(_) {
      var U,
        R = [],
        re;
      for (
        _.token !== "" &&
        _.token !==
          `
` &&
        _.token !== ";" &&
        ((U = te(_)), _.comment && (U.comment = _.comment));
        _.token ===
          `
` || _.token === ";";

      )
        R.length === 0 &&
          U &&
          ((re = _.token !== ";"), R.push({ node: U, visible: re })),
          k(_),
          _.token !==
            `
` &&
            _.token !== ";" &&
            _.token !== "" &&
            ((U = te(_)),
            _.comment && (U.comment = _.comment),
            (re = _.token !== ";"),
            R.push({ node: U, visible: re }));
      return R.length > 0
        ? new o(R)
        : (U || ((U = new u(void 0)), _.comment && (U.comment = _.comment)), U);
    }
    function te(_) {
      var U,
        R,
        re,
        K,
        le = ve(_);
      if (_.token === "=") {
        if (Rt(le))
          return (U = le.name), Z(_), (re = te(_)), new s(new S(U), re);
        if (Pr(le)) return Z(_), (re = te(_)), new s(le.object, le.index, re);
        if (
          fr(le) &&
          Rt(le.fn) &&
          ((K = !0),
          (R = []),
          (U = le.name),
          le.args.forEach(function (Se, Ye) {
            Rt(Se) ? (R[Ye] = Se.name) : (K = !1);
          }),
          K)
        )
          return Z(_), (re = te(_)), new l(U, R, re);
        throw fe(_, "Invalid left hand side of assignment operator =");
      }
      return le;
    }
    function ve(_) {
      for (var U = be(_); _.token === "?"; ) {
        var R = _.conditionalLevel;
        (_.conditionalLevel = _.nestingLevel), Z(_);
        var re = U,
          K = te(_);
        if (_.token !== ":")
          throw fe(_, "False part of conditional expression expected");
        (_.conditionalLevel = null), Z(_);
        var le = te(_);
        (U = new c(re, K, le)), (_.conditionalLevel = R);
      }
      return U;
    }
    function be(_) {
      for (var U = Ae(_); _.token === "or"; )
        Z(_), (U = new g("or", "or", [U, Ae(_)]));
      return U;
    }
    function Ae(_) {
      for (var U = Fe(_); _.token === "xor"; )
        Z(_), (U = new g("xor", "xor", [U, Fe(_)]));
      return U;
    }
    function Fe(_) {
      for (var U = Pe(_); _.token === "and"; )
        Z(_), (U = new g("and", "and", [U, Pe(_)]));
      return U;
    }
    function Pe(_) {
      for (var U = Te(_); _.token === "|"; )
        Z(_), (U = new g("|", "bitOr", [U, Te(_)]));
      return U;
    }
    function Te(_) {
      for (var U = ze(_); _.token === "^|"; )
        Z(_), (U = new g("^|", "bitXor", [U, ze(_)]));
      return U;
    }
    function ze(_) {
      for (var U = Ee(_); _.token === "&"; )
        Z(_), (U = new g("&", "bitAnd", [U, Ee(_)]));
      return U;
    }
    function Ee(_) {
      for (
        var U = [H(_)],
          R = [],
          re = {
            "==": "equal",
            "!=": "unequal",
            "<": "smaller",
            ">": "larger",
            "<=": "smallerEq",
            ">=": "largerEq",
          };
        Ve(re, _.token);

      ) {
        var K = { name: _.token, fn: re[_.token] };
        R.push(K), Z(_), U.push(H(_));
      }
      return U.length === 1
        ? U[0]
        : U.length === 2
        ? new g(R[0].name, R[0].fn, U)
        : new p(
            R.map((le) => le.fn),
            U
          );
    }
    function H(_) {
      var U, R, re, K;
      U = we(_);
      for (
        var le = {
          "<<": "leftShift",
          ">>": "rightArithShift",
          ">>>": "rightLogShift",
        };
        Ve(le, _.token);

      )
        (R = _.token),
          (re = le[R]),
          Z(_),
          (K = [U, we(_)]),
          (U = new g(R, re, K));
      return U;
    }
    function we(_) {
      var U, R, re, K;
      U = he(_);
      for (var le = { to: "to", in: "to" }; Ve(le, _.token); )
        (R = _.token),
          (re = le[R]),
          Z(_),
          R === "in" && _.token === ""
            ? (U = new g("*", "multiply", [U, new S("in")], !0))
            : ((K = [U, he(_)]), (U = new g(R, re, K)));
      return U;
    }
    function he(_) {
      var U,
        R = [];
      if (
        (_.token === ":" ? (U = new u(1)) : (U = _e(_)),
        _.token === ":" && _.conditionalLevel !== _.nestingLevel)
      ) {
        for (R.push(U); _.token === ":" && R.length < 3; )
          Z(_),
            _.token === ")" ||
            _.token === "]" ||
            _.token === "," ||
            _.token === ""
              ? R.push(new S("end"))
              : R.push(_e(_));
        R.length === 3
          ? (U = new m(R[0], R[2], R[1]))
          : (U = new m(R[0], R[1]));
      }
      return U;
    }
    function _e(_) {
      var U, R, re, K;
      U = ge(_);
      for (var le = { "+": "add", "-": "subtract" }; Ve(le, _.token); ) {
        (R = _.token), (re = le[R]), Z(_);
        var Se = ge(_);
        Se.isPercentage
          ? (K = [U, new g("*", "multiply", [U, Se])])
          : (K = [U, Se]),
          (U = new g(R, re, K));
      }
      return U;
    }
    function ge(_) {
      var U, R, re, K;
      (U = Ue(_)), (R = U);
      for (
        var le = {
          "*": "multiply",
          ".*": "dotMultiply",
          "/": "divide",
          "./": "dotDivide",
        };
        Ve(le, _.token);

      )
        (re = _.token),
          (K = le[re]),
          Z(_),
          (R = Ue(_)),
          (U = new g(re, K, [U, R]));
      return U;
    }
    function Ue(_) {
      var U, R;
      for (
        U = J(_), R = U;
        _.tokenType === E.SYMBOL ||
        (_.token === "in" && Qe(U)) ||
        (_.tokenType === E.NUMBER && !Qe(R) && (!Et(R) || R.op === "!")) ||
        _.token === "(";

      )
        (R = J(_)), (U = new g("*", "multiply", [U, R], !0));
      return U;
    }
    function J(_) {
      for (var U = Q(_), R = U, re = []; _.token === "/" && bc(R); )
        if ((re.push(ir({}, _)), Z(_), _.tokenType === E.NUMBER))
          if (
            (re.push(ir({}, _)),
            Z(_),
            _.tokenType === E.SYMBOL || _.token === "(")
          )
            ir(_, re.pop()),
              re.pop(),
              (R = Q(_)),
              (U = new g("/", "divide", [U, R]));
          else {
            re.pop(), ir(_, re.pop());
            break;
          }
        else {
          ir(_, re.pop());
          break;
        }
      return U;
    }
    function Q(_) {
      var U, R, re, K;
      U = ce(_);
      for (var le = { "%": "mod", mod: "mod" }; Ve(le, _.token); )
        (R = _.token),
          (re = le[R]),
          Z(_),
          R === "%" && _.tokenType === E.DELIMITER && _.token !== "("
            ? (U = new g("/", "divide", [U, new u(100)], !1, !0))
            : ((K = [U, ce(_)]), (U = new g(R, re, K)));
      return U;
    }
    function ce(_) {
      var U,
        R,
        re,
        K = { "-": "unaryMinus", "+": "unaryPlus", "~": "bitNot", not: "not" };
      return Ve(K, _.token)
        ? ((re = K[_.token]),
          (U = _.token),
          Z(_),
          (R = [ce(_)]),
          new g(U, re, R))
        : Ce(_);
    }
    function Ce(_) {
      var U, R, re, K;
      return (
        (U = Ne(_)),
        (_.token === "^" || _.token === ".^") &&
          ((R = _.token),
          (re = R === "^" ? "pow" : "dotPow"),
          Z(_),
          (K = [U, ce(_)]),
          (U = new g(R, re, K))),
        U
      );
    }
    function Ne(_) {
      var U, R, re, K;
      U = w(_);
      for (var le = { "!": "factorial", "'": "ctranspose" }; Ve(le, _.token); )
        (R = _.token),
          (re = le[R]),
          k(_),
          (K = [U]),
          (U = new g(R, re, K)),
          (U = F(_, U));
      return U;
    }
    function w(_) {
      var U = [];
      if (_.tokenType === E.SYMBOL && Ve(_.extraNodes, _.token)) {
        var R = _.extraNodes[_.token];
        if ((k(_), _.token === "(")) {
          if (((U = []), ie(_), k(_), _.token !== ")"))
            for (U.push(te(_)); _.token === ","; ) k(_), U.push(te(_));
          if (_.token !== ")") throw fe(_, "Parenthesis ) expected");
          ne(_), k(_);
        }
        return new R(U);
      }
      return b(_);
    }
    function b(_) {
      var U, R;
      return _.tokenType === E.SYMBOL ||
        (_.tokenType === E.DELIMITER && _.token in T)
        ? ((R = _.token),
          k(_),
          Ve(N, R)
            ? (U = new u(N[R]))
            : A.includes(R)
            ? (U = new u(t(R, "number")))
            : (U = new S(R)),
          (U = F(_, U)),
          U)
        : V(_);
    }
    function F(_, U, R) {
      for (
        var re;
        (_.token === "(" || _.token === "[" || _.token === ".") &&
        (!R || R.includes(_.token));

      )
        if (((re = []), _.token === "("))
          if (Rt(U) || Pr(U)) {
            if ((ie(_), k(_), _.token !== ")"))
              for (re.push(te(_)); _.token === ","; ) k(_), re.push(te(_));
            if (_.token !== ")") throw fe(_, "Parenthesis ) expected");
            ne(_), k(_), (U = new f(U, re));
          } else return U;
        else if (_.token === "[") {
          if ((ie(_), k(_), _.token !== "]"))
            for (re.push(te(_)); _.token === ","; ) k(_), re.push(te(_));
          if (_.token !== "]") throw fe(_, "Parenthesis ] expected");
          ne(_), k(_), (U = new i(U, new h(re)));
        } else {
          k(_);
          var K =
            _.tokenType === E.SYMBOL ||
            (_.tokenType === E.DELIMITER && _.token in T);
          if (!K) throw fe(_, "Property name expected after dot");
          re.push(new u(_.token)), k(_);
          var le = !0;
          U = new i(U, new h(re, le));
        }
      return U;
    }
    function V(_) {
      var U, R;
      return _.token === '"' || _.token === "'"
        ? ((R = j(_, _.token)), (U = new u(R)), (U = F(_, U)), U)
        : X(_);
    }
    function j(_, U) {
      for (var R = ""; I(_) !== "" && I(_) !== U; )
        if (I(_) === "\\") {
          G(_);
          var re = I(_),
            K = D[re];
          if (K !== void 0) (R += K), (_.index += 1);
          else if (re === "u") {
            var le = _.expression.slice(_.index + 1, _.index + 5);
            if (/^[0-9A-Fa-f]{4}$/.test(le))
              (R += String.fromCharCode(parseInt(le, 16))), (_.index += 5);
            else throw fe(_, "Invalid unicode character \\u".concat(le));
          } else throw fe(_, "Bad escape character \\".concat(re));
        } else (R += I(_)), G(_);
      if ((k(_), _.token !== U))
        throw fe(_, "End of string ".concat(U, " expected"));
      return k(_), R;
    }
    function X(_) {
      var U, R, re, K;
      if (_.token === "[") {
        if ((ie(_), k(_), _.token !== "]")) {
          var le = oe(_);
          if (_.token === ";") {
            for (re = 1, R = [le]; _.token === ";"; )
              k(_), _.token !== "]" && ((R[re] = oe(_)), re++);
            if (_.token !== "]") throw fe(_, "End of matrix ] expected");
            ne(_), k(_), (K = R[0].items.length);
            for (var Se = 1; Se < re; Se++)
              if (R[Se].items.length !== K)
                throw Me(
                  _,
                  "Column dimensions mismatch (" +
                    R[Se].items.length +
                    " !== " +
                    K +
                    ")"
                );
            U = new a(R);
          } else {
            if (_.token !== "]") throw fe(_, "End of matrix ] expected");
            ne(_), k(_), (U = le);
          }
        } else ne(_), k(_), (U = new a([]));
        return F(_, U);
      }
      return ee(_);
    }
    function oe(_) {
      for (var U = [te(_)], R = 1; _.token === ","; )
        k(_), _.token !== "]" && _.token !== ";" && ((U[R] = te(_)), R++);
      return new a(U);
    }
    function ee(_) {
      if (_.token === "{") {
        ie(_);
        var U,
          R = {};
        do
          if ((k(_), _.token !== "}")) {
            if (_.token === '"' || _.token === "'") U = j(_, _.token);
            else if (
              _.tokenType === E.SYMBOL ||
              (_.tokenType === E.DELIMITER && _.token in T)
            )
              (U = _.token), k(_);
            else throw fe(_, "Symbol or string expected as object key");
            if (_.token !== ":")
              throw fe(_, "Colon : expected after object key");
            k(_), (R[U] = te(_));
          }
        while (_.token === ",");
        if (_.token !== "}")
          throw fe(_, "Comma , or bracket } expected after object value");
        ne(_), k(_);
        var re = new d(R);
        return (re = F(_, re)), re;
      }
      return q(_);
    }
    function q(_) {
      var U;
      return _.tokenType === E.NUMBER
        ? ((U = _.token), k(_), new u(t(U, r.number)))
        : P(_);
    }
    function P(_) {
      var U;
      if (_.token === "(") {
        if ((ie(_), k(_), (U = te(_)), _.token !== ")"))
          throw fe(_, "Parenthesis ) expected");
        return ne(_), k(_), (U = new x(U)), (U = F(_, U)), U;
      }
      return ue(_);
    }
    function ue(_) {
      throw _.token === ""
        ? fe(_, "Unexpected end of expression")
        : fe(_, "Value expected");
    }
    function ye(_) {
      return _.index - _.token.length + 1;
    }
    function fe(_, U) {
      var R = ye(_),
        re = new SyntaxError(U + " (char " + R + ")");
      return (re.char = R), re;
    }
    function Me(_, U) {
      var R = ye(_),
        re = new SyntaxError(U + " (char " + R + ")");
      return (re.char = R), re;
    }
    return e.addConversion({ from: "string", to: "Node", convert: v }), v;
  }),
  pd = "compile",
  a3 = ["typed", "parse"],
  s3 = me(pd, a3, (n) => {
    var { typed: e, parse: t } = n;
    return e(pd, {
      string: function (i) {
        return t(i).compile();
      },
      "Array | Matrix": function (i) {
        return Sn(i, function (a) {
          return t(a).compile();
        });
      },
    });
  }),
  md = "evaluate",
  o3 = ["typed", "parse"],
  u3 = me(md, o3, (n) => {
    var { typed: e, parse: t } = n;
    return e(md, {
      string: function (i) {
        var a = cs();
        return t(i).compile().evaluate(a);
      },
      "string, Map | Object": function (i, a) {
        return t(i).compile().evaluate(a);
      },
      "Array | Matrix": function (i) {
        var a = cs();
        return Sn(i, function (s) {
          return t(s).compile().evaluate(a);
        });
      },
      "Array | Matrix, Map | Object": function (i, a) {
        return Sn(i, function (s) {
          return t(s).compile().evaluate(a);
        });
      },
    });
  }),
  c3 = "Parser",
  l3 = ["evaluate"],
  f3 = me(
    c3,
    l3,
    (n) => {
      var { evaluate: e } = n;
      function t() {
        if (!(this instanceof t))
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        Object.defineProperty(this, "scope", { value: cs(), writable: !1 });
      }
      return (
        (t.prototype.type = "Parser"),
        (t.prototype.isParser = !0),
        (t.prototype.evaluate = function (r) {
          return e(r, this.scope);
        }),
        (t.prototype.get = function (r) {
          if (this.scope.has(r)) return this.scope.get(r);
        }),
        (t.prototype.getAll = function () {
          return dS(this.scope);
        }),
        (t.prototype.getAllAsMap = function () {
          return this.scope;
        }),
        (t.prototype.set = function (r, i) {
          return this.scope.set(r, i), i;
        }),
        (t.prototype.remove = function (r) {
          this.scope.delete(r);
        }),
        (t.prototype.clear = function () {
          this.scope.clear();
        }),
        t
      );
    },
    { isClass: !0 }
  ),
  gd = "apply",
  h3 = ["typed", "isInteger"],
  ml = me(gd, h3, (n) => {
    var { typed: e, isInteger: t } = n;
    return e(gd, {
      "Array | Matrix, number | BigNumber, function": function (i, a, s) {
        if (!t(a)) throw new TypeError("Integer number expected for dimension");
        var o = Array.isArray(i) ? mi(i) : i.size();
        if (a < 0 || a >= o.length) throw new Xn(a, o.length);
        return tn(i) ? i.create(Oo(i.valueOf(), a, s)) : Oo(i, a, s);
      },
    });
  });
function Oo(n, e, t) {
  var r, i, a;
  if (e <= 0)
    if (Array.isArray(n[0])) {
      for (a = d3(n), i = [], r = 0; r < a.length; r++)
        i[r] = Oo(a[r], e - 1, t);
      return i;
    } else return t(n);
  else {
    for (i = [], r = 0; r < n.length; r++) i[r] = Oo(n[r], e - 1, t);
    return i;
  }
}
function d3(n) {
  var e = n.length,
    t = n[0].length,
    r,
    i,
    a = [];
  for (i = 0; i < t; i++) {
    var s = [];
    for (r = 0; r < e; r++) s.push(n[r][i]);
    a.push(s);
  }
  return a;
}
function Ea(n, e, t, r, i) {
  if (Kr.isTypedFunction(n)) {
    var a = [e, t, r],
      s = Kr.resolve(n, a);
    if (s) return f(s.implementation, a);
    var o = [e, t],
      c = Kr.resolve(n, o);
    if (c) return f(c.implementation, o);
    var u = [e],
      l = Kr.resolve(n, u);
    return l ? f(l.implementation, u) : f(n, a);
  } else return n(e, t, r);
  function f(h, d) {
    try {
      return h.apply(h, d);
    } catch (m) {
      var g;
      if (
        m instanceof TypeError &&
        ((g = m.data) === null || g === void 0 ? void 0 : g.category) ===
          "wrongType"
      ) {
        var x = [];
        throw (
          (x.push("value: ".concat(Vt(e))),
          d.length >= 2 && x.push("index: ".concat(Vt(t))),
          d.length >= 3 && x.push("array: ".concat(Vt(r))),
          new TypeError(
            "Function ".concat(i, " cannot apply callback arguments ") +
              ""
                .concat(n.name, "(")
                .concat(x.join(", "), ") at index ")
                .concat(JSON.stringify(t))
          ))
        );
      } else
        throw new TypeError(
          "Function ".concat(i, " cannot apply callback arguments ") +
            "to function ".concat(n.name, ": ").concat(m.message)
        );
    }
  }
}
var p3 = "filter",
  m3 = ["typed"],
  g3 = me(p3, m3, (n) => {
    var { typed: e } = n;
    return e("filter", {
      "Array, function": vd,
      "Matrix, function": function (r, i) {
        return r.create(vd(r.toArray(), i));
      },
      "Array, RegExp": Lo,
      "Matrix, RegExp": function (r, i) {
        return r.create(Lo(r.toArray(), i));
      },
    });
  });
function vd(n, e) {
  return m0(n, function (t, r, i) {
    return Ea(e, t, [r], i, "filter");
  });
}
var yd = "forEach",
  v3 = ["typed"],
  y3 = me(yd, v3, (n) => {
    var { typed: e } = n;
    return e(yd, {
      "Array, function": x3,
      "Matrix, function": function (r, i) {
        r.forEach(i);
      },
    });
  });
function x3(n, e) {
  var t = function r(i, a) {
    if (Array.isArray(i))
      tu(i, function (s, o) {
        r(s, a.concat(o));
      });
    else return Ea(e, i, a, n, "forEach");
  };
  t(n, []);
}
var xd = "map",
  b3 = ["typed"],
  _3 = me(xd, b3, (n) => {
    var { typed: e } = n;
    return e(xd, {
      "Array, function": w3,
      "Matrix, function": function (r, i) {
        return r.map(i);
      },
    });
  });
function w3(n, e) {
  var t = function r(i, a) {
    return Array.isArray(i)
      ? i.map(function (s, o) {
          return r(s, a.concat(o));
        })
      : Ea(e, i, a, n, "map");
  };
  return t(n, []);
}
var bd = "range",
  E3 = [
    "typed",
    "config",
    "?matrix",
    "?bignumber",
    "smaller",
    "smallerEq",
    "larger",
    "largerEq",
    "add",
    "isPositive",
  ],
  _0 = me(bd, E3, (n) => {
    var {
      typed: e,
      config: t,
      matrix: r,
      bignumber: i,
      smaller: a,
      smallerEq: s,
      larger: o,
      largerEq: c,
      add: u,
      isPositive: l,
    } = n;
    return e(bd, {
      string: h,
      "string, boolean": h,
      "number, number": function (m, p) {
        return f(d(m, p, 1, !1));
      },
      "number, number, number": function (m, p, S) {
        return f(d(m, p, S, !1));
      },
      "number, number, boolean": function (m, p, S) {
        return f(d(m, p, 1, S));
      },
      "number, number, number, boolean": function (m, p, S, v) {
        return f(d(m, p, S, v));
      },
      "BigNumber, BigNumber": function (m, p) {
        var S = m.constructor;
        return f(d(m, p, new S(1), !1));
      },
      "BigNumber, BigNumber, BigNumber": function (m, p, S) {
        return f(d(m, p, S, !1));
      },
      "BigNumber, BigNumber, boolean": function (m, p, S) {
        var v = m.constructor;
        return f(d(m, p, new v(1), S));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function (m, p, S, v) {
        return f(d(m, p, S, v));
      },
      "Unit, Unit, Unit": function (m, p, S) {
        return f(d(m, p, S, !1));
      },
      "Unit, Unit, Unit, boolean": function (m, p, S, v) {
        return f(d(m, p, S, v));
      },
    });
    function f(x) {
      return t.matrix === "Matrix" ? (r ? r(x) : fl()) : x;
    }
    function h(x, m) {
      var p = g(x);
      if (!p) throw new SyntaxError('String "' + x + '" is no valid range');
      return t.number === "BigNumber"
        ? (i === void 0 && ll(), f(d(i(p.start), i(p.end), i(p.step))))
        : f(d(p.start, p.end, p.step, m));
    }
    function d(x, m, p, S) {
      for (var v = [], y = l(p) ? (S ? s : a) : S ? c : o, E = x; y(E, m); )
        v.push(E), (E = u(E, p));
      return v;
    }
    function g(x) {
      var m = x.split(":"),
        p = m.map(function (v) {
          return Number(v);
        }),
        S = p.some(function (v) {
          return isNaN(v);
        });
      if (S) return null;
      switch (p.length) {
        case 2:
          return { start: p[0], end: p[1], step: 1 };
        case 3:
          return { start: p[0], end: p[2], step: p[1] };
        default:
          return null;
      }
    }
  }),
  _d = "size",
  S3 = ["typed", "config", "?matrix"],
  M3 = me(_d, S3, (n) => {
    var { typed: e, config: t, matrix: r } = n;
    return e(_d, {
      Matrix: function (a) {
        return a.create(a.size());
      },
      Array: mi,
      string: function (a) {
        return t.matrix === "Array" ? [a.length] : r([a.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function (a) {
        return t.matrix === "Array" ? [] : r ? r([]) : fl();
      },
    });
  }),
  wd = "partitionSelect",
  A3 = ["typed", "isNumeric", "isNaN", "compare"],
  D3 = me(wd, A3, (n) => {
    var { typed: e, isNumeric: t, isNaN: r, compare: i } = n,
      a = i,
      s = (u, l) => -i(u, l);
    return e(wd, {
      "Array | Matrix, number": function (l, f) {
        return o(l, f, a);
      },
      "Array | Matrix, number, string": function (l, f, h) {
        if (h === "asc") return o(l, f, a);
        if (h === "desc") return o(l, f, s);
        throw new Error('Compare string must be "asc" or "desc"');
      },
      "Array | Matrix, number, function": o,
    });
    function o(u, l, f) {
      if (!rt(l) || l < 0) throw new Error("k must be a non-negative integer");
      if (tn(u)) {
        var h = u.size();
        if (h.length > 1)
          throw new Error("Only one dimensional matrices supported");
        return c(u.valueOf(), l, f);
      }
      if (Array.isArray(u)) return c(u, l, f);
    }
    function c(u, l, f) {
      if (l >= u.length) throw new Error("k out of bounds");
      for (var h = 0; h < u.length; h++) if (t(u[h]) && r(u[h])) return u[h];
      for (var d = 0, g = u.length - 1; d < g; ) {
        for (
          var x = d, m = g, p = u[Math.floor(Math.random() * (g - d + 1)) + d];
          x < m;

        )
          if (f(u[x], p) >= 0) {
            var S = u[m];
            (u[m] = u[x]), (u[x] = S), --m;
          } else ++x;
        f(u[x], p) > 0 && --x, l <= x ? (g = x) : (d = x + 1);
      }
      return u[l];
    }
  }),
  Ed = "combinationsWithRep",
  T3 = ["typed"],
  C3 = me(Ed, T3, (n) => {
    var { typed: e } = n;
    return e(Ed, {
      "number, number": function (r, i) {
        if (!rt(r) || r < 0)
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        if (!rt(i) || i < 0)
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        if (r < 1)
          throw new TypeError("k must be less than or equal to n + k - 1");
        if (i < r - 1) {
          var a = or(r, r + i - 1);
          return a / or(1, i);
        }
        var s = or(i + 1, r + i - 1);
        return s / or(1, r - 1);
      },
      "BigNumber, BigNumber": function (r, i) {
        var a = r.constructor,
          s,
          o,
          c = new a(1),
          u = r.minus(c);
        if (!Sd(r) || !Sd(i))
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        if (r.lt(c))
          throw new TypeError(
            "k must be less than or equal to n + k - 1 in function combinationsWithRep"
          );
        if (((s = c), i.lt(u)))
          for (o = c; o.lte(u); o = o.plus(c))
            s = s.times(i.plus(o)).dividedBy(o);
        else
          for (o = c; o.lte(i); o = o.plus(c))
            s = s.times(u.plus(o)).dividedBy(o);
        return s;
      },
    });
  });
function Sd(n) {
  return n.isInteger() && n.gte(0);
}
var Md = "factorial",
  N3 = ["typed", "gamma"],
  R3 = me(Md, N3, (n) => {
    var { typed: e, gamma: t } = n;
    return e(Md, {
      number: function (i) {
        if (i < 0) throw new Error("Value must be non-negative");
        return t(i + 1);
      },
      BigNumber: function (i) {
        if (i.isNegative()) throw new Error("Value must be non-negative");
        return t(i.plus(1));
      },
      "Array | Matrix": e.referToSelf((r) => (i) => Sn(i, r)),
    });
  }),
  Ad = "multinomial",
  F3 = [
    "typed",
    "add",
    "divide",
    "multiply",
    "factorial",
    "isInteger",
    "isPositive",
  ],
  P3 = me(Ad, F3, (n) => {
    var {
      typed: e,
      add: t,
      divide: r,
      multiply: i,
      factorial: a,
      isInteger: s,
      isPositive: o,
    } = n;
    return e(Ad, {
      "Array | Matrix": function (u) {
        var l = 0,
          f = 1;
        return (
          dr(u, function (h) {
            if (!s(h) || !o(h))
              throw new TypeError(
                "Positive integer value expected in function multinomial"
              );
            (l = t(l, h)), (f = i(f, a(h)));
          }),
          r(a(l), f)
        );
      },
    });
  }),
  Dd = "permutations",
  L3 = ["typed", "factorial"],
  I3 = me(Dd, L3, (n) => {
    var { typed: e, factorial: t } = n;
    return e(Dd, {
      "number | BigNumber": t,
      "number, number": function (i, a) {
        if (!rt(i) || i < 0)
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        if (!rt(a) || a < 0)
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        if (a > i)
          throw new TypeError(
            "second argument k must be less than or equal to first argument n"
          );
        return or(i - a + 1, i);
      },
      "BigNumber, BigNumber": function (i, a) {
        var s, o;
        if (!Td(i) || !Td(a))
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        if (a.gt(i))
          throw new TypeError(
            "second argument k must be less than or equal to first argument n"
          );
        var c = i.mul(0).add(1);
        for (s = c, o = i.minus(a).plus(1); o.lte(i); o = o.plus(1))
          s = s.times(o);
        return s;
      },
    });
  });
function Td(n) {
  return n.isInteger() && n.gte(0);
}
var gl = { exports: {} };
gl.exports;
(function (n) {
  (function (e, t, r) {
    function i(c) {
      var u = this,
        l = o();
      (u.next = function () {
        var f = 2091639 * u.s0 + u.c * 23283064365386963e-26;
        return (u.s0 = u.s1), (u.s1 = u.s2), (u.s2 = f - (u.c = f | 0));
      }),
        (u.c = 1),
        (u.s0 = l(" ")),
        (u.s1 = l(" ")),
        (u.s2 = l(" ")),
        (u.s0 -= l(c)),
        u.s0 < 0 && (u.s0 += 1),
        (u.s1 -= l(c)),
        u.s1 < 0 && (u.s1 += 1),
        (u.s2 -= l(c)),
        u.s2 < 0 && (u.s2 += 1),
        (l = null);
    }
    function a(c, u) {
      return (u.c = c.c), (u.s0 = c.s0), (u.s1 = c.s1), (u.s2 = c.s2), u;
    }
    function s(c, u) {
      var l = new i(c),
        f = u && u.state,
        h = l.next;
      return (
        (h.int32 = function () {
          return (l.next() * 4294967296) | 0;
        }),
        (h.double = function () {
          return h() + ((h() * 2097152) | 0) * 11102230246251565e-32;
        }),
        (h.quick = h),
        f &&
          (typeof f == "object" && a(f, l),
          (h.state = function () {
            return a(l, {});
          })),
        h
      );
    }
    function o() {
      var c = 4022871197,
        u = function (l) {
          l = String(l);
          for (var f = 0; f < l.length; f++) {
            c += l.charCodeAt(f);
            var h = 0.02519603282416938 * c;
            (c = h >>> 0),
              (h -= c),
              (h *= c),
              (c = h >>> 0),
              (h -= c),
              (c += h * 4294967296);
          }
          return (c >>> 0) * 23283064365386963e-26;
        };
      return u;
    }
    t && t.exports
      ? (t.exports = s)
      : r && r.amd
      ? r(function () {
          return s;
        })
      : (this.alea = s);
  })(Ur, n, !1);
})(gl);
var O3 = gl.exports,
  vl = { exports: {} };
vl.exports;
(function (n) {
  (function (e, t, r) {
    function i(o) {
      var c = this,
        u = "";
      (c.x = 0),
        (c.y = 0),
        (c.z = 0),
        (c.w = 0),
        (c.next = function () {
          var f = c.x ^ (c.x << 11);
          return (
            (c.x = c.y),
            (c.y = c.z),
            (c.z = c.w),
            (c.w ^= (c.w >>> 19) ^ f ^ (f >>> 8))
          );
        }),
        o === (o | 0) ? (c.x = o) : (u += o);
      for (var l = 0; l < u.length + 64; l++)
        (c.x ^= u.charCodeAt(l) | 0), c.next();
    }
    function a(o, c) {
      return (c.x = o.x), (c.y = o.y), (c.z = o.z), (c.w = o.w), c;
    }
    function s(o, c) {
      var u = new i(o),
        l = c && c.state,
        f = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (f.double = function () {
          do
            var h = u.next() >>> 11,
              d = (u.next() >>> 0) / 4294967296,
              g = (h + d) / (1 << 21);
          while (g === 0);
          return g;
        }),
        (f.int32 = u.next),
        (f.quick = f),
        l &&
          (typeof l == "object" && a(l, u),
          (f.state = function () {
            return a(u, {});
          })),
        f
      );
    }
    t && t.exports
      ? (t.exports = s)
      : r && r.amd
      ? r(function () {
          return s;
        })
      : (this.xor128 = s);
  })(Ur, n, !1);
})(vl);
var U3 = vl.exports,
  yl = { exports: {} };
yl.exports;
(function (n) {
  (function (e, t, r) {
    function i(o) {
      var c = this,
        u = "";
      (c.next = function () {
        var f = c.x ^ (c.x >>> 2);
        return (
          (c.x = c.y),
          (c.y = c.z),
          (c.z = c.w),
          (c.w = c.v),
          ((c.d = (c.d + 362437) | 0) +
            (c.v = c.v ^ (c.v << 4) ^ (f ^ (f << 1)))) |
            0
        );
      }),
        (c.x = 0),
        (c.y = 0),
        (c.z = 0),
        (c.w = 0),
        (c.v = 0),
        o === (o | 0) ? (c.x = o) : (u += o);
      for (var l = 0; l < u.length + 64; l++)
        (c.x ^= u.charCodeAt(l) | 0),
          l == u.length && (c.d = (c.x << 10) ^ (c.x >>> 4)),
          c.next();
    }
    function a(o, c) {
      return (
        (c.x = o.x),
        (c.y = o.y),
        (c.z = o.z),
        (c.w = o.w),
        (c.v = o.v),
        (c.d = o.d),
        c
      );
    }
    function s(o, c) {
      var u = new i(o),
        l = c && c.state,
        f = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (f.double = function () {
          do
            var h = u.next() >>> 11,
              d = (u.next() >>> 0) / 4294967296,
              g = (h + d) / (1 << 21);
          while (g === 0);
          return g;
        }),
        (f.int32 = u.next),
        (f.quick = f),
        l &&
          (typeof l == "object" && a(l, u),
          (f.state = function () {
            return a(u, {});
          })),
        f
      );
    }
    t && t.exports
      ? (t.exports = s)
      : r && r.amd
      ? r(function () {
          return s;
        })
      : (this.xorwow = s);
  })(Ur, n, !1);
})(yl);
var B3 = yl.exports,
  xl = { exports: {} };
xl.exports;
(function (n) {
  (function (e, t, r) {
    function i(o) {
      var c = this;
      c.next = function () {
        var l = c.x,
          f = c.i,
          h,
          d;
        return (
          (h = l[f]),
          (h ^= h >>> 7),
          (d = h ^ (h << 24)),
          (h = l[(f + 1) & 7]),
          (d ^= h ^ (h >>> 10)),
          (h = l[(f + 3) & 7]),
          (d ^= h ^ (h >>> 3)),
          (h = l[(f + 4) & 7]),
          (d ^= h ^ (h << 7)),
          (h = l[(f + 7) & 7]),
          (h = h ^ (h << 13)),
          (d ^= h ^ (h << 9)),
          (l[f] = d),
          (c.i = (f + 1) & 7),
          d
        );
      };
      function u(l, f) {
        var h,
          d = [];
        if (f === (f | 0)) d[0] = f;
        else
          for (f = "" + f, h = 0; h < f.length; ++h)
            d[h & 7] =
              (d[h & 7] << 15) ^ ((f.charCodeAt(h) + d[(h + 1) & 7]) << 13);
        for (; d.length < 8; ) d.push(0);
        for (h = 0; h < 8 && d[h] === 0; ++h);
        for (h == 8 ? (d[7] = -1) : d[h], l.x = d, l.i = 0, h = 256; h > 0; --h)
          l.next();
      }
      u(c, o);
    }
    function a(o, c) {
      return (c.x = o.x.slice()), (c.i = o.i), c;
    }
    function s(o, c) {
      o == null && (o = +new Date());
      var u = new i(o),
        l = c && c.state,
        f = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (f.double = function () {
          do
            var h = u.next() >>> 11,
              d = (u.next() >>> 0) / 4294967296,
              g = (h + d) / (1 << 21);
          while (g === 0);
          return g;
        }),
        (f.int32 = u.next),
        (f.quick = f),
        l &&
          (l.x && a(l, u),
          (f.state = function () {
            return a(u, {});
          })),
        f
      );
    }
    t && t.exports
      ? (t.exports = s)
      : r && r.amd
      ? r(function () {
          return s;
        })
      : (this.xorshift7 = s);
  })(Ur, n, !1);
})(xl);
var z3 = xl.exports,
  bl = { exports: {} };
bl.exports;
(function (n) {
  (function (e, t, r) {
    function i(o) {
      var c = this;
      c.next = function () {
        var l = c.w,
          f = c.X,
          h = c.i,
          d,
          g;
        return (
          (c.w = l = (l + 1640531527) | 0),
          (g = f[(h + 34) & 127]),
          (d = f[(h = (h + 1) & 127)]),
          (g ^= g << 13),
          (d ^= d << 17),
          (g ^= g >>> 15),
          (d ^= d >>> 12),
          (g = f[h] = g ^ d),
          (c.i = h),
          (g + (l ^ (l >>> 16))) | 0
        );
      };
      function u(l, f) {
        var h,
          d,
          g,
          x,
          m,
          p = [],
          S = 128;
        for (
          f === (f | 0)
            ? ((d = f), (f = null))
            : ((f = f + "\0"), (d = 0), (S = Math.max(S, f.length))),
            g = 0,
            x = -32;
          x < S;
          ++x
        )
          f && (d ^= f.charCodeAt((x + 32) % f.length)),
            x === 0 && (m = d),
            (d ^= d << 10),
            (d ^= d >>> 15),
            (d ^= d << 4),
            (d ^= d >>> 13),
            x >= 0 &&
              ((m = (m + 1640531527) | 0),
              (h = p[x & 127] ^= d + m),
              (g = h == 0 ? g + 1 : 0));
        for (
          g >= 128 && (p[((f && f.length) || 0) & 127] = -1),
            g = 127,
            x = 4 * 128;
          x > 0;
          --x
        )
          (d = p[(g + 34) & 127]),
            (h = p[(g = (g + 1) & 127)]),
            (d ^= d << 13),
            (h ^= h << 17),
            (d ^= d >>> 15),
            (h ^= h >>> 12),
            (p[g] = d ^ h);
        (l.w = m), (l.X = p), (l.i = g);
      }
      u(c, o);
    }
    function a(o, c) {
      return (c.i = o.i), (c.w = o.w), (c.X = o.X.slice()), c;
    }
    function s(o, c) {
      o == null && (o = +new Date());
      var u = new i(o),
        l = c && c.state,
        f = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (f.double = function () {
          do
            var h = u.next() >>> 11,
              d = (u.next() >>> 0) / 4294967296,
              g = (h + d) / (1 << 21);
          while (g === 0);
          return g;
        }),
        (f.int32 = u.next),
        (f.quick = f),
        l &&
          (l.X && a(l, u),
          (f.state = function () {
            return a(u, {});
          })),
        f
      );
    }
    t && t.exports
      ? (t.exports = s)
      : r && r.amd
      ? r(function () {
          return s;
        })
      : (this.xor4096 = s);
  })(Ur, n, !1);
})(bl);
var k3 = bl.exports,
  _l = { exports: {} };
_l.exports;
(function (n) {
  (function (e, t, r) {
    function i(o) {
      var c = this,
        u = "";
      (c.next = function () {
        var f = c.b,
          h = c.c,
          d = c.d,
          g = c.a;
        return (
          (f = (f << 25) ^ (f >>> 7) ^ h),
          (h = (h - d) | 0),
          (d = (d << 24) ^ (d >>> 8) ^ g),
          (g = (g - f) | 0),
          (c.b = f = (f << 20) ^ (f >>> 12) ^ h),
          (c.c = h = (h - d) | 0),
          (c.d = (d << 16) ^ (h >>> 16) ^ g),
          (c.a = (g - f) | 0)
        );
      }),
        (c.a = 0),
        (c.b = 0),
        (c.c = -1640531527),
        (c.d = 1367130551),
        o === Math.floor(o)
          ? ((c.a = (o / 4294967296) | 0), (c.b = o | 0))
          : (u += o);
      for (var l = 0; l < u.length + 20; l++)
        (c.b ^= u.charCodeAt(l) | 0), c.next();
    }
    function a(o, c) {
      return (c.a = o.a), (c.b = o.b), (c.c = o.c), (c.d = o.d), c;
    }
    function s(o, c) {
      var u = new i(o),
        l = c && c.state,
        f = function () {
          return (u.next() >>> 0) / 4294967296;
        };
      return (
        (f.double = function () {
          do
            var h = u.next() >>> 11,
              d = (u.next() >>> 0) / 4294967296,
              g = (h + d) / (1 << 21);
          while (g === 0);
          return g;
        }),
        (f.int32 = u.next),
        (f.quick = f),
        l &&
          (typeof l == "object" && a(l, u),
          (f.state = function () {
            return a(u, {});
          })),
        f
      );
    }
    t && t.exports
      ? (t.exports = s)
      : r && r.amd
      ? r(function () {
          return s;
        })
      : (this.tychei = s);
  })(Ur, n, !1);
})(_l);
var H3 = _l.exports,
  w0 = { exports: {} };
const G3 = {},
  V3 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: G3 },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  W3 = ME(V3);
(function (n) {
  (function (e, t, r) {
    var i = 256,
      a = 6,
      s = 52,
      o = "random",
      c = r.pow(i, a),
      u = r.pow(2, s),
      l = u * 2,
      f = i - 1,
      h;
    function d(y, E, M) {
      var T = [];
      E = E == !0 ? { entropy: !0 } : E || {};
      var N = p(m(E.entropy ? [y, v(t)] : y ?? S(), 3), T),
        A = new g(T),
        D = function () {
          for (var z = A.g(a), $ = c, I = 0; z < u; )
            (z = (z + I) * i), ($ *= i), (I = A.g(1));
          for (; z >= l; ) (z /= 2), ($ /= 2), (I >>>= 1);
          return (z + I) / $;
        };
      return (
        (D.int32 = function () {
          return A.g(4) | 0;
        }),
        (D.quick = function () {
          return A.g(4) / 4294967296;
        }),
        (D.double = D),
        p(v(A.S), t),
        (
          E.pass ||
          M ||
          function (z, $, I, G) {
            return (
              G &&
                (G.S && x(G, A),
                (z.state = function () {
                  return x(A, {});
                })),
              I ? ((r[o] = z), $) : z
            );
          }
        )(D, N, "global" in E ? E.global : this == r, E.state)
      );
    }
    function g(y) {
      var E,
        M = y.length,
        T = this,
        N = 0,
        A = (T.i = T.j = 0),
        D = (T.S = []);
      for (M || (y = [M++]); N < i; ) D[N] = N++;
      for (N = 0; N < i; N++)
        (D[N] = D[(A = f & (A + y[N % M] + (E = D[N])))]), (D[A] = E);
      (T.g = function (z) {
        for (var $, I = 0, G = T.i, L = T.j, C = T.S; z--; )
          ($ = C[(G = f & (G + 1))]),
            (I = I * i + C[f & ((C[G] = C[(L = f & (L + $))]) + (C[L] = $))]);
        return (T.i = G), (T.j = L), I;
      })(i);
    }
    function x(y, E) {
      return (E.i = y.i), (E.j = y.j), (E.S = y.S.slice()), E;
    }
    function m(y, E) {
      var M = [],
        T = typeof y,
        N;
      if (E && T == "object")
        for (N in y)
          try {
            M.push(m(y[N], E - 1));
          } catch {}
      return M.length ? M : T == "string" ? y : y + "\0";
    }
    function p(y, E) {
      for (var M = y + "", T, N = 0; N < M.length; )
        E[f & N] = f & ((T ^= E[f & N] * 19) + M.charCodeAt(N++));
      return v(E);
    }
    function S() {
      try {
        var y;
        return (
          h && (y = h.randomBytes)
            ? (y = y(i))
            : ((y = new Uint8Array(i)),
              (e.crypto || e.msCrypto).getRandomValues(y)),
          v(y)
        );
      } catch {
        var E = e.navigator,
          M = E && E.plugins;
        return [+new Date(), e, M, e.screen, v(t)];
      }
    }
    function v(y) {
      return String.fromCharCode.apply(0, y);
    }
    if ((p(r.random(), t), n.exports)) {
      n.exports = d;
      try {
        h = W3;
      } catch {}
    } else r["seed" + o] = d;
  })(typeof self < "u" ? self : Ur, [], Math);
})(w0);
var q3 = w0.exports,
  $3 = O3,
  j3 = U3,
  X3 = B3,
  Y3 = z3,
  Z3 = k3,
  J3 = H3,
  gi = q3;
gi.alea = $3;
gi.xor128 = j3;
gi.xorwow = X3;
gi.xorshift7 = Y3;
gi.xor4096 = Z3;
gi.tychei = J3;
var K3 = gi;
const E0 = gs(K3);
var Q3 = E0(Date.now());
function fa(n) {
  var e;
  function t(i) {
    e = i === null ? Q3 : E0(String(i));
  }
  t(n);
  function r() {
    return e();
  }
  return r;
}
var Cd = "pickRandom",
  eR = ["typed", "config", "?on"],
  tR = me(Cd, eR, (n) => {
    var { typed: e, config: t, on: r } = n,
      i = fa(t.randomSeed);
    return (
      r &&
        r("config", function (s, o) {
          s.randomSeed !== o.randomSeed && (i = fa(s.randomSeed));
        }),
      e(Cd, {
        "Array | Matrix": function (o) {
          return a(o, {});
        },
        "Array | Matrix, Object": function (o, c) {
          return a(o, c);
        },
        "Array | Matrix, number": function (o, c) {
          return a(o, { number: c });
        },
        "Array | Matrix, Array | Matrix": function (o, c) {
          return a(o, { weights: c });
        },
        "Array | Matrix, Array | Matrix, number": function (o, c, u) {
          return a(o, { number: u, weights: c });
        },
        "Array | Matrix, number, Array | Matrix": function (o, c, u) {
          return a(o, { number: c, weights: u });
        },
      })
    );
    function a(s, o) {
      var { number: c, weights: u, elementWise: l = !0 } = o,
        f = typeof c > "u";
      f && (c = 1);
      var h = tn(s) ? s.create : tn(u) ? u.create : null;
      (s = s.valueOf()),
        u && (u = u.valueOf()),
        l === !0 && ((s = oi(s)), (u = oi(u)));
      var d = 0;
      if (typeof u < "u") {
        if (u.length !== s.length)
          throw new Error("Weights must have the same length as possibles");
        for (var g = 0, x = u.length; g < x; g++) {
          if (!Dt(u[g]) || u[g] < 0)
            throw new Error("Weights must be an array of positive numbers");
          d += u[g];
        }
      }
      for (var m = s.length, p = [], S; p.length < c; ) {
        if (typeof u > "u") S = s[Math.floor(i() * m)];
        else
          for (var v = i() * d, y = 0, E = s.length; y < E; y++)
            if (((v -= u[y]), v < 0)) {
              S = s[y];
              break;
            }
        p.push(S);
      }
      return f ? p[0] : h ? h(p) : p;
    }
  });
function S0(n, e) {
  var t = [];
  if (((n = n.slice(0)), n.length > 1))
    for (var r = 0, i = n.shift(); r < i; r++) t.push(S0(n, e));
  else for (var a = 0, s = n.shift(); a < s; a++) t.push(e());
  return t;
}
var Nd = "random",
  nR = me(Nd, ["typed", "config", "?on"], (n) => {
    var { typed: e, config: t, on: r, matrix: i } = n,
      a = fa(t.randomSeed);
    return (
      r &&
        r("config", function (o, c) {
          o.randomSeed !== c.randomSeed && (a = fa(o.randomSeed));
        }),
      e(Nd, {
        "": () => s(0, 1),
        number: (o) => s(0, o),
        "number, number": (o, c) => s(o, c),
      })
    );
    function s(o, c) {
      return o + a() * (c - o);
    }
  }),
  Rd = "randomInt",
  rR = ["typed", "config", "?on"],
  iR = me(Rd, rR, (n) => {
    var { typed: e, config: t, on: r } = n,
      i = fa(t.randomSeed);
    return (
      r &&
        r("config", function (o, c) {
          o.randomSeed !== c.randomSeed && (i = fa(o.randomSeed));
        }),
      e(Rd, {
        "": () => s(0, 1),
        number: (o) => s(0, o),
        "number, number": (o, c) => s(o, c),
        "Array | Matrix": (o) => a(o, 0, 1),
        "Array | Matrix, number": (o, c) => a(o, 0, c),
        "Array | Matrix, number, number": (o, c, u) => a(o, c, u),
      })
    );
    function a(o, c, u) {
      var l = S0(o.valueOf(), () => s(c, u));
      return tn(o) ? o.create(l) : l;
    }
    function s(o, c) {
      return Math.floor(o + i() * (c - o));
    }
  }),
  Fd = "equalScalar",
  aR = me(Fd, ["typed", "config"], (n) => {
    var { typed: e, config: t } = n;
    return e(Fd, {
      "number, number": function (i, a) {
        return qn(i, a, t.epsilon);
      },
    });
  }),
  Pd = "compare",
  sR = me(Pd, ["typed", "config"], (n) => {
    var { typed: e, config: t } = n;
    return e(Pd, {
      "number, number": function (i, a) {
        return qn(i, a, t.epsilon) ? 0 : i > a ? 1 : -1;
      },
    });
  }),
  oR = function n(e, t) {
    var r =
        /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
      i = /(^[ ]*|[ ]*$)/g,
      a =
        /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
      s = /^0x[0-9a-f]+$/i,
      o = /^0/,
      c = function (v) {
        return (n.insensitive && ("" + v).toLowerCase()) || "" + v;
      },
      u = c(e).replace(i, "") || "",
      l = c(t).replace(i, "") || "",
      f = u
        .replace(r, "\0$1\0")
        .replace(/\0$/, "")
        .replace(/^\0/, "")
        .split("\0"),
      h = l
        .replace(r, "\0$1\0")
        .replace(/\0$/, "")
        .replace(/^\0/, "")
        .split("\0"),
      d =
        parseInt(u.match(s), 16) ||
        (f.length !== 1 && u.match(a) && Date.parse(u)),
      g =
        parseInt(l.match(s), 16) || (d && l.match(a) && Date.parse(l)) || null,
      x,
      m;
    if (g) {
      if (d < g) return -1;
      if (d > g) return 1;
    }
    for (var p = 0, S = Math.max(f.length, h.length); p < S; p++) {
      if (
        ((x = (!(f[p] || "").match(o) && parseFloat(f[p])) || f[p] || 0),
        (m = (!(h[p] || "").match(o) && parseFloat(h[p])) || h[p] || 0),
        isNaN(x) !== isNaN(m))
      )
        return isNaN(x) ? 1 : -1;
      if ((typeof x != typeof m && ((x += ""), (m += "")), x < m)) return -1;
      if (x > m) return 1;
    }
    return 0;
  };
const ki = gs(oR);
var Ld = "compareNatural",
  uR = ["typed", "compare"],
  cR = me(Ld, uR, (n) => {
    var { typed: e, compare: t } = n,
      r = t.signatures["boolean,boolean"];
    return e(Ld, { "any, any": i });
    function i(c, u) {
      var l = Vt(c),
        f = Vt(u),
        h;
      if (
        (l === "number" || l === "BigNumber" || l === "Fraction") &&
        (f === "number" || f === "BigNumber" || f === "Fraction")
      )
        return (
          (h = t(c, u)), h.toString() !== "0" ? (h > 0 ? 1 : -1) : ki(l, f)
        );
      var d = ["Array", "DenseMatrix", "SparseMatrix"];
      if (d.includes(l) || d.includes(f))
        return (h = a(i, c, u)), h !== 0 ? h : ki(l, f);
      if (l !== f) return ki(l, f);
      if (l === "Complex") return lR(c, u);
      if (l === "Unit")
        return c.equalBase(u)
          ? i(c.value, u.value)
          : s(i, c.formatUnits(), u.formatUnits());
      if (l === "boolean") return r(c, u);
      if (l === "string") return ki(c, u);
      if (l === "Object") return o(i, c, u);
      if (l === "null" || l === "undefined") return 0;
      throw new TypeError('Unsupported type of value "' + l + '"');
    }
    function a(c, u, l) {
      return Yi(u) && Yi(l)
        ? s(c, u.toJSON().values, l.toJSON().values)
        : Yi(u)
        ? a(c, u.toArray(), l)
        : Yi(l)
        ? a(c, u, l.toArray())
        : Co(u)
        ? a(c, u.toJSON().data, l)
        : Co(l)
        ? a(c, u, l.toJSON().data)
        : Array.isArray(u)
        ? Array.isArray(l)
          ? s(c, u, l)
          : a(c, u, [l])
        : a(c, [u], l);
    }
    function s(c, u, l) {
      for (var f = 0, h = Math.min(u.length, l.length); f < h; f++) {
        var d = c(u[f], l[f]);
        if (d !== 0) return d;
      }
      return u.length > l.length ? 1 : u.length < l.length ? -1 : 0;
    }
    function o(c, u, l) {
      var f = Object.keys(u),
        h = Object.keys(l);
      f.sort(ki), h.sort(ki);
      var d = s(c, f, h);
      if (d !== 0) return d;
      for (var g = 0; g < f.length; g++) {
        var x = c(u[f[g]], l[h[g]]);
        if (x !== 0) return x;
      }
      return 0;
    }
  });
function lR(n, e) {
  return n.re > e.re
    ? 1
    : n.re < e.re
    ? -1
    : n.im > e.im
    ? 1
    : n.im < e.im
    ? -1
    : 0;
}
var Id = "compareText";
r0.signature = "any, any";
var fR = me(Id, ["typed"], (n) => {
    var { typed: e } = n;
    return e(Id, r0);
  }),
  Od = "equal",
  hR = me(Od, ["typed", "equalScalar"], (n) => {
    var { typed: e, equalScalar: t } = n;
    return e(Od, {
      "any, any": function (i, a) {
        return i === null
          ? a === null
          : a === null
          ? i === null
          : i === void 0
          ? a === void 0
          : a === void 0
          ? i === void 0
          : t(i, a);
      },
    });
  }),
  Ud = "equalText",
  dR = ["typed", "compareText", "isZero"],
  pR = me(Ud, dR, (n) => {
    var { typed: e, compareText: t, isZero: r } = n;
    return e(Ud, {
      "any, any": function (a, s) {
        return r(t(a, s));
      },
    });
  }),
  Bd = "smaller",
  mR = me(Bd, ["typed", "config"], (n) => {
    var { typed: e, config: t } = n;
    return e(Bd, {
      "number, number": function (i, a) {
        return i < a && !qn(i, a, t.epsilon);
      },
    });
  }),
  zd = "smallerEq",
  gR = me(zd, ["typed", "config"], (n) => {
    var { typed: e, config: t } = n;
    return e(zd, {
      "number, number": function (i, a) {
        return i <= a || qn(i, a, t.epsilon);
      },
    });
  }),
  kd = "larger",
  vR = me(kd, ["typed", "config"], (n) => {
    var { typed: e, config: t } = n;
    return e(kd, {
      "number, number": function (i, a) {
        return i > a && !qn(i, a, t.epsilon);
      },
    });
  }),
  Hd = "largerEq",
  yR = me(Hd, ["typed", "config"], (n) => {
    var { typed: e, config: t } = n;
    return e(Hd, {
      "number, number": function (i, a) {
        return i >= a || qn(i, a, t.epsilon);
      },
    });
  }),
  Gd = "deepEqual",
  xR = ["typed", "equal"],
  bR = me(Gd, xR, (n) => {
    var { typed: e, equal: t } = n;
    return e(Gd, {
      "any, any": function (a, s) {
        return r(a.valueOf(), s.valueOf());
      },
    });
    function r(i, a) {
      if (Array.isArray(i))
        if (Array.isArray(a)) {
          var s = i.length;
          if (s !== a.length) return !1;
          for (var o = 0; o < s; o++) if (!r(i[o], a[o])) return !1;
          return !0;
        } else return !1;
      else return Array.isArray(a) ? !1 : t(i, a);
    }
  }),
  Vd = "unequal",
  _R = me(Vd, ["typed", "equalScalar"], (n) => {
    var { typed: e, equalScalar: t } = n;
    return e(Vd, {
      "any, any": function (i, a) {
        return i === null
          ? a !== null
          : a === null
          ? i !== null
          : i === void 0
          ? a !== void 0
          : a === void 0
          ? i !== void 0
          : !t(i, a);
      },
    });
  }),
  wR = "erf",
  ER = ["typed"],
  SR = me(wR, ER, (n) => {
    var { typed: e } = n;
    return e("name", {
      number: function (s) {
        var o = Math.abs(s);
        return o >= DR
          ? Ar(s)
          : o <= MR
          ? Ar(s) * t(o)
          : o <= 4
          ? Ar(s) * (1 - r(o))
          : Ar(s) * (1 - i(o));
      },
      "Array | Matrix": e.referToSelf((a) => (s) => Sn(s, a)),
    });
    function t(a) {
      var s = a * a,
        o = nr[0][4] * s,
        c = s,
        u;
      for (u = 0; u < 3; u += 1)
        (o = (o + nr[0][u]) * s), (c = (c + Hi[0][u]) * s);
      return (a * (o + nr[0][3])) / (c + Hi[0][3]);
    }
    function r(a) {
      var s = nr[1][8] * a,
        o = a,
        c;
      for (c = 0; c < 7; c += 1)
        (s = (s + nr[1][c]) * a), (o = (o + Hi[1][c]) * a);
      var u = (s + nr[1][7]) / (o + Hi[1][7]),
        l = parseInt(a * 16) / 16,
        f = (a - l) * (a + l);
      return Math.exp(-l * l) * Math.exp(-f) * u;
    }
    function i(a) {
      var s = 1 / (a * a),
        o = nr[2][5] * s,
        c = s,
        u;
      for (u = 0; u < 4; u += 1)
        (o = (o + nr[2][u]) * s), (c = (c + Hi[2][u]) * s);
      var l = (s * (o + nr[2][4])) / (c + Hi[2][4]);
      (l = (AR - l) / a), (s = parseInt(a * 16) / 16);
      var f = (a - s) * (a + s);
      return Math.exp(-s * s) * Math.exp(-f) * l;
    }
  }),
  MR = 0.46875,
  AR = 0.5641895835477563,
  nr = [
    [
      3.1611237438705655, 113.86415415105016, 377.485237685302,
      3209.3775891384694, 0.18577770618460315,
    ],
    [
      0.5641884969886701, 8.883149794388377, 66.11919063714163,
      298.6351381974001, 881.952221241769, 1712.0476126340707,
      2051.0783778260716, 1230.3393547979972, 21531153547440383e-24,
    ],
    [
      0.30532663496123236, 0.36034489994980445, 0.12578172611122926,
      0.016083785148742275, 0.0006587491615298378, 0.016315387137302097,
    ],
  ],
  Hi = [
    [
      23.601290952344122, 244.02463793444417, 1282.6165260773723,
      2844.236833439171,
    ],
    [
      15.744926110709835, 117.6939508913125, 537.1811018620099,
      1621.3895745666903, 3290.7992357334597, 4362.619090143247,
      3439.3676741437216, 1230.3393548037495,
    ],
    [
      2.568520192289822, 1.8729528499234604, 0.5279051029514285,
      0.06051834131244132, 0.0023352049762686918,
    ],
  ],
  DR = Math.pow(2, 53),
  Wd = "zeta",
  TR = [
    "typed",
    "config",
    "multiply",
    "pow",
    "divide",
    "factorial",
    "equal",
    "smallerEq",
    "isNegative",
    "gamma",
    "sin",
    "subtract",
    "add",
    "?Complex",
    "?BigNumber",
    "pi",
  ],
  CR = me(Wd, TR, (n) => {
    var {
      typed: e,
      config: t,
      multiply: r,
      pow: i,
      divide: a,
      factorial: s,
      equal: o,
      smallerEq: c,
      isNegative: u,
      gamma: l,
      sin: f,
      subtract: h,
      add: d,
      Complex: g,
      BigNumber: x,
      pi: m,
    } = n;
    return e(Wd, {
      number: (M) =>
        p(
          M,
          (T) => T,
          () => 20
        ),
      BigNumber: (M) =>
        p(
          M,
          (T) => new x(T),
          () => Math.abs(Math.log10(t.epsilon))
        ),
      Complex: S,
    });
    function p(M, T, N) {
      return o(M, 0)
        ? T(-0.5)
        : o(M, 1)
        ? T(NaN)
        : isFinite(M)
        ? v(M, T, N, (A) => A)
        : u(M)
        ? T(NaN)
        : T(1);
    }
    function S(M) {
      return M.re === 0 && M.im === 0
        ? new g(-0.5)
        : M.re === 1
        ? new g(NaN, NaN)
        : M.re === 1 / 0 && M.im === 0
        ? new g(1)
        : M.im === 1 / 0 || M.re === -1 / 0
        ? new g(NaN, NaN)
        : v(
            M,
            (T) => T,
            (T) => Math.round(1.3 * 15 + 0.9 * Math.abs(T.im)),
            (T) => T.re
          );
    }
    function v(M, T, N, A) {
      var D = N(M);
      if (A(M) > -(D - 1) / 2) return E(M, T(D), T);
      var z = r(i(2, M), i(T(m), h(M, 1)));
      return (
        (z = r(z, f(r(a(T(m), 2), M)))),
        (z = r(z, l(h(1, M)))),
        r(z, v(h(1, M), T, N, A))
      );
    }
    function y(M, T) {
      for (var N = M, A = M; c(A, T); A = d(A, 1)) {
        var D = a(r(s(d(T, h(A, 1))), i(4, A)), r(s(h(T, A)), s(r(2, A))));
        N = d(N, D);
      }
      return r(T, N);
    }
    function E(M, T, N) {
      for (
        var A = a(1, r(y(N(0), T), h(1, i(2, h(1, M))))), D = N(0), z = N(1);
        c(z, T);
        z = d(z, 1)
      )
        D = d(D, a(r((-1) ** (z - 1), y(z, T)), i(z, M)));
      return r(A, D);
    }
  }),
  qd = "mode",
  NR = ["typed", "isNaN", "isNumeric"],
  RR = me(qd, NR, (n) => {
    var { typed: e, isNaN: t, isNumeric: r } = n;
    return e(qd, {
      "Array | Matrix": i,
      "...": function (s) {
        return i(s);
      },
    });
    function i(a) {
      a = oi(a.valueOf());
      var s = a.length;
      if (s === 0) throw new Error("Cannot calculate mode of an empty array");
      for (var o = {}, c = [], u = 0, l = 0; l < a.length; l++) {
        var f = a[l];
        if (r(f) && t(f))
          throw new Error(
            "Cannot calculate mode of an array containing NaN values"
          );
        f in o || (o[f] = 0),
          o[f]++,
          o[f] === u ? c.push(f) : o[f] > u && ((u = o[f]), (c = [f]));
      }
      return c;
    }
  });
function nn(n, e, t) {
  var r;
  return String(n).includes("Unexpected type")
    ? ((r =
        arguments.length > 2
          ? " (type: " + Vt(t) + ", value: " + JSON.stringify(t) + ")"
          : " (type: " + n.data.actual + ")"),
      new TypeError(
        "Cannot calculate " + e + ", unexpected type of argument" + r
      ))
    : String(n).includes("complex numbers")
    ? ((r =
        arguments.length > 2
          ? " (type: " + Vt(t) + ", value: " + JSON.stringify(t) + ")"
          : ""),
      new TypeError(
        "Cannot calculate " +
          e +
          ", no ordering relation is defined for complex numbers" +
          r
      ))
    : n;
}
var $d = "prod",
  FR = ["typed", "config", "multiplyScalar", "numeric"],
  PR = me($d, FR, (n) => {
    var { typed: e, config: t, multiplyScalar: r, numeric: i } = n;
    return e($d, {
      "Array | Matrix": a,
      "Array | Matrix, number | BigNumber": function (o, c) {
        throw new Error("prod(A, dim) is not yet supported");
      },
      "...": function (o) {
        return a(o);
      },
    });
    function a(s) {
      var o;
      if (
        (dr(s, function (c) {
          try {
            o = o === void 0 ? c : r(o, c);
          } catch (u) {
            throw nn(u, "prod", c);
          }
        }),
        typeof o == "string" && (o = i(o, t.number)),
        o === void 0)
      )
        throw new Error("Cannot calculate prod of an empty array");
      return o;
    }
  }),
  jd = "max",
  LR = ["typed", "config", "numeric", "larger"],
  M0 = me(jd, LR, (n) => {
    var { typed: e, config: t, numeric: r, larger: i } = n;
    return e(jd, {
      "Array | Matrix": s,
      "Array | Matrix, number | BigNumber": function (c, u) {
        return nu(c, u.valueOf(), a);
      },
      "...": function (c) {
        if (wa(c))
          throw new TypeError("Scalar values expected in function max");
        return s(c);
      },
    });
    function a(o, c) {
      try {
        return i(o, c) ? o : c;
      } catch (u) {
        throw nn(u, "max", c);
      }
    }
    function s(o) {
      var c;
      if (
        (dr(o, function (u) {
          try {
            isNaN(u) && typeof u == "number"
              ? (c = NaN)
              : (c === void 0 || i(u, c)) && (c = u);
          } catch (l) {
            throw nn(l, "max", u);
          }
        }),
        c === void 0)
      )
        throw new Error("Cannot calculate max of an empty array");
      return typeof c == "string" && (c = r(c, t.number)), c;
    }
  }),
  Xd = "min",
  IR = ["typed", "config", "numeric", "smaller"],
  A0 = me(Xd, IR, (n) => {
    var { typed: e, config: t, numeric: r, smaller: i } = n;
    return e(Xd, {
      "Array | Matrix": s,
      "Array | Matrix, number | BigNumber": function (c, u) {
        return nu(c, u.valueOf(), a);
      },
      "...": function (c) {
        if (wa(c))
          throw new TypeError("Scalar values expected in function min");
        return s(c);
      },
    });
    function a(o, c) {
      try {
        return i(o, c) ? o : c;
      } catch (u) {
        throw nn(u, "min", c);
      }
    }
    function s(o) {
      var c;
      if (
        (dr(o, function (u) {
          try {
            isNaN(u) && typeof u == "number"
              ? (c = NaN)
              : (c === void 0 || i(u, c)) && (c = u);
          } catch (l) {
            throw nn(l, "min", u);
          }
        }),
        c === void 0)
      )
        throw new Error("Cannot calculate min of an empty array");
      return typeof c == "string" && (c = r(c, t.number)), c;
    }
  }),
  Yd = "sum",
  OR = ["typed", "config", "add", "numeric"],
  D0 = me(Yd, OR, (n) => {
    var { typed: e, config: t, add: r, numeric: i } = n;
    return e(Yd, {
      "Array | Matrix": a,
      "Array | Matrix, number | BigNumber": s,
      "...": function (c) {
        if (wa(c))
          throw new TypeError("Scalar values expected in function sum");
        return a(c);
      },
    });
    function a(o) {
      var c;
      return (
        dr(o, function (u) {
          try {
            c = c === void 0 ? u : r(c, u);
          } catch (l) {
            throw nn(l, "sum", u);
          }
        }),
        c === void 0 && (c = i(0, t.number)),
        typeof c == "string" && (c = i(c, t.number)),
        c
      );
    }
    function s(o, c) {
      try {
        var u = nu(o, c, r);
        return u;
      } catch (l) {
        throw nn(l, "sum");
      }
    }
  }),
  vo = "cumsum",
  UR = ["typed", "add", "unaryPlus"],
  T0 = me(vo, UR, (n) => {
    var { typed: e, add: t, unaryPlus: r } = n;
    return e(vo, {
      Array: i,
      Matrix: function (u) {
        return u.create(i(u.valueOf()));
      },
      "Array, number | BigNumber": s,
      "Matrix, number | BigNumber": function (u, l) {
        return u.create(s(u.valueOf(), l));
      },
      "...": function (u) {
        if (wa(u))
          throw new TypeError(
            "All values expected to be scalar in function cumsum"
          );
        return i(u);
      },
    });
    function i(c) {
      try {
        return a(c);
      } catch (u) {
        throw nn(u, vo);
      }
    }
    function a(c) {
      if (c.length === 0) return [];
      for (var u = [r(c[0])], l = 1; l < c.length; ++l)
        u.push(t(u[l - 1], c[l]));
      return u;
    }
    function s(c, u) {
      var l = mi(c);
      if (u < 0 || u >= l.length) throw new Xn(u, l.length);
      try {
        return o(c, u);
      } catch (f) {
        throw nn(f, vo);
      }
    }
    function o(c, u) {
      var l, f, h;
      if (u <= 0) {
        var d = c[0][0];
        if (Array.isArray(d)) {
          for (h = g0(c), f = [], l = 0; l < h.length; l++)
            f[l] = o(h[l], u - 1);
          return f;
        } else return a(c);
      } else {
        for (f = [], l = 0; l < c.length; l++) f[l] = o(c[l], u - 1);
        return f;
      }
    }
  }),
  Zd = "mean",
  BR = ["typed", "add", "divide"],
  C0 = me(Zd, BR, (n) => {
    var { typed: e, add: t, divide: r } = n;
    return e(Zd, {
      "Array | Matrix": a,
      "Array | Matrix, number | BigNumber": i,
      "...": function (o) {
        if (wa(o))
          throw new TypeError("Scalar values expected in function mean");
        return a(o);
      },
    });
    function i(s, o) {
      try {
        var c = nu(s, o, t),
          u = Array.isArray(s) ? mi(s) : s.size();
        return r(c, u[o]);
      } catch (l) {
        throw nn(l, "mean");
      }
    }
    function a(s) {
      var o,
        c = 0;
      if (
        (dr(s, function (u) {
          try {
            (o = o === void 0 ? u : t(o, u)), c++;
          } catch (l) {
            throw nn(l, "mean", u);
          }
        }),
        c === 0)
      )
        throw new Error("Cannot calculate the mean of an empty array");
      return r(o, c);
    }
  }),
  Jd = "median",
  zR = ["typed", "add", "divide", "compare", "partitionSelect"],
  kR = me(Jd, zR, (n) => {
    var { typed: e, add: t, divide: r, compare: i, partitionSelect: a } = n;
    function s(u) {
      try {
        u = oi(u.valueOf());
        var l = u.length;
        if (l === 0)
          throw new Error("Cannot calculate median of an empty array");
        if (l % 2 === 0) {
          for (var f = l / 2 - 1, h = a(u, f + 1), d = u[f], g = 0; g < f; ++g)
            i(u[g], d) > 0 && (d = u[g]);
          return c(d, h);
        } else {
          var x = a(u, (l - 1) / 2);
          return o(x);
        }
      } catch (m) {
        throw nn(m, "median");
      }
    }
    var o = e({
        "number | BigNumber | Complex | Unit": function (l) {
          return l;
        },
      }),
      c = e({
        "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit":
          function (l, f) {
            return r(t(l, f), 2);
          },
      });
    return e(Jd, {
      "Array | Matrix": s,
      "Array | Matrix, number | BigNumber": function (l, f) {
        throw new Error("median(A, dim) is not yet supported");
      },
      "...": function (l) {
        if (wa(l))
          throw new TypeError("Scalar values expected in function median");
        return s(l);
      },
    });
  }),
  Kd = "mad",
  HR = ["typed", "abs", "map", "median", "subtract"],
  GR = me(Kd, HR, (n) => {
    var { typed: e, abs: t, map: r, median: i, subtract: a } = n;
    return e(Kd, {
      "Array | Matrix": s,
      "...": function (c) {
        return s(c);
      },
    });
    function s(o) {
      if (((o = oi(o.valueOf())), o.length === 0))
        throw new Error(
          "Cannot calculate median absolute deviation (mad) of an empty array"
        );
      try {
        var c = i(o);
        return i(
          r(o, function (u) {
            return t(a(u, c));
          })
        );
      } catch (u) {
        throw u instanceof TypeError && u.message.includes("median")
          ? new TypeError(u.message.replace("median", "mad"))
          : nn(u, "mad");
      }
    }
  }),
  sc = "unbiased",
  Qd = "variance",
  VR = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"],
  N0 = me(Qd, VR, (n) => {
    var {
      typed: e,
      add: t,
      subtract: r,
      multiply: i,
      divide: a,
      apply: s,
      isNaN: o,
    } = n;
    return e(Qd, {
      "Array | Matrix": function (f) {
        return c(f, sc);
      },
      "Array | Matrix, string": c,
      "Array | Matrix, number | BigNumber": function (f, h) {
        return u(f, h, sc);
      },
      "Array | Matrix, number | BigNumber, string": u,
      "...": function (f) {
        return c(f, sc);
      },
    });
    function c(l, f) {
      var h,
        d = 0;
      if (l.length === 0)
        throw new SyntaxError(
          "Function variance requires one or more parameters (0 provided)"
        );
      if (
        (dr(l, function (m) {
          try {
            (h = h === void 0 ? m : t(h, m)), d++;
          } catch (p) {
            throw nn(p, "variance", m);
          }
        }),
        d === 0)
      )
        throw new Error("Cannot calculate variance of an empty array");
      var g = a(h, d);
      if (
        ((h = void 0),
        dr(l, function (m) {
          var p = r(m, g);
          h = h === void 0 ? i(p, p) : t(h, i(p, p));
        }),
        o(h))
      )
        return h;
      switch (f) {
        case "uncorrected":
          return a(h, d);
        case "biased":
          return a(h, d + 1);
        case "unbiased": {
          var x = Bt(h) ? h.mul(0) : 0;
          return d === 1 ? x : a(h, d - 1);
        }
        default:
          throw new Error(
            'Unknown normalization "' +
              f +
              '". Choose "unbiased" (default), "uncorrected", or "biased".'
          );
      }
    }
    function u(l, f, h) {
      try {
        if (l.length === 0)
          throw new SyntaxError(
            "Function variance requires one or more parameters (0 provided)"
          );
        return s(l, f, (d) => c(d, h));
      } catch (d) {
        throw nn(d, "variance");
      }
    }
  }),
  ep = "quantileSeq",
  WR = [
    "typed",
    "?bignumber",
    "add",
    "subtract",
    "divide",
    "multiply",
    "partitionSelect",
    "compare",
    "isInteger",
    "smaller",
    "smallerEq",
    "larger",
  ],
  qR = me(ep, WR, (n) => {
    var {
        typed: e,
        bignumber: t,
        add: r,
        subtract: i,
        divide: a,
        multiply: s,
        partitionSelect: o,
        compare: c,
        isInteger: u,
        smaller: l,
        smallerEq: f,
        larger: h,
      } = n,
      d = ml({ typed: e, isInteger: u });
    return e(ep, {
      "Array | Matrix, number | BigNumber": (S, v) => x(S, v, !1),
      "Array | Matrix, number | BigNumber, number": (S, v, y) =>
        g(S, v, !1, y, x),
      "Array | Matrix, number | BigNumber, boolean": x,
      "Array | Matrix, number | BigNumber, boolean, number": (S, v, y, E) =>
        g(S, v, y, E, x),
      "Array | Matrix, Array | Matrix": (S, v) => m(S, v, !1),
      "Array | Matrix, Array | Matrix, number": (S, v, y) => g(S, v, !1, y, m),
      "Array | Matrix, Array | Matrix, boolean": m,
      "Array | Matrix, Array | Matrix, boolean, number": (S, v, y, E) =>
        g(S, v, y, E, m),
    });
    function g(S, v, y, E, M) {
      return d(S, E, (T) => M(T, v, y));
    }
    function x(S, v, y) {
      var E,
        M = S.valueOf();
      if (l(v, 0)) throw new Error("N/prob must be non-negative");
      if (f(v, 1)) return Dt(v) ? p(M, v, y) : t(p(M, v, y));
      if (h(v, 1)) {
        if (!u(v)) throw new Error("N must be a positive integer");
        if (h(v, 4294967295))
          throw new Error(
            "N must be less than or equal to 2^32-1, as that is the maximum length of an Array"
          );
        var T = r(v, 1);
        E = [];
        for (var N = 0; l(N, v); N++) {
          var A = a(N + 1, T);
          E.push(p(M, A, y));
        }
        return Dt(v) ? E : t(E);
      }
    }
    function m(S, v, y) {
      for (
        var E = S.valueOf(), M = v.valueOf(), T = [], N = 0;
        N < M.length;
        ++N
      )
        T.push(p(E, M[N], y));
      return T;
    }
    function p(S, v, y) {
      var E = oi(S),
        M = E.length;
      if (M === 0)
        throw new Error("Cannot calculate quantile of an empty sequence");
      var T = Dt(v) ? v * (M - 1) : v.times(M - 1),
        N = Dt(v) ? Math.floor(T) : T.floor().toNumber(),
        A = Dt(v) ? T % 1 : T.minus(N);
      if (u(T)) return y ? E[T] : o(E, Dt(v) ? T : T.valueOf());
      var D, z;
      if (y) (D = E[N]), (z = E[N + 1]);
      else {
        (z = o(E, N + 1)), (D = E[N]);
        for (var $ = 0; $ < N; ++$) c(E[$], D) > 0 && (D = E[$]);
      }
      return r(s(D, i(1, A)), s(z, A));
    }
  }),
  tp = "std",
  $R = ["typed", "map", "sqrt", "variance"],
  R0 = me(tp, $R, (n) => {
    var { typed: e, map: t, sqrt: r, variance: i } = n;
    return e(tp, {
      "Array | Matrix": a,
      "Array | Matrix, string": a,
      "Array | Matrix, number | BigNumber": a,
      "Array | Matrix, number | BigNumber, string": a,
      "...": function (o) {
        return a(o);
      },
    });
    function a(s, o) {
      if (s.length === 0)
        throw new SyntaxError(
          "Function std requires one or more parameters (0 provided)"
        );
      try {
        var c = i.apply(null, arguments);
        return si(c) ? t(c, r) : r(c);
      } catch (u) {
        throw u instanceof TypeError && u.message.includes(" variance")
          ? new TypeError(u.message.replace(" variance", " std"))
          : u;
      }
    }
  }),
  np = "corr",
  jR = [
    "typed",
    "matrix",
    "mean",
    "sqrt",
    "sum",
    "add",
    "subtract",
    "multiply",
    "pow",
    "divide",
  ],
  XR = me(np, jR, (n) => {
    var {
      typed: e,
      matrix: t,
      sqrt: r,
      sum: i,
      add: a,
      subtract: s,
      multiply: o,
      pow: c,
      divide: u,
    } = n;
    return e(np, {
      "Array, Array": function (d, g) {
        return l(d, g);
      },
      "Matrix, Matrix": function (d, g) {
        var x = l(d.toArray(), g.toArray());
        return Array.isArray(x) ? t(x) : x;
      },
    });
    function l(h, d) {
      var g = [];
      if (Array.isArray(h[0]) && Array.isArray(d[0])) {
        if (h.length !== d.length)
          throw new SyntaxError(
            "Dimension mismatch. Array A and B must have the same length."
          );
        for (var x = 0; x < h.length; x++) {
          if (h[x].length !== d[x].length)
            throw new SyntaxError(
              "Dimension mismatch. Array A and B must have the same number of elements."
            );
          g.push(f(h[x], d[x]));
        }
        return g;
      } else {
        if (h.length !== d.length)
          throw new SyntaxError(
            "Dimension mismatch. Array A and B must have the same number of elements."
          );
        return f(h, d);
      }
    }
    function f(h, d) {
      var g = h.length,
        x = i(h),
        m = i(d),
        p = h.reduce((M, T, N) => a(M, o(T, d[N])), 0),
        S = i(h.map((M) => c(M, 2))),
        v = i(d.map((M) => c(M, 2))),
        y = s(o(g, p), o(x, m)),
        E = r(o(s(o(g, S), c(x, 2)), s(o(g, v), c(m, 2))));
      return u(y, E);
    }
  }),
  rp = "format",
  YR = ["typed"],
  ZR = me(rp, YR, (n) => {
    var { typed: e } = n;
    return e(rp, {
      any: hr,
      "any, Object | function | number | BigNumber": hr,
    });
  }),
  JR = /\$([\w.]+)/g,
  ip = "print",
  KR = ["typed"],
  QR = me(ip, KR, (n) => {
    var { typed: e } = n;
    return e(ip, {
      "string, Object | Array": ap,
      "string, Object | Array, number | Object": ap,
    });
  });
function ap(n, e, t) {
  return n.replace(JR, function (r, i) {
    var a = i.split("."),
      s = e[a.shift()];
    for (
      s !== void 0 && s.isMatrix && (s = s.toArray());
      a.length && s !== void 0;

    ) {
      var o = a.shift();
      s = o ? s[o] : s + ".";
    }
    return s !== void 0 ? (Fr(s) ? s : hr(s, t)) : r;
  });
}
var eF = "apply",
  tF = ["typed", "isInteger"],
  nF = me(
    eF,
    tF,
    (n) => {
      var { typed: e, isInteger: t } = n,
        r = ml({ typed: e, isInteger: t });
      return e("apply", {
        "...any": function (a) {
          var s = a[1];
          Dt(s) ? (a[1] = s - 1) : Bt(s) && (a[1] = s.minus(1));
          try {
            return r.apply(null, a);
          } catch (o) {
            throw Yn(o);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  );
function wl(n, e, t) {
  var r = n.filter(function (c) {
    return Rt(c) && !(c.name in e) && !t.has(c.name);
  })[0];
  if (!r)
    throw new Error(
      'No undefined variable found in inline expression "' + n + '"'
    );
  var i = r.name,
    a = new Map(),
    s = new Kg(t, a, new Set([i])),
    o = n.compile();
  return function (u) {
    return a.set(i, u), o.evaluate(s);
  };
}
var rF = "filter",
  iF = ["typed"],
  aF = me(
    rF,
    iF,
    (n) => {
      var { typed: e } = n;
      function t(i, a, s) {
        var o, c;
        return (
          i[0] && (o = i[0].compile().evaluate(s)),
          i[1] &&
            (Rt(i[1]) || xa(i[1])
              ? (c = i[1].compile().evaluate(s))
              : (c = wl(i[1], a, s))),
          r(o, c)
        );
      }
      t.rawArgs = !0;
      var r = e("filter", {
        "Array, function": sp,
        "Matrix, function": function (a, s) {
          return a.create(sp(a.toArray(), s));
        },
        "Array, RegExp": Lo,
        "Matrix, RegExp": function (a, s) {
          return a.create(Lo(a.toArray(), s));
        },
      });
      return t;
    },
    { isTransformFunction: !0 }
  );
function sp(n, e) {
  return m0(n, function (t, r, i) {
    return Ea(e, t, [r + 1], i, "filter");
  });
}
var sF = "forEach",
  oF = ["typed"],
  uF = me(
    sF,
    oF,
    (n) => {
      var { typed: e } = n;
      function t(i, a, s) {
        var o, c;
        return (
          i[0] && (o = i[0].compile().evaluate(s)),
          i[1] &&
            (Rt(i[1]) || xa(i[1])
              ? (c = i[1].compile().evaluate(s))
              : (c = wl(i[1], a, s))),
          r(o, c)
        );
      }
      t.rawArgs = !0;
      var r = e("forEach", {
        "Array | Matrix, function": function (a, s) {
          var o = function c(u, l) {
            if (Array.isArray(u))
              tu(u, function (f, h) {
                c(f, l.concat(h + 1));
              });
            else return Ea(s, u, l, a, "forEach");
          };
          o(a.valueOf(), []);
        },
      });
      return t;
    },
    { isTransformFunction: !0 }
  ),
  cF = "map",
  lF = ["typed"],
  fF = me(
    cF,
    lF,
    (n) => {
      var { typed: e } = n;
      function t(i, a, s) {
        var o, c;
        return (
          i[0] && (o = i[0].compile().evaluate(s)),
          i[1] &&
            (Rt(i[1]) || xa(i[1])
              ? (c = i[1].compile().evaluate(s))
              : (c = wl(i[1], a, s))),
          r(o, c)
        );
      }
      t.rawArgs = !0;
      var r = e("map", {
        "Array, function": function (a, s) {
          return op(a, s, a);
        },
        "Matrix, function": function (a, s) {
          return a.create(op(a.valueOf(), s, a));
        },
      });
      return t;
    },
    { isTransformFunction: !0 }
  );
function op(n, e, t) {
  function r(i, a) {
    return Array.isArray(i)
      ? cr(i, function (s, o) {
          return r(s, a.concat(o + 1));
        })
      : Ea(e, i, a, t, "map");
  }
  return r(n, []);
}
function Sa(n) {
  if (n.length === 2 && si(n[0])) {
    n = n.slice();
    var e = n[1];
    Dt(e) ? (n[1] = e - 1) : Bt(e) && (n[1] = e.minus(1));
  }
  return n;
}
var hF = "max",
  dF = ["typed", "config", "numeric", "larger"],
  pF = me(
    hF,
    dF,
    (n) => {
      var { typed: e, config: t, numeric: r, larger: i } = n,
        a = M0({ typed: e, config: t, numeric: r, larger: i });
      return e("max", {
        "...any": function (o) {
          o = Sa(o);
          try {
            return a.apply(null, o);
          } catch (c) {
            throw Yn(c);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  mF = "mean",
  gF = ["typed", "add", "divide"],
  vF = me(
    mF,
    gF,
    (n) => {
      var { typed: e, add: t, divide: r } = n,
        i = C0({ typed: e, add: t, divide: r });
      return e("mean", {
        "...any": function (s) {
          s = Sa(s);
          try {
            return i.apply(null, s);
          } catch (o) {
            throw Yn(o);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  yF = "min",
  xF = ["typed", "config", "numeric", "smaller"],
  bF = me(
    yF,
    xF,
    (n) => {
      var { typed: e, config: t, numeric: r, smaller: i } = n,
        a = A0({ typed: e, config: t, numeric: r, smaller: i });
      return e("min", {
        "...any": function (o) {
          o = Sa(o);
          try {
            return a.apply(null, o);
          } catch (c) {
            throw Yn(c);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  _F = "range",
  wF = [
    "typed",
    "config",
    "?matrix",
    "?bignumber",
    "smaller",
    "smallerEq",
    "larger",
    "largerEq",
    "add",
    "isPositive",
  ],
  EF = me(
    _F,
    wF,
    (n) => {
      var {
          typed: e,
          config: t,
          matrix: r,
          bignumber: i,
          smaller: a,
          smallerEq: s,
          larger: o,
          largerEq: c,
          add: u,
          isPositive: l,
        } = n,
        f = _0({
          typed: e,
          config: t,
          matrix: r,
          bignumber: i,
          smaller: a,
          smallerEq: s,
          larger: o,
          largerEq: c,
          add: u,
          isPositive: l,
        });
      return e("range", {
        "...any": function (d) {
          var g = d.length - 1,
            x = d[g];
          return typeof x != "boolean" && d.push(!0), f.apply(null, d);
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  SF = "std",
  MF = ["typed", "map", "sqrt", "variance"],
  AF = me(
    SF,
    MF,
    (n) => {
      var { typed: e, map: t, sqrt: r, variance: i } = n,
        a = R0({ typed: e, map: t, sqrt: r, variance: i });
      return e("std", {
        "...any": function (o) {
          o = Sa(o);
          try {
            return a.apply(null, o);
          } catch (c) {
            throw Yn(c);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  up = "sum",
  DF = ["typed", "config", "add", "numeric"],
  TF = me(
    up,
    DF,
    (n) => {
      var { typed: e, config: t, add: r, numeric: i } = n,
        a = D0({ typed: e, config: t, add: r, numeric: i });
      return e(up, {
        "...any": function (o) {
          o = Sa(o);
          try {
            return a.apply(null, o);
          } catch (c) {
            throw Yn(c);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  cp = "cumsum",
  CF = ["typed", "add", "unaryPlus"],
  NF = me(
    cp,
    CF,
    (n) => {
      var { typed: e, add: t, unaryPlus: r } = n,
        i = T0({ typed: e, add: t, unaryPlus: r });
      return e(cp, {
        "...any": function (s) {
          if (s.length === 2 && si(s[0])) {
            var o = s[1];
            Dt(o) ? (s[1] = o - 1) : Bt(o) && (s[1] = o.minus(1));
          }
          try {
            return i.apply(null, s);
          } catch (c) {
            throw Yn(c);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  lp = "variance",
  RF = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"],
  FF = me(
    lp,
    RF,
    (n) => {
      var {
          typed: e,
          add: t,
          subtract: r,
          multiply: i,
          divide: a,
          apply: s,
          isNaN: o,
        } = n,
        c = N0({
          typed: e,
          add: t,
          subtract: r,
          multiply: i,
          divide: a,
          apply: s,
          isNaN: o,
        });
      return e(lp, {
        "...any": function (l) {
          l = Sa(l);
          try {
            return c.apply(null, l);
          } catch (f) {
            throw Yn(f);
          }
        },
      });
    },
    { isTransformFunction: !0 }
  ),
  fp = "clone",
  PF = ["typed"],
  LF = me(fp, PF, (n) => {
    var { typed: e } = n;
    return e(fp, { any: Mr });
  }),
  hp = "isNumeric",
  IF = ["typed"],
  OF = me(hp, IF, (n) => {
    var { typed: e } = n;
    return e(hp, {
      "number | BigNumber | Fraction | boolean": () => !0,
      "Complex | Unit | string | null | undefined | Node": () => !1,
      "Array | Matrix": e.referToSelf((t) => (r) => Sn(r, t)),
    });
  }),
  dp = "hasNumericValue",
  UF = ["typed", "isNumeric"],
  BF = me(dp, UF, (n) => {
    var { typed: e, isNumeric: t } = n;
    return e(dp, {
      boolean: () => !0,
      string: function (i) {
        return i.trim().length > 0 && !isNaN(Number(i));
      },
      any: function (i) {
        return t(i);
      },
    });
  }),
  pp = "typeOf",
  zF = ["typed"],
  kF = me(pp, zF, (n) => {
    var { typed: e } = n;
    return e(pp, { any: Vt });
  }),
  mp = "isPrime",
  HF = ["typed"],
  GF = me(mp, HF, (n) => {
    var { typed: e } = n;
    return e(mp, {
      number: function (r) {
        if (r * 0 !== 0) return !1;
        if (r <= 3) return r > 1;
        if (r % 2 === 0 || r % 3 === 0) return !1;
        for (var i = 5; i * i <= r; i += 6)
          if (r % i === 0 || r % (i + 2) === 0) return !1;
        return !0;
      },
      BigNumber: function (r) {
        if (r.toNumber() * 0 !== 0) return !1;
        if (r.lte(3)) return r.gt(1);
        if (r.mod(2).eq(0) || r.mod(3).eq(0)) return !1;
        if (r.lt(Math.pow(2, 32))) {
          for (var i = r.toNumber(), a = 5; a * a <= i; a += 6)
            if (i % a === 0 || i % (a + 2) === 0) return !1;
          return !0;
        }
        function s(S, v, y) {
          for (var E = 1; !v.eq(0); )
            v.mod(2).eq(0)
              ? ((v = v.div(2)), (S = S.mul(S).mod(y)))
              : ((v = v.sub(1)), (E = S.mul(E).mod(y)));
          return E;
        }
        var o = r.constructor.clone({ precision: r.toFixed(0).length * 2 });
        r = new o(r);
        for (var c = 0, u = r.sub(1); u.mod(2).eq(0); )
          (u = u.div(2)), (c += 1);
        var l = null;
        if (r.lt("3317044064679887385961981"))
          l = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter(
            (S) => S < r
          );
        else {
          var f = Math.min(
            r.toNumber() - 2,
            Math.floor(2 * Math.pow(r.toFixed(0).length * Math.log(10), 2))
          );
          l = [];
          for (var h = 2; h <= f; h += 1) l.push(f);
        }
        for (var d = 0; d < l.length; d += 1) {
          var g = l[d],
            x = s(r.sub(r).add(g), u, r);
          if (!x.eq(1)) {
            for (var m = 0, p = x; !p.eq(r.sub(1)); m += 1, p = p.mul(p).mod(r))
              if (m === c - 1) return !1;
          }
        }
        return !0;
      },
      "Array | Matrix": e.referToSelf((t) => (r) => Sn(r, t)),
    });
  }),
  VF = "numeric",
  WF = ["number", "?bignumber", "?fraction"],
  qF = me(VF, WF, (n) => {
    var { number: e, bignumber: t, fraction: r } = n,
      i = { string: !0, number: !0, BigNumber: !0, Fraction: !0 },
      a = {
        number: (s) => e(s),
        BigNumber: t ? (s) => t(s) : ll,
        Fraction: r ? (s) => r(s) : jg,
      };
    return function (o) {
      var c =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : "number",
        u = arguments.length > 2 ? arguments[2] : void 0;
      if (u !== void 0)
        throw new SyntaxError("numeric() takes one or two arguments");
      var l = Vt(o);
      if (!(l in i))
        throw new TypeError(
          "Cannot convert " +
            o +
            ' of type "' +
            l +
            '"; valid input types are ' +
            Object.keys(i).join(", ")
        );
      if (!(c in a))
        throw new TypeError(
          "Cannot convert " +
            o +
            ' to type "' +
            c +
            '"; valid output types are ' +
            Object.keys(a).join(", ")
        );
      return c === l ? o : a[c](o);
    };
  }),
  $F = "reviver",
  jF = ["classes"],
  XF = me($F, jF, (n) => {
    var { classes: e } = n;
    return function (r, i) {
      var a = e[i && i.mathjs];
      return a && typeof a.fromJSON == "function" ? a.fromJSON(i) : i;
    };
  }),
  YF = "replacer",
  ZF = [],
  JF = me(
    YF,
    ZF,
    () =>
      function (e, t) {
        return typeof t == "number" && (!isFinite(t) || isNaN(t))
          ? { mathjs: "number", value: String(t) }
          : t;
      }
  ),
  KF = Oe("unaryMinus", km),
  QF = Oe("unaryPlus", Hm),
  eP = Oe("abs", zm),
  tP = Oe("addScalar", rl),
  nP = Oe("subtractScalar", il),
  rP = Oe("cbrt", Gm),
  iP = Oe("cube", Vm),
  aP = Oe("exp", Wm),
  sP = Oe("expm1", qm),
  oP = Oe("gcd", $m),
  uP = Oe("lcm", jm),
  cP = Oe("log10", Xm),
  lP = Oe("log2", Ym),
  fP = Oe("mod", Jm),
  hP = Oe("multiplyScalar", al),
  dP = Oe("multiply", al),
  pP = El("nthRoot", jE),
  mP = Oe("sign", Km),
  gP = Oe("sqrt", Qm),
  vP = Oe("square", eg),
  yP = Oe("subtract", il),
  xP = Oe("xgcd", tg),
  bP = Oe("divideScalar", sl),
  _P = Oe("pow", ng),
  wP = El("round", XE),
  EP = El("log", $E),
  SP = Oe("log1p", Zm),
  MP = Oe("add", rl),
  AP = Oe("norm", rg),
  DP = Oe("divide", sl),
  TP = Oe("bitAnd", ig),
  CP = Oe("bitNot", ag),
  NP = Oe("bitOr", sg),
  RP = Oe("bitXor", og),
  FP = Oe("leftShift", ug),
  PP = Oe("rightArithShift", cg),
  LP = Oe("rightLogShift", lg),
  IP = Oe("and", mg),
  OP = Oe("not", hg),
  UP = Oe("or", dg),
  BP = Oe("xor", pg),
  zP = me("index", [], () => uS),
  kP = me("matrix", [], () => fl),
  HP = me("subset", [], () => Xg),
  GP = Oe("combinations", fg),
  VP = Oe("gamma", ul),
  WP = Oe("lgamma", cl),
  qP = Oe("acos", gg),
  $P = Oe("acosh", vg),
  jP = Oe("acot", yg),
  XP = Oe("acoth", xg),
  YP = Oe("acsc", bg),
  ZP = Oe("acsch", _g),
  JP = Oe("asec", wg),
  KP = Oe("asech", Eg),
  QP = Oe("asin", Sg),
  eL = Oe("asinh", Mg),
  tL = Oe("atan", Ag),
  nL = Oe("atan2", Dg),
  rL = Oe("atanh", Tg),
  iL = Oe("cos", Cg),
  aL = Oe("cosh", Ng),
  sL = Oe("cot", Rg),
  oL = Oe("coth", Fg),
  uL = Oe("csc", Pg),
  cL = Oe("csch", Lg),
  lL = Oe("sec", Ig),
  fL = Oe("sech", Og),
  hL = Oe("sin", Ug),
  dL = Oe("sinh", Bg),
  pL = Oe("tan", zg),
  mL = Oe("tanh", kg),
  gL = me("subset", [], () => Xg, { isTransformFunction: !0 }),
  vL = Oe("isInteger", Hg),
  yL = Oe("isNegative", Gg),
  xL = Oe("isPositive", Vg),
  bL = Oe("isZero", Wg),
  _L = Oe("isNaN", qg);
function Oe(n, e) {
  return me(n, ["typed"], (t) => {
    var { typed: r } = t;
    return r(e);
  });
}
function El(n, e) {
  return me(n, ["typed"], (t) => {
    var { typed: r } = t;
    return r({ number: e, "number,number": e });
  });
}
const wL = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      createAbs: eP,
      createAccessorNode: bN,
      createAcos: qP,
      createAcosh: $P,
      createAcot: jP,
      createAcoth: XP,
      createAcsc: YP,
      createAcsch: ZP,
      createAdd: MP,
      createAddScalar: tP,
      createAnd: IP,
      createApply: ml,
      createApplyTransform: nF,
      createArrayNode: wN,
      createAsec: JP,
      createAsech: KP,
      createAsin: QP,
      createAsinh: eL,
      createAssignmentNode: MN,
      createAtan: tL,
      createAtan2: nL,
      createAtanh: rL,
      createBellNumbers: RC,
      createBitAnd: TP,
      createBitNot: CP,
      createBitOr: NP,
      createBitXor: RP,
      createBlockNode: DN,
      createBoolean: dN,
      createCatalan: PC,
      createCbrt: rP,
      createCeil: EC,
      createChain: cT,
      createChainClass: PS,
      createClone: LF,
      createCombinations: GP,
      createCombinationsWithRep: C3,
      createCompare: sR,
      createCompareNatural: cR,
      createCompareText: fR,
      createCompile: s3,
      createComposition: IC,
      createConditionalNode: CN,
      createConstantNode: UN,
      createCorr: XR,
      createCos: iL,
      createCosh: aL,
      createCot: sL,
      createCoth: oL,
      createCsc: uL,
      createCsch: cL,
      createCube: iP,
      createCumSum: T0,
      createCumSumTransform: NF,
      createDeepEqual: bR,
      createDerivative: DT,
      createDivide: DP,
      createDivideScalar: bP,
      createE: XC,
      createEqual: hR,
      createEqualScalar: aR,
      createEqualText: pR,
      createErf: SR,
      createEvaluate: u3,
      createExp: aP,
      createExpm1: sP,
      createFactorial: R3,
      createFalse: GC,
      createFilter: g3,
      createFilterTransform: aF,
      createFix: SC,
      createFloor: MC,
      createForEach: y3,
      createForEachTransform: uF,
      createFormat: ZR,
      createFunctionAssignmentNode: zN,
      createFunctionNode: n3,
      createGamma: VP,
      createGcd: oP,
      createHasNumericValue: BF,
      createHelp: oT,
      createHelpClass: NS,
      createHypot: DC,
      createIndex: zP,
      createIndexNode: HN,
      createInfinity: WC,
      createIsInteger: vL,
      createIsNaN: _L,
      createIsNegative: yL,
      createIsNumeric: OF,
      createIsPositive: xL,
      createIsPrime: GF,
      createIsZero: bL,
      createLN10: JC,
      createLN2: ZC,
      createLOG10E: QC,
      createLOG2E: KC,
      createLarger: vR,
      createLargerEq: yR,
      createLcm: uP,
      createLeftShift: FP,
      createLgamma: WP,
      createLog: EP,
      createLog10: cP,
      createLog1p: SP,
      createLog2: lP,
      createMad: GR,
      createMap: _3,
      createMapTransform: fF,
      createMatrix: kP,
      createMax: M0,
      createMaxTransform: pF,
      createMean: C0,
      createMeanTransform: vF,
      createMedian: kR,
      createMin: A0,
      createMinTransform: bF,
      createMod: fP,
      createMode: RR,
      createMultinomial: P3,
      createMultiply: dP,
      createMultiplyScalar: hP,
      createNaN: qC,
      createNode: yN,
      createNorm: AP,
      createNot: OP,
      createNthRoot: pP,
      createNull: VC,
      createNumber: cN,
      createNumeric: qF,
      createObjectNode: VN,
      createOperatorNode: qN,
      createOr: UP,
      createParenthesisNode: jN,
      createParse: i3,
      createParser: mN,
      createParserClass: f3,
      createPartitionSelect: D3,
      createPermutations: I3,
      createPhi: YC,
      createPi: $C,
      createPickRandom: tR,
      createPow: _P,
      createPrint: QR,
      createProd: PR,
      createQuantileSeq: qR,
      createRandom: nR,
      createRandomInt: iR,
      createRange: _0,
      createRangeClass: wS,
      createRangeNode: YN,
      createRangeTransform: EF,
      createRationalize: CT,
      createRelationalNode: JN,
      createReplacer: JF,
      createResolve: hT,
      createResultSet: xS,
      createReviver: XF,
      createRightArithShift: PP,
      createRightLogShift: LP,
      createRound: wP,
      createSQRT1_2: eN,
      createSQRT2: tN,
      createSec: lL,
      createSech: fL,
      createSign: mP,
      createSimplify: xT,
      createSimplifyConstant: wT,
      createSimplifyCore: MT,
      createSin: hL,
      createSinh: dL,
      createSize: M3,
      createSmaller: mR,
      createSmallerEq: gR,
      createSqrt: gP,
      createSquare: vP,
      createStd: R0,
      createStdTransform: AF,
      createStirlingS2: CC,
      createString: fN,
      createSubset: HP,
      createSubsetTransform: gL,
      createSubtract: yP,
      createSubtractScalar: nP,
      createSum: D0,
      createSumTransform: TF,
      createSymbolNode: e3,
      createTan: pL,
      createTanh: mL,
      createTau: jC,
      createTrue: HC,
      createTypeOf: kF,
      createTyped: mS,
      createUnaryMinus: KF,
      createUnaryPlus: QF,
      createUnequal: _R,
      createUppercaseE: rN,
      createUppercasePi: nN,
      createVariance: N0,
      createVarianceTransform: FF,
      createVersion: iN,
      createXgcd: xP,
      createXor: BP,
      createZeta: CR,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function vi(n, e, t, r) {
  if (!(this instanceof vi))
    throw new SyntaxError("Constructor must be called with the new operator");
  (this.fn = n),
    (this.count = e),
    (this.min = t),
    (this.max = r),
    (this.message =
      "Wrong number of arguments in function " +
      n +
      " (" +
      e +
      " provided, " +
      t +
      (r != null ? "-" + r : "") +
      " expected)"),
    (this.stack = new Error().stack);
}
vi.prototype = new Error();
vi.prototype.constructor = Error;
vi.prototype.name = "ArgumentsError";
vi.prototype.isArgumentsError = !0;
var EL = wL,
  Sl = { exports: {} };
function Ml() {}
Ml.prototype = {
  on: function (n, e, t) {
    var r = this.e || (this.e = {});
    return (r[n] || (r[n] = [])).push({ fn: e, ctx: t }), this;
  },
  once: function (n, e, t) {
    var r = this;
    function i() {
      r.off(n, i), e.apply(t, arguments);
    }
    return (i._ = e), this.on(n, i, t);
  },
  emit: function (n) {
    var e = [].slice.call(arguments, 1),
      t = ((this.e || (this.e = {}))[n] || []).slice(),
      r = 0,
      i = t.length;
    for (r; r < i; r++) t[r].fn.apply(t[r].ctx, e);
    return this;
  },
  off: function (n, e) {
    var t = this.e || (this.e = {}),
      r = t[n],
      i = [];
    if (r && e)
      for (var a = 0, s = r.length; a < s; a++)
        r[a].fn !== e && r[a].fn._ !== e && i.push(r[a]);
    return i.length ? (t[n] = i) : delete t[n], this;
  },
};
Sl.exports = Ml;
Sl.exports.TinyEmitter = Ml;
var SL = Sl.exports;
const ML = gs(SL);
function AL(n) {
  var e = new ML();
  return (
    (n.on = e.on.bind(e)),
    (n.off = e.off.bind(e)),
    (n.once = e.once.bind(e)),
    (n.emit = e.emit.bind(e)),
    n
  );
}
function DL(n, e, t, r) {
  function i(m, p) {
    var S = arguments.length;
    if (S !== 1 && S !== 2) throw new vi("import", S, 1, 2);
    p || (p = {});
    function v(T, N, A) {
      if (Array.isArray(N)) N.forEach(($) => v(T, $));
      else if (typeof N == "object") for (var D in N) Ve(N, D) && v(T, N[D], D);
      else if (Ka(N) || A !== void 0) {
        var z = Ka(N) ? (g(N) ? N.fn + ".transform" : N.fn) : A;
        if (Ve(T, z) && T[z] !== N && !p.silent)
          throw new Error('Cannot import "' + z + '" twice');
        T[z] = N;
      } else if (!p.silent)
        throw new TypeError("Factory, Object, or Array expected");
    }
    var y = {};
    v(y, m);
    for (var E in y)
      if (Ve(y, E)) {
        var M = y[E];
        if (Ka(M)) u(M, p);
        else if (l(M)) a(E, M, p);
        else if (!p.silent)
          throw new TypeError("Factory, Object, or Array expected");
      }
  }
  function a(m, p, S) {
    if (
      (S.wrap && typeof p == "function" && (p = c(p)),
      f(p) && (p = n(m, { [p.signature]: p })),
      n.isTypedFunction(t[m]) && n.isTypedFunction(p))
    ) {
      S.override ? (p = n(m, p.signatures)) : (p = n(t[m], p)),
        (t[m] = p),
        delete r[m],
        s(m, p),
        t.emit("import", m, function () {
          return p;
        });
      return;
    }
    if (t[m] === void 0 || S.override) {
      (t[m] = p),
        delete r[m],
        s(m, p),
        t.emit("import", m, function () {
          return p;
        });
      return;
    }
    if (!S.silent) throw new Error('Cannot import "' + m + '": already exists');
  }
  function s(m, p) {
    p && typeof p.transform == "function"
      ? ((t.expression.transform[m] = p.transform),
        h(m) && (t.expression.mathWithTransform[m] = p.transform))
      : (delete t.expression.transform[m],
        h(m) && (t.expression.mathWithTransform[m] = p));
  }
  function o(m) {
    delete t.expression.transform[m],
      h(m)
        ? (t.expression.mathWithTransform[m] = t[m])
        : delete t.expression.mathWithTransform[m];
  }
  function c(m) {
    var p = function () {
      for (var v = [], y = 0, E = arguments.length; y < E; y++) {
        var M = arguments[y];
        v[y] = M && M.valueOf();
      }
      return m.apply(t, v);
    };
    return m.transform && (p.transform = m.transform), p;
  }
  function u(m, p) {
    var S =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : m.fn;
    if (S.includes("."))
      throw new Error(
        "Factory name should not contain a nested path. Name: " +
          JSON.stringify(S)
      );
    var v = g(m) ? t.expression.transform : t,
      y = S in t.expression.transform,
      E = Ve(v, S) ? v[S] : void 0,
      M = function () {
        var N = {};
        m.dependencies.map($g).forEach((D) => {
          if (D.includes("."))
            throw new Error(
              "Factory dependency should not contain a nested path. Name: " +
                JSON.stringify(D)
            );
          D === "math"
            ? (N.math = t)
            : D === "mathWithTransform"
            ? (N.mathWithTransform = t.expression.mathWithTransform)
            : D === "classes"
            ? (N.classes = t)
            : (N[D] = t[D]);
        });
        var A = m(N);
        if (A && typeof A.transform == "function")
          throw new Error(
            'Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path="expression.transform"'
          );
        if (E === void 0 || p.override) return A;
        if (n.isTypedFunction(E) && n.isTypedFunction(A)) return n(E, A);
        if (p.silent) return E;
        throw new Error('Cannot import "' + S + '": already exists');
      };
    !m.meta || m.meta.lazy !== !1
      ? (wo(v, S, M),
        E && y
          ? o(S)
          : (g(m) || d(m)) && wo(t.expression.mathWithTransform, S, () => v[S]))
      : ((v[S] = M()),
        E && y
          ? o(S)
          : (g(m) || d(m)) &&
            wo(t.expression.mathWithTransform, S, () => v[S])),
      (r[S] = m),
      t.emit("import", S, M);
  }
  function l(m) {
    return (
      typeof m == "function" ||
      typeof m == "number" ||
      typeof m == "string" ||
      typeof m == "boolean" ||
      m === null ||
      jo(m) ||
      ya(m) ||
      Bt(m) ||
      vs(m) ||
      tn(m) ||
      Array.isArray(m)
    );
  }
  function f(m) {
    return typeof m == "function" && typeof m.signature == "string";
  }
  function h(m) {
    return !Ve(x, m);
  }
  function d(m) {
    return !m.fn.includes(".") && !Ve(x, m.fn) && (!m.meta || !m.meta.isClass);
  }
  function g(m) {
    return (
      (m !== void 0 &&
        m.meta !== void 0 &&
        m.meta.isTransformFunction === !0) ||
      !1
    );
  }
  var x = {
    expression: !0,
    type: !0,
    docs: !0,
    error: !0,
    json: !0,
    chain: !0,
  };
  return i;
}
function F0(n, e) {
  var t = ir({}, xm, e);
  if (typeof Object.create != "function")
    throw new Error(
      "ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility."
    );
  var r = AL({
    isNumber: Dt,
    isComplex: ya,
    isBigNumber: Bt,
    isFraction: vs,
    isUnit: jo,
    isString: Fr,
    isArray: el,
    isMatrix: tn,
    isCollection: si,
    isDenseMatrix: Co,
    isSparseMatrix: Yi,
    isRange: bm,
    isIndex: _m,
    isBoolean: wm,
    isResultSet: Em,
    isHelp: tl,
    isFunction: Sm,
    isDate: Mm,
    isRegExp: Am,
    isObject: ys,
    isNull: Dm,
    isUndefined: Tm,
    isAccessorNode: Pr,
    isArrayNode: pn,
    isAssignmentNode: Cm,
    isBlockNode: Nm,
    isConditionalNode: Rm,
    isConstantNode: Qe,
    isFunctionAssignmentNode: xa,
    isFunctionNode: fr,
    isIndexNode: pi,
    isNode: at,
    isObjectNode: xs,
    isOperatorNode: Et,
    isParenthesisNode: Wn,
    isRangeNode: Fm,
    isRelationalNode: Pm,
    isSymbolNode: Rt,
    isChain: nl,
  });
  (r.config = NE(t, r.emit)),
    (r.expression = { transform: {}, mathWithTransform: { config: r.config } });
  var i = [],
    a = [];
  function s(l) {
    if (Ka(l)) return l(r);
    var f = l[Object.keys(l)[0]];
    if (Ka(f)) return f(r);
    if (!TE(l))
      throw (
        (console.warn(
          "Factory object with properties `type`, `name`, and `factory` expected",
          l
        ),
        new Error(
          "Factory object with properties `type`, `name`, and `factory` expected"
        ))
      );
    var h = i.indexOf(l),
      d;
    return (
      h === -1
        ? (l.math === !0
            ? (d = l.factory(r.type, t, s, r.typed, r))
            : (d = l.factory(r.type, t, s, r.typed)),
          i.push(l),
          a.push(d))
        : (d = a[h]),
      d
    );
  }
  var o = {};
  function c() {
    for (var l = arguments.length, f = new Array(l), h = 0; h < l; h++)
      f[h] = arguments[h];
    return r.typed.apply(r.typed, f);
  }
  c.isTypedFunction = Kr.isTypedFunction;
  var u = DL(c, s, r, o);
  return (
    (r.import = u),
    r.on("config", () => {
      Object.values(o).forEach((l) => {
        l && l.meta && l.meta.recreateOnConfigChange && u(l, { override: !0 });
      });
    }),
    (r.create = F0.bind(null, n)),
    (r.factory = me),
    r.import(Object.values(DE(n))),
    (r.ArgumentsError = vi),
    (r.DimensionError = _a),
    (r.IndexError = Xn),
    r
  );
}
const gp = F0(EL, {});
function TL(n) {
  return n[Math.floor(n.length * Math.random())];
}
function Gi(n) {
  return n[0];
}
const CL = {
  Lexer: void 0,
  ParserRules: [
    { name: "main", symbols: ["axiom", "_"], postprocess: Gi },
    { name: "main", symbols: ["some_prod", "_"], postprocess: Gi },
    {
      name: "some_prod",
      symbols: [
        "prod",
        "_",
        {
          literal: `
`,
        },
        "_",
        "some_prod",
      ],
      postprocess: ([n, e, t, r, i]) => [n].concat(i),
    },
    { name: "some_prod", symbols: ["prod"] },
    {
      name: "prod$string$1",
      symbols: [{ literal: "-" }, { literal: ">" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    {
      name: "prod",
      symbols: ["expression", "_", "prod$string$1", "_", "some_exp"],
      postprocess: ([n, e, t, r, i]) => ({ lhs: n, rhs: i, production: !0 }),
    },
    {
      name: "axiom",
      symbols: ["some_exp"],
      postprocess: ([n]) => ({ val: n, axiom: !0 }),
    },
    {
      name: "some_exp",
      symbols: ["expression", "__", "some_exp"],
      postprocess: ([n, e, t]) => [n].concat(t),
    },
    { name: "some_exp", symbols: ["expression"] },
    { name: "expression", symbols: ["command"], postprocess: Gi },
    { name: "expression", symbols: ["variable"], postprocess: Gi },
    {
      name: "variable",
      symbols: ["variableSymbol", "parameters"],
      postprocess: ([n, e]) => ({ sym: n, params: e }),
    },
    {
      name: "command",
      symbols: ["commandSymbol", "parameters"],
      postprocess: ([n, e]) => ({ sym: n[0], params: e, command: !0 }),
    },
    { name: "variableSymbol", symbols: ["upper"], postprocess: Gi },
    {
      name: "commandSymbol$string$1",
      symbols: [{ literal: "+" }, { literal: "x" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$1"] },
    {
      name: "commandSymbol$string$2",
      symbols: [{ literal: "-" }, { literal: "x" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$2"] },
    {
      name: "commandSymbol$string$3",
      symbols: [{ literal: "+" }, { literal: "y" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$3"] },
    {
      name: "commandSymbol$string$4",
      symbols: [{ literal: "-" }, { literal: "y" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$4"] },
    {
      name: "commandSymbol$string$5",
      symbols: [{ literal: "+" }, { literal: "z" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$5"] },
    {
      name: "commandSymbol$string$6",
      symbols: [{ literal: "-" }, { literal: "z" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$6"] },
    {
      name: "commandSymbol$string$7",
      symbols: [
        { literal: "s" },
        { literal: "p" },
        { literal: "h" },
        { literal: "e" },
        { literal: "r" },
        { literal: "e" },
      ],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$7"] },
    {
      name: "commandSymbol$string$8",
      symbols: [{ literal: "b" }, { literal: "o" }, { literal: "x" }],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$8"] },
    {
      name: "commandSymbol$string$9",
      symbols: [
        { literal: "c" },
        { literal: "u" },
        { literal: "b" },
        { literal: "e" },
      ],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$9"] },
    {
      name: "commandSymbol$string$10",
      symbols: [
        { literal: "c" },
        { literal: "o" },
        { literal: "n" },
        { literal: "e" },
      ],
      postprocess: function (e) {
        return e.join("");
      },
    },
    { name: "commandSymbol", symbols: ["commandSymbol$string$10"] },
    { name: "commandSymbol", symbols: [{ literal: "[" }] },
    { name: "commandSymbol", symbols: [{ literal: "]" }] },
    { name: "commandSymbol", symbols: [{ literal: "s" }] },
    { name: "commandSymbol", symbols: [{ literal: "e" }] },
    { name: "commandSymbol", symbols: [{ literal: "f" }] },
    { name: "commandSymbol", symbols: [{ literal: "l" }] },
    { name: "commandSymbol", symbols: [{ literal: "r" }] },
    { name: "commandSymbol", symbols: [{ literal: "t" }] },
    { name: "commandSymbol", symbols: [{ literal: "m" }] },
    {
      name: "parameters",
      symbols: [{ literal: "{" }, "some_params", { literal: "}" }],
      postprocess: (n) => n[1],
    },
    { name: "parameters", symbols: [] },
    {
      name: "some_params",
      symbols: ["param", { literal: "," }, "some_params"],
      postprocess: ([n, e, t]) => [n].concat(t),
    },
    { name: "some_params", symbols: ["param"] },
    { name: "param$ebnf$1", symbols: [/[a-zA-Z0-9 +\-*\/!^&|~><()\.]/] },
    {
      name: "param$ebnf$1",
      symbols: ["param$ebnf$1", /[a-zA-Z0-9 +\-*\/!^&|~><()\.]/],
      postprocess: function (e) {
        return e[0].concat([e[1]]);
      },
    },
    {
      name: "param",
      symbols: ["param$ebnf$1"],
      postprocess: (n) => n[0].join("").trim(),
    },
    { name: "upper$ebnf$1", symbols: [/[A-Z]/] },
    {
      name: "upper$ebnf$1",
      symbols: ["upper$ebnf$1", /[A-Z]/],
      postprocess: function (e) {
        return e[0].concat([e[1]]);
      },
    },
    {
      name: "upper",
      symbols: ["upper$ebnf$1"],
      postprocess: (n) => n[0].join(""),
    },
    { name: "_$ebnf$1", symbols: [] },
    {
      name: "_$ebnf$1",
      symbols: ["_$ebnf$1", "wschar"],
      postprocess: function (e) {
        return e[0].concat([e[1]]);
      },
    },
    {
      name: "_",
      symbols: ["_$ebnf$1"],
      postprocess: function (n) {
        return null;
      },
    },
    { name: "__$ebnf$1", symbols: ["wschar"] },
    {
      name: "__$ebnf$1",
      symbols: ["__$ebnf$1", "wschar"],
      postprocess: function (e) {
        return e[0].concat([e[1]]);
      },
    },
    {
      name: "__",
      symbols: ["__$ebnf$1"],
      postprocess: function (n) {
        return null;
      },
    },
    { name: "wschar", symbols: [/[ \t\n\v\f]/], postprocess: Gi },
  ],
  ParserStart: "main",
};
function NL(n) {
  return (n.name = "SyntaxError"), n;
}
function vp(n) {
  try {
    const e = new Ch.Parser(Ch.Grammar.fromCompiled(CL));
    e.feed(n);
    const t = e.results;
    if (t.length === 0) throw new SyntaxError("Unexpected end of input.");
    return t[0];
  } catch (e) {
    throw NL(e);
  }
}
function RL(n, e, t) {
  let r = {},
    i = [];
  try {
    if (((r = vp(n)), !r.axiom))
      throw new Error("Enter an axiom not a production.");
  } catch (c) {
    throw new Error("Error parsing axiom.", { cause: c });
  }
  try {
    if (((i = vp(e)), i.axiom))
      throw new Error("Enter a production not an axiom.");
  } catch (c) {
    throw new Error("Error parsing production.", { cause: c });
  }
  const a = i;
  let s = {};
  for (const [c, u] of a.entries()) {
    const l = u.lhs.sym;
    Array.isArray(s[l]) ? s[l].push(c) : (s[l] = [c]);
  }
  let o = r.val;
  for (const c of o) c.params = gp.evaluate(c.params);
  for (let c = 0; c < t; ++c)
    o = o.flatMap((u) => {
      const l = u.sym;
      if (!s[l]) return u;
      const f = a[TL(s[l])],
        h = {};
      for (let g = 0; g < f.lhs.params.length; ++g)
        h[f.lhs.params[g]] = u.params[g];
      const d = f.rhs.map((g) => Object.assign({}, g));
      for (const g of d) g.params = gp.evaluate(g.params, h);
      return d;
    });
  return o;
}
function FL(n, e) {
  Object.keys(e)
    .filter((t) => t in n)
    .forEach((t) => (n[t] = e[t]));
}
const PL = Object.freeze({ length: 0.2, angle: 25, radius: 0.05, size: 0.3 });
function P0(n, e = void 0, t = 16160195, r = 5852464) {
  let i = {
      axiom: `m{${r}, 0.9, 0} A{0.2}`,
      productions: `A{r} -> l{0.2, r, r} +x +y +z [ [ A{r/2} ] -x A{r/2} ] -x -y -z l{0.2, r, r} [ -x l{0.2, r, r/2} A{r/2} m{${t}, 0.7, 0, true} sphere ] +x A{r/2}

      l{a, b, c} -> l{a*2.5, b, c}

      l{a, b, c} -> l{a*2, b, c}

      sphere -> sphere{random()/7+0.1}`,
    },
    a = new Nc();
  return a.generate(RL(i.axiom, i.productions, n), t, e), a;
}
const Qa = class Qa {
  constructor() {
    fn(this, "scene");
    fn(this, "light");
    fn(this, "material");
    fn(this, "materials");
    fn(this, "geometries");
    fn(this, "pos");
    fn(this, "dir");
    fn(this, "tension");
    fn(this, "radius");
    (this.lights = []),
      (this.group = new ka()),
      (this.anchor = this.group),
      (this.materials = []),
      (this.geometries = []),
      (this.defaults = Object.assign({}, Qa.defaults)),
      (this.tmpVec = new B()),
      this.reset(),
      (this.count = 0),
      (this.fruitMass = new B());
  }
  getPos() {
    return this.object.getWorldPosition(this.tmpVec);
  }
  getDir() {
    return this.object.getWorldDirection(this.tmpVec);
  }
  reset() {
    return (
      (this.object = new st()),
      this.object.lookAt(new B(0, 1, 0)),
      (this.tension = 0.5),
      (this.radius = this.defaults.radius),
      (this.stack = []),
      (this.currentCurve = []),
      this.lights.forEach((e) => e.dispose()),
      this.materials.forEach((e) => e.dispose()),
      this.geometries.forEach((e) => e.dispose()),
      (this.lights = []),
      (this.group.children = []),
      (this.materials = []),
      (this.geometries = []),
      this.resetMaterial(),
      this
    );
  }
  resetMaterial() {
    return this.setMaterial(), this;
  }
  setDefaults(e = {}) {
    return FL(this.defaults, e), this;
  }
  setMaterial(
    e = 16777215,
    t = 0.1,
    r = 0.1,
    i = !1,
    a = !1,
    s = !0,
    o = !1,
    c = !1,
    u = 1,
    l = 0
  ) {
    const f = [lr, en, jt];
    return (
      (this.material = new Hw({
        color: e,
        roughness: t,
        metalness: r,
        flatShading: a,
        fog: s,
        wireframe: o,
        transparent: c,
        opacity: u,
        side: f[l],
        emissive: e,
        emissiveIntensity: i ? 1.2 : 0,
      })),
      this.materials.push(this.material),
      this
    );
  }
  setTension(e = 0.5) {
    return (this.tension = e), this;
  }
  setRadius(e = this.defaults.radius) {
    return (this.radius = e), this;
  }
  forward(e = this.defaults.length) {
    return (
      this.object.translateZ(e),
      this.drawing && this.currentCurve.push(this.getPos().clone()),
      this
    );
  }
  rotateX(e = this.defaults.angle) {
    return this.object.rotateX(Ba.degToRad(e)), this;
  }
  rotateY(e = this.defaults.angle) {
    return this.object.rotateY(Ba.degToRad(e)), this;
  }
  rotateZ(e = this.defaults.angle) {
    return this.object.rotateZ(Ba.degToRad(e)), this;
  }
  startLine() {
    return this.drawing
      ? this
      : ((this.drawing = !0),
        this.currentCurve.push(this.getPos().clone()),
        this);
  }
  endLine() {
    if (!this.drawing) return this;
    if (((this.drawing = !1), this.currentCurve.length <= 1))
      return (this.currentCurve.length = 0), this;
    const e = new Qp(this.currentCurve, !1, "catmullrom", this.tension),
      t = this.currentCurve.length * 5,
      r = new Jc(e, t, this.radius, 8, !1);
    this.geometries.push(r);
    const i = new Re(r, this.material);
    return (
      (i.castShadow = !0),
      (i.receiveShadow = !0),
      this.group.add(i),
      (this.currentCurve.length = 0),
      this
    );
  }
  line(e = this.defaults.length, t = this.radius, r = this.radius) {
    const i = new Ot(r, t, e);
    this.geometries.push(i);
    const a = new Re(i, this.material);
    return (
      (a.castShadow = !0),
      (a.receiveShadow = !0),
      a.lookAt(this.getDir()),
      a.geometry.rotateX(Math.PI / 2),
      a.position.copy(this.getPos()),
      a.geometry.translate(0, 0, e / 2),
      this.group.add(a),
      this.forward(e),
      this
    );
  }
  push() {
    return (
      this.drawing && (this.endLine(), this.startLine()),
      this.stack.push({
        object: this.object.clone(!1),
        material: this.material,
        tension: this.tension,
        radius: this.radius,
      }),
      this
    );
  }
  pop() {
    this.drawing && (this.endLine(), this.startLine());
    const e = this.stack.pop();
    return e ? (Object.assign(this, e), this) : this;
  }
  sphere(e = this.defaults.size / 2, t = 12, r = 6, ...i) {
    const a = new di(e, t, r, ...i);
    this.geometries.push(a);
    const s = new Re(a, this.material);
    return (
      s.geometry.rotateX(Math.PI / 2),
      s.lookAt(this.getDir()),
      s.position.copy(this.getPos()),
      (s.castShadow = !0),
      (s.receiveShadow = !0),
      this.group.add(s),
      this.count++,
      this.fruitMass.add(this.getPos()),
      this
    );
  }
  box(
    e = this.defaults.size,
    t = this.defaults.size,
    r = this.defaults.size,
    ...i
  ) {
    const a = new mt(e, t, r, ...i);
    this.geometries.push(a);
    const s = new Re(a, this.material);
    return (
      (s.castShadow = !0),
      (s.receiveShadow = !0),
      s.lookAt(this.getDir()),
      s.position.copy(this.getPos()),
      this.group.add(s),
      this
    );
  }
  cube(e = this.defaults.size, ...t) {
    return this.box(e, e, e, ...t), this;
  }
  cone(e = this.defaults.size / 2, t = this.defaults.size, ...r) {
    const i = new Xc(e, t, ...r);
    this.geometries.push(i);
    const a = new Re(i, this.material);
    return (
      (a.castShadow = !0),
      (a.receiveShadow = !0),
      a.geometry.rotateX(Math.PI / 2),
      a.lookAt(this.getDir()),
      a.position.copy(this.getPos()),
      this.group.add(a),
      this
    );
  }
  do(e) {
    switch (e.sym) {
      case "+x":
        this.rotateX(e.params[0]);
        break;
      case "-x":
        this.rotateX(-(e.params[0] ?? this.defaults.angle));
        break;
      case "+y":
        this.rotateY(e.params[0]);
        break;
      case "-y":
        this.rotateY(-(e.params[0] ?? this.defaults.angle));
        break;
      case "+z":
        this.rotateZ(e.params[0]);
        break;
      case "-z":
        this.rotateZ(-(e.params[0] ?? this.defaults.angle));
        break;
      case "f":
        this.forward(...e.params);
        break;
      case "s":
        this.startLine();
        break;
      case "e":
        this.endLine();
        break;
      case "l":
        this.line(...e.params);
        break;
      case "[":
        this.push();
        break;
      case "]":
        this.pop();
        break;
      case "sphere":
        this.sphere(...e.params);
        break;
      case "box":
        this.box(...e.params);
        break;
      case "cube":
        this.cube(...e.params);
        break;
      case "cone":
        this.cone(...e.params);
        break;
      case "r":
        this.setRadius(...e.params);
        break;
      case "t":
        this.setTension(...e.params);
        break;
      case "m":
        this.setMaterial(...e.params);
        break;
    }
  }
  generate(e, t, r) {
    this.setDefaults(Qa.defaults), this.reset();
    for (const o of e) this.do(o);
    this.group.rotation.y = Ba.degToRad(0);
    const i = new Ir().setFromObject(this.group),
      a = new B();
    i.getCenter(a),
      a.setX(0),
      (this.hitbox = new Un()),
      this.hitbox.handler(r, this.hitbox.mesh, this.anchor),
      this.anchor.add(this.hitbox.mesh);
    let s = new os(t, 5e3, 0, 1.5);
    s.position.copy(this.fruitMass.divideScalar(Math.max(this.count, 1))),
      this.anchor.add(s),
      (this.light = s);
  }
};
fn(Qa, "defaults", PL);
let Nc = Qa,
  LL = "random";
const Ua = 50,
  L0 = 20,
  yp = L0;
class IL {
  constructor() {
    (this.settings = {}),
      (this.generations = []),
      (this.currentGen = 0),
      (this.ruleNb = 0),
      (this.ruleset = []),
      (this.anchor = new st()),
      (this.planes = []);
  }
  generate(e, t) {
    this.update(), this.draw(e, t);
  }
  update() {
    this.randomRuleset(), this.updateState();
  }
  updateState() {
    let e = this.setInitialState(LL);
    this.generations.push(e);
  }
  draw(e, t = yp) {
    for (let r = 0; r < t; r++) this.drawAllGen(e), this.calculateNextGen();
  }
  drawAllGen(e) {
    let t = new ga(Ua, Ua),
      r = new Or({ color: e, side: jt }),
      i = this.generations.flat().filter((o) => o === 1).length,
      a = new Jp(t, r, i),
      s = 0;
    for (let o = 0; o <= this.currentGen; o++)
      for (let c = 0; c < L0; c++)
        this.generations[o][c] === 1 &&
          (a.setMatrixAt(s, new ut().setPosition(c * Ua, -o * Ua, 0)), s++);
    this.planes.push(a), this.anchor.add(a);
  }
  calculateNextGen() {
    let e = [],
      t = this.generations[this.currentGen];
    for (let r = 0; r < t.length; r++) {
      let i, a, s;
      r === 0
        ? ((i = t[t.length - 1]), (s = t[r + 1]))
        : r === t.length - 1
        ? ((i = t[r - 1]), (s = t[0]))
        : ((i = t[r - 1]), (s = t[r + 1])),
        (a = t[r]),
        (e[r] = this.applyRule(i, a, s));
    }
    this.currentGen < yp && this.currentGen++,
      (this.generations[this.currentGen] = e);
  }
  setInitialState(e) {
    let t = [];
    if (
      ((t = Array(Math.floor(window.innerWidth / Ua)).fill(0)), e == "centered")
    )
      t[Math.floor(t.length / 2)] = 1;
    else if (e == "random")
      for (let r = 0; r < t.length; r++)
        Math.random() < 0.5 ? (t[r] = 0) : (t[r] = 1);
    return t;
  }
  randomRuleset() {
    for (let e = 0; e < 8; e++)
      Math.random() < 0.5 ? (this.ruleset[e] = 0) : (this.ruleset[e] = 1),
        (this.ruleNb += this.ruleset[e] * Math.pow(2, e));
  }
  applyRule(e, t, r) {
    let i = e * 4 + t * 2 + r * 1;
    return this.ruleset[i];
  }
}
const OL = 5313208,
  UL = 16777215,
  oc = 6688739,
  BL = 7222506;
class zL {
  constructor() {
    this.anchor = new st();
  }
  buildGround() {
    this.addGrid(),
      this.addSoils(),
      this.addWolframGrass(),
      this.addSierpinskiGrass();
  }
  addSoils() {
    this.addSoil(40, OL, -0.5 - 40 / 2),
      this.addSoil(40 * 2.5, BL, -0.5 - 40 * 2.25),
      this.addSoil(40 * 3.5, oc, -0.5 - 40 * 5.25);
  }
  addSoil(e, t, r) {
    const s = new mt(1e3, e, 1e3),
      o = new Or({ color: t, opacity: 1, side: jt }),
      c = new Re(s, o);
    (c.position.y = r), this.anchor.add(c);
  }
  addGrid() {
    this.gridHelper = new Jw(1e3, 20);
    const e = new hi({ color: UL, opacity: 0.25, transparent: !0 });
    (this.gridHelper.material = e), (this.gridHelper.position.y = 2);
  }
  addSierpinskiGrass() {
    const e = new SE(oc);
    e.generate2dSierpinski(),
      (e.anchor.position.y = 1),
      this.anchor.add(e.anchor);
  }
  addWolframGrass() {
    const e = new IL();
    e.generate(oc),
      this.anchor.add(e.anchor),
      (e.anchor.position.x = -475),
      (e.anchor.position.z = 475),
      (e.anchor.position.y = 0),
      (e.anchor.rotation.x = Math.PI / 2);
  }
}
function I0(n) {
  switch (n) {
    case "lorenz":
      return { loopNb: 1e4, scale: 4 };
    case "rossler":
      return { loopNb: 1e4, scale: 8 };
    case "aizawa":
      return { loopNb: 15e3, scale: 50 };
    case "arneodo":
      return { loopNb: 15e3, scale: 10 };
    case "sprottB":
      return { loopNb: 2e4, scale: 15 };
    case "sprottLinzF":
      return { loopNb: 15e3, scale: 30 };
    case "halvorsen":
      return { loopNb: 1e4, scale: 8 };
  }
}
const kL = document.getElementById("content");
function Vi(n, e) {
  const t = new Zp();
  t.name = n;
  const r = document.createElement("div");
  r.className = "list-item";
  const i = document.createElement("div");
  r.appendChild(i),
    (t.userData.element = i),
    (t.userData.root = r),
    kL.appendChild(r);
  const a = new an(50, 1, 1, 10);
  (a.position.z = 2), (t.userData.camera = a);
  const s = new fm(t.userData.camera, t.userData.element);
  (s.minDistance = 2),
    (s.maxDistance = 5),
    (s.enablePan = !1),
    (s.enableZoom = !1),
    (t.userData.controls = s),
    t.add(e),
    t.add(new jw(11184810, 4473924, 3));
  const o = new cm(16777215, 1.5);
  return o.position.set(1, 1, 1), t.add(o), t;
}
async function HL(n, e) {
  let t = [],
    r = {},
    i;
  const a = [
    "lorenz",
    "rossler",
    "aizawa",
    "arneodo",
    "sprottB",
    "sprottLinzF",
    "halvorsen",
  ];
  let s,
    o = new pm();
  o.create(2),
    o.anchor.remove(o.hitbox.mesh),
    (o.centerPointLight.intensity = 1),
    (s = Vi("Sponge", o.anchor)),
    (r.sponge = s),
    t.push(s),
    (r.attractor = {}),
    a.forEach((u) => {
      o = new vm();
      const { loopNb: l, scale: f } = I0(u);
      o.instantDraw(u, l);
      const h = 0.009 * f;
      o.anchor.scale.set(h, h, h),
        (s = Vi(`${Qc.capitalize(u)} Attractor`, o.anchor)),
        (r.attractor[u] = s),
        console.log(`Pushed ${s.name} in attractor ${u}`),
        t.push(s);
    }),
    (o = new gm()),
    o.geneticAlgorithmWithAdaptiveLandscape(400, 200, 0.1),
    o.anchor.scale.set(1 / 8.5, 1 / 8.5, 1 / 8.5),
    o.anchor.position.set(0, -0.5, 0),
    (s = Vi("Fitness Landscape", o.anchor)),
    (r["fitness-landscape"] = s),
    t.push(s),
    (o = P0(4)),
    o.anchor.scale.set(1 / 5.5, 1 / 5.5, 1 / 5.5),
    o.anchor.position.set(0, -0.7, 0),
    (o.light.intensity = 1),
    (s = Vi("Tree", o.anchor)),
    (r.tree = s),
    t.push(s),
    (o = new mm()),
    o.generate(),
    o.anchor.scale.set(1 / 50, 1 / 50, 1 / 50),
    (s = Vi("TSP", o.anchor)),
    (r.tsp = s),
    t.push(s),
    (o = new dm(e)),
    o.create(),
    o.anchor.scale.set(1 / 20, 1 / 20, 1 / 20),
    o.anchor.remove(o.hitbox.mesh);
  let c = o;
  return (
    (s = Vi("Boids", o.anchor)),
    (r.boids = s),
    t.push(s),
    (i = new Vc({ canvas: n, antialias: !0 })),
    i.setPixelRatio(window.devicePixelRatio),
    i.setClearColor(6308307, 0),
    i.setScissorTest(!0),
    {
      previewScenes: r,
      allPreviewScenes: t,
      previewRenderer: i,
      previewBoids: c,
    }
  );
}
let Hn,
  kt,
  zn,
  ar,
  Ki = document.getElementById("c"),
  So,
  ha,
  hs,
  ia = !1,
  GL = Date.now(),
  aa,
  xp = 0,
  Rc,
  O0,
  wr,
  Fc,
  da,
  bp,
  Uo = [],
  Qi,
  mn = 0,
  ds,
  Pc,
  Lc;
const ui = {
  anchors: [],
  hitbox: [],
  spongehitbox: [],
  push(n, e = !1) {
    this.anchors.push(n.anchor),
      n.hitbox && this.hitbox.push(n.hitbox.mesh),
      e && this.spongehitbox.push(n.hitbox.mesh);
  },
  remove(n, e) {
    let t = this.hitbox.findIndex((i) => i === n);
    if (t !== -1) {
      let i = this.anchors.splice(t, 1);
      this.hitbox.splice(t, 1),
        Un.removeInstance(n),
        (Uo = Uo.filter((a) => a.anchor !== i[0])),
        e.remove(i[0]);
    }
    this.spongehitbox.findIndex((i) => i === n) !== -1 &&
      this.spongehitbox.splice(t, 1);
  },
  clearWorld(n) {
    this.anchors.forEach((e) => n.remove(e)),
      (this.hitbox = []),
      (Un.instances = []),
      this.push({ anchor: So, hitbox: ha });
  },
};
let Rr = "view",
  Bo = !0,
  pa = "attractor",
  zo = "lorenz",
  Jr,
  ko = !1,
  yo = 0;
const au = new Re(
  new di(1, 8, 8),
  new Or({ color: 15450995, transparent: !0, opacity: 0.2 })
);
au.add(
  new Re(
    new di(0.6, 5, 5),
    new Or({ color: 6688739, transparent: !0, opacity: 0.3 })
  )
);
au.add(new os(15450995, 100, 3));
$L();
U0();
function VL() {
  (Rr = Rr === "edit" ? "view" : "edit"), Rr == "edit" ? WL() : qL();
}
function WL() {
  kt.add(da), kt.add(Qi.gridHelper);
}
function qL() {
  kt.remove(da), kt.remove(Qi.gridHelper), mn++;
}
function _p() {
  (Bo = !Bo), Un.toggleDebug();
}
function $L() {
  (Hn = new an(45, window.innerWidth / window.innerHeight, 1, 1e4)),
    Hn.position.set(0, 800, 1300),
    Hn.lookAt(0, 0, 0),
    (kt = new Zp());
  const e = new $w().load("/la-fabrique-des-mondes/assets/fond.png", () => {
      (e.mapping = Mo), (e.colorSpace = gt), (kt.background = e), mn++;
    }),
    t = new mt(50, 50, 50);
  (bp = new Vn({ color: 13601266, opacity: 0.5, transparent: !0 })),
    (da = new Re(t, bp)),
    kt.add(da),
    (async () => {
      (Qi = new zL()),
        Qi.buildGround(),
        kt.add(Qi.anchor),
        kt.add(Qi.gridHelper),
        console.log("Ground successfully built.");
    })(),
    (ia = new lm()),
    (hs = new De());
  const i = new ga(1e3, 1e3);
  i.rotateX(-Math.PI / 2),
    (So = new Re(i, new Vn({ visible: !1 }))),
    kt.add(So),
    (ha = new Un(i)),
    ui.push({ anchor: So, hitbox: ha }, !0);
  const a = new Zw(6316128, 3);
  kt.add(a),
    (aa = new cm(16777215, 1)),
    aa.position.set(1, 0.75, 0.5).normalize(),
    kt.add(aa),
    B0(),
    (zn = new Vc({ antialias: !0, preserveDrawingBuffer: !0 })),
    zn.setPixelRatio(window.devicePixelRatio),
    zn.setSize(window.innerWidth, window.innerHeight),
    document.body.appendChild(zn.domElement),
    document.addEventListener("pointermove", XL),
    document.addEventListener("pointerdown", ZL),
    document.addEventListener("keydown", QL),
    document.addEventListener("keyup", eI);
  let s = new fm(Hn, zn.domElement);
  (s.enableDamping = !0),
    (s.dampingFactor = 0.1),
    (s.rotateSpeed = 0.5),
    s.addEventListener("change", () => {
      mn++;
    }),
    (Jr = new Qw(Hn, zn.domElement)),
    kt.add(Jr),
    _p(),
    dE();
  let o = !1;
  document
    .querySelector(".popup-content button")
    .addEventListener("click", function () {
      o && (Rr = "edit"), (o = !0);
    }),
    (async () => {
      console.log("Building UI Listeners..."),
        (async () => {
          (ds = document.querySelectorAll(".selectObject")),
            ds.forEach((h) => {
              h.addEventListener("click", function () {
                pa = h.value;
              }),
                console.log(h);
            });
        })().then("Buttons built"),
        document
          .querySelector(".selectAttractor")
          .addEventListener("change", function (h) {
            zo = h.target.value;
          }),
        (async () => {
          document.querySelectorAll(".menuButton").forEach((h) => {
            switch (h.classList[0]) {
              case "selectMode":
                h.addEventListener("click", function (d) {
                  VL(),
                    Rr == "view"
                      ? ((d.target.innerHTML = "View mode"),
                        (d.target.style.backgroundColor = "#ebc373"))
                      : Rr == "edit" &&
                        ((d.target.innerHTML = "Edit mode"),
                        (d.target.style.backgroundColor = "#cf89f2"));
                });
                break;
              case "debugMode":
                h.addEventListener("click", function (d) {
                  _p(),
                    Bo
                      ? ((d.target.innerHTML = "Enabled debug mode"),
                        (d.target.style.backgroundColor = "#cf89f2"))
                      : ((d.target.innerHTML = "Disabled debug mode"),
                        (d.target.style.backgroundColor = "#ebc373")),
                    mn++;
                });
                break;
              case "clear":
                h.addEventListener("click", function (d) {
                  YL(), (ko = !1), mn++;
                });
                break;
              case "screenshot":
                h.addEventListener("click", function () {
                  fE(zn);
                });
                break;
            }
          });
        })().then(() => console.log("Set menu buttons.")),
        window.addEventListener("resize", jL),
        (async () => {
          (Pc = document.querySelector(".card")),
            (Lc = document.querySelector(".prev"));
        })().then(() => console.log("Built preview"));
    })().then(() => console.log("Built UI Listeners.")),
    setTimeout(async () => {
      let u = await HL(Ki, au);
      (Rc = u.previewScenes),
        (O0 = u.allPreviewScenes),
        (wr = u.previewRenderer),
        (Fc = u.previewBoids),
        console.log("Preview scenes loaded.");
    }, 2e3),
    requestAnimationFrame(z0),
    console.log("Ready!");
}
function jL() {
  (Hn.aspect = window.innerWidth / window.innerHeight),
    Hn.updateProjectionMatrix(),
    zn.setSize(window.innerWidth, window.innerHeight),
    mn++;
}
function XL(n) {
  if (Rr == "edit") {
    hs.set(
      (n.clientX / window.innerWidth) * 2 - 1,
      -(n.clientY / window.innerHeight) * 2 + 1
    ),
      ia.setFromCamera(hs, Hn);
    const e = ia.intersectObjects(
      pa === "sponge" ? ui.spongehitbox : [ha.mesh],
      !1
    );
    if (e.length > 0) {
      const t = e[0];
      da.position.copy(t.point).add(t.face.normal),
        da.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25),
        mn++;
    }
  }
}
function YL() {
  ui.clearWorld(kt);
}
function ZL(n) {
  if (
    (hs.set(
      (n.clientX / window.innerWidth) * 2 - 1,
      -(n.clientY / window.innerHeight) * 2 + 1
    ),
    ia.setFromCamera(hs, Hn),
    Rr === "edit")
  ) {
    if (n.button === 0) {
      const e = ia.intersectObjects(
        pa === "sponge" ? ui.spongehitbox : [ha.mesh],
        !1
      );
      if (e.length > 0) {
        const t = e[0];
        KL(t);
      }
    } else if (n.button === 2) {
      const e = ia.intersectObjects(ui.hitbox, !1);
      if (e.length > 0) {
        const t = e[0];
        JL(t);
      }
    }
    mn++;
  }
}
function JL(n) {
  console.log(n.object),
    n.object && n.object !== ha.mesh && ui.remove(n.object, kt),
    mn++;
}
const wp = [16777215, 16740351, 16740351, 16173391];
function KL(n) {
  let e,
    t = 50;
  switch (pa) {
    case "sponge":
      (e = new pm(Jr)),
        e.create(2),
        e.anchor.scale.set(t, t, t),
        (e = xo(e, n, !0));
      break;
    case "attractor":
      e = new vm(Jr);
      const { loopNb: r, scale: i } = I0(zo);
      e.instantDraw(zo, r),
        e.anchor.scale.set(i, i, i),
        (e = xo(e, n, !0)),
        (e.anchor.position.y = Math.random() * (500 - 200) + 200),
        (e.anchor.rotation.x = Math.random() * Math.PI * 2),
        (e.anchor.rotation.y = Math.random() * Math.PI * 2);
      break;
    case "tree":
      const a = wp[Math.floor(Math.random() * wp.length)];
      (e = P0(4, Jr, a, 1773570)),
        (t = t / 2),
        e.anchor.scale.set(t, t, t),
        (e = xo(e, n, !1)),
        (e.anchor.rotation.y = Math.random() * Math.PI * 2);
      break;
    case "fitness-landscape":
      (e = new gm(Jr)),
        e.geneticAlgorithmWithAdaptiveLandscape(400, 200, 0.1),
        (t /= 8.5),
        e.anchor.scale.set(t, t, t),
        (e = xo(e, n, !0)),
        (e.anchor.position.y = 0);
      break;
    case "tsp":
      (e = new mm()),
        e.generate(),
        (e.anchor.position.x = wh(n.point.x)),
        (e.anchor.position.z = wh(n.point.z)),
        (e.anchor.position.y = cE(n.point.x, n.point.z)),
        (t = t / 3),
        e.anchor.scale.set(t, t, t);
      break;
    case "boids":
      (e = new dm(au, Jr)),
        e.create(),
        (e.anchor.position.y = Math.random() * 400 + 500),
        (t /= 3),
        e.anchor.scale.set(t, t, t),
        (ko = !0),
        Uo.push(e);
      break;
  }
  kt.add(e.anchor), ui.push(e, pa === "sponge"), mn++;
}
function xo(n, e, t) {
  let r = e.point.add(e.face.normal);
  return (
    t && r.divideScalar(50).floor().multiplyScalar(50).addScalar(25),
    n.anchor.position.add(r),
    n
  );
}
function QL(n) {
  switch (n.keyCode) {
    case 16:
      isShiftDown = !0;
      break;
  }
}
function eI(n) {
  switch (n.keyCode) {
    case 16:
      isShiftDown = !1;
      break;
  }
}
function U0() {
  zn.render(kt, Hn), Bo && console.log(zn.info.render);
}
function tI() {
  const n = Ki.clientWidth,
    e = Ki.clientHeight;
  (Ki.width !== n || Ki.height !== e) && wr.setSize(n, e, !1);
}
function nI() {
  ar.name === "Boids" && (Fc.update(), Fc.render()),
    O0.filter((n) => n !== ar).forEach((n) => {
      n.userData.root.style.display = "none";
    }),
    (ar.userData.root.style.display = "inline"),
    tI(),
    (Ki.style.transform = `translateY(${window.scrollY}px)`),
    console.log(`Animating ${ar.name}`),
    rI(ar);
}
function B0() {
  if (aa) {
    const n = Date.now(),
      e = (n - GL) / 1e3,
      t = 60 * 5,
      r = 2 + 1.5 * Math.sin((e / t) * Math.PI);
    (aa.intensity = r),
      aa.updateMatrixWorld(),
      mn++,
      n - xp >= 2e3 && ((xp = n), setTimeout(B0, 2e3));
  }
}
function z0() {
  mn > 0 || (ko && yo >= 0)
    ? (Uo.forEach((n) => {
        for (let e = 0; e <= yo; e++) n.update();
        n.render();
      }),
      U0(),
      (mn = 0),
      (yo = 0))
    : ko && yo++,
    ar && ar.userData.element.display !== "none" && nI(),
    requestAnimationFrame(z0);
}
ds.forEach((n) => {
  n.addEventListener("click", function () {
    (pa = this.value),
      ds.forEach((e) => {
        e.classList.remove("active");
      }),
      this.classList.add("active");
  });
});
const $r = document.querySelector(".dynamic-content", "prev");
ds.forEach((n) => {
  n.addEventListener("mouseover", function () {
    const e = this.value;
    switch ((console.log(`Hovering ${e}`), e)) {
      case "sponge":
        $r.innerHTML =
          "<span class='aspect'>🧽 L'architecte s'est laissé guider par la fascinante géométrie de la Menger Sponge pour concevoir ces magnifiques immeubles, transformant ainsi une source d'inspiration infinie en une réalité architecturale extraordinaire.</span>";
        break;
      case "attractor":
        $r.innerHTML =
          "<span class='aspect'>🌌 Les attracteurs étranges ont donné naissance à de magnifiques galaxies dans nos ciels étoilés, où les lois de la physique se mêlent à l'art pour créer des constellations mystérieuses et captivantes !</span>";
        break;
      case "fitness-landscape":
        $r.innerHTML =
          "<span class='aspect'>🏔️ Nos ingénieurs paysagistes ont conçu une 'Fitness Map' innovante qui a transformé nos paysages en de superbes reliefs, créant ainsi des sommets majestueux pour les amateurs d'aventure.</span>";
        break;
      case "tree":
        $r.innerHTML =
          "<span class='aspect'>🌳🌸 Nos jardiniers ont conçu des L-Systems pour transformer vos écrans en jardins numériques où les pixels fleurissent en branches et fleurs de cerisier japonais.</span>";
        break;
      case "tsp":
        $r.innerHTML =
          "<span class='aspect'>✨ Les TSP se transforment en constellations ! Transformez vos problèmes de voyageurs de commerce en étoiles scintillantes et illuminez le ciel de votre monde.</span>";
        break;
      case "boids":
        $r.innerHTML =
          "<span class='aspect'>🚀 Les Boids font les stars ! En les introduisant dans ton monde, tu donnes vie à un univers astral incroyable ! Imaginez vous dans Star Wars, mais avec des boids qui planent plutôt que des vaisseaux intergalactiques…</span>";
        break;
      default:
        $r.innerHTML = "";
    }
    (ar = e === "attractor" ? Rc[e][zo] : Rc[e]),
      (Pc.style.display = "inline-block"),
      (Lc.style.display = "inline-block");
  }),
    n.addEventListener("mouseout", function () {
      (ar = void 0), (Pc.style.display = "none"), (Lc.style.display = "none");
    });
});
function rI(n) {
  n.children[0].rotation.y = Date.now() * 0.001;
  const t = n.userData.element.getBoundingClientRect();
  if (
    t.bottom < 0 ||
    t.top > wr.domElement.clientHeight ||
    t.right < 0 ||
    t.left > wr.domElement.clientWidth
  )
    return;
  const r = t.right - t.left,
    i = t.bottom - t.top,
    a = t.left,
    s = wr.domElement.clientHeight - t.bottom;
  wr.setViewport(a, s, r, i), wr.setScissor(a, s, r, i);
  const o = n.userData.camera;
  wr.render(n, o);
}
